<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS开发/Swift 中的 some 和 any 关键字</title>
    <url>/2023/04/25/iOS%E5%BC%80%E5%8F%91/Swift%20%E4%B8%AD%E7%9A%84%20some%20%E5%92%8C%20any%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<hr>
<p>title: Swift 中的 some 和 any 关键字<br>date: 2023-04-26<br>category: iOS开发<br>description: “some 代表了不透明类型（opaque type），any 代表存在类型（existential type）”<br>tags:  [Swift]</p>
<hr>
<p>从定义出发，some 代表了不透明类型（opaque type），而 any 代表存在类型（existential type）。</p>
<p>如果用一句概括的话，some 代表存在某个具体类型，这个具体类型遵循了某种协议的约束，并且这个具体类型是可以在编译期确定的，而 any 代表任意一种满足某种协议约束的类型，但这个类型具体是什么，必须要在运行时才能确定。</p>
<h1 id="some-关键字"><a href="#some-关键字" class="headerlink" title="some 关键字"></a>some 关键字</h1><p>some 关键字是在 Swift 5.1 跟随 SwiftUI 的发布出现的，我们最常见到的 some 的使用如下所示</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    ···       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在这里，some 主要起到的作用是为了减少类型定义的理解难度，body 内部可以返回任意一种 SwiftUI 定义的 View，但对外部调用者而言，其实并不关心 View 的具体类型，只要编译器确保返回值确实是 View 类型即可。因此 some View 就可以很好的表达这种 ”我不关心你是什么具体类型，只要编译器知道你的类型就可以” 的含义。</p>
<h2 id="Self-约束"><a href="#Self-约束" class="headerlink" title="Self 约束"></a>Self 约束</h2><p>让我们看一段代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Food</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meat</span>: <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Unit</span> = <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vegetable</span>: <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Unit</span> = <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">(<span class="number">_</span> food: Food)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> m = food <span class="keyword">as</span>? <span class="type">Meat</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(m)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> v = food <span class="keyword">as</span>? <span class="type">Vegetable</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        eat(<span class="type">Meat</span>())</span><br><span class="line">        eat(<span class="type">Vegetable</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以编译通过，可以看到我们的 eat 函数接受一个 “Food 类型” 的参数，并在内部将其转化成不同类型的 Food，但实际上更确切的说这里接受的应该是遵循 Food 协议的类型，由于 Food 协议并没有特殊性，所以这样的代码目前是可以通过编译的。</p>
<p>但如果我们将 Food 修改为这样的实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Food</span>: <span class="title">Equatable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们要求 Food 遵循 Equatable 协议，Equatable 协议的定义如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它有一个静态方法需要传入类型为 Self 的参数，类似这种类型的函数参数，我们称为 <strong>Self 约束</strong>，针对这种情况，一开始定义的 eat 函数就会报错，原因是在缺乏额外信息的情况下，我们并不能确定出 food 的具体类型，如此一来，Equatable 要求的 Self 类型也无法推断出来。</p>
<p>可以想象一个简单的例子，如果我们在 eat 函数内部也有一个遵循 Food 类型的变量 a，那么变量 a 实际上是否能够和 food 参数判等是不能确定的，如果运行时传入的 food 和 a 的类型一样自然可以判等，但如果类型不一样就不能判等，我们就不能简单用一句 <code>a == food</code> 来实现我们的逻辑，这样 Equatable 协议就失去了它希望表达的两者可以判等的意图。</p>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>接下来我们重新定义我们的 Food 协议</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Food</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Unit</span>: <span class="type">Hashable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里用到了关联类型，也就是 Unit，这样也会导致 eat 函数不能编译通过，原因和上面类似，因为有了关联类型 Unit 的存在，我们不能单纯从 Food 协议本身确定出具体类型，需要更多信息来确定。</p>
<h2 id="反向泛型"><a href="#反向泛型" class="headerlink" title="反向泛型"></a>反向泛型</h2><p>上面两种情况我们都可以用 some 关键字来解决编译问题，也就是类似下面这样</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">(<span class="number">_</span> food: some Food)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> m = food <span class="keyword">as</span>? <span class="type">Meat</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> v = food <span class="keyword">as</span>? <span class="type">Vegetable</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它其实和用泛型约束实现是一个效果</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eat</span>&lt;F: Food&gt;<span class="params">(<span class="number">_</span> food: F)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> m = food <span class="keyword">as</span>? <span class="type">Meat</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> v = food <span class="keyword">as</span>? <span class="type">Vegetable</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这两者又有所区别，让我们看看下面的代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> -&gt; some <span class="type">Food</span> &#123;</span><br><span class="line">    <span class="type">Vegetable</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span>&lt;F: Food&gt;<span class="params">()</span></span> -&gt; <span class="type">F</span> &#123;</span><br><span class="line">    <span class="type">F</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，函数 a 和 b 看起来实现了一样的效果，都是返回遵循 Food 协议的类型实例，但 b 函数返回的具体类型实际上取决于调用者，比如下面代码虽然都调用了 b 函数，但是返回值类型分别是 Vegetable 和 Meat。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable: <span class="type">Vegetable</span> = b()</span><br><span class="line"><span class="keyword">let</span> meat: <span class="type">Meat</span> = b()</span><br></pre></td></tr></table></figure>

<p>而 some 则不一样，无论是谁调用 a 函数，a 函数返回值类型都由 a 函数自身实现决定，在这里也就是 Vegetable 类型，这种由实现方决定具体返回类型的方式，又被称为“反向泛型”（reverse generics）。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>由于 some 关键字所解决的问题实际上是一种特定问题，所以大部分开发场景我们大概不会用到 some 关键字，我在这里总结了一些可能的使用场景</p>
<ul>
<li>如果一个泛型参数只在一个地方使用，可以用 some 代替它以提升代码可读性，类似前面的 eat 函数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">(<span class="number">_</span> food: some Food)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eat</span>&lt;F: Food&gt;<span class="params">(<span class="number">_</span> food: F)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作为模块的开发者，希望对外隐藏接口的返回值类型，例如上面所举的 a 函数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> -&gt; some <span class="type">Food</span> &#123;</span><br><span class="line">    <span class="type">Vegetable</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类型过于复杂，并且对于开发者而言没有太大意义，只需要编译器知晓类型的信息即可</li>
</ul>
<p>例如，在 Combine 中，多个 Operator 叠加后的 Publisher 类型会非常复杂，而开发者并不需要关心具体类型，some 关键字就可以派上用场</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">somePublisher</span><span class="params">()</span></span> -&gt; some <span class="type">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">        .publisher</span><br><span class="line">        .flatMap &#123; $<span class="number">0</span>.publisher &#125;</span><br><span class="line">        .<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 p1 的类型为</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Publishers</span>.<span class="type">Map</span>&lt;<span class="type">Publishers</span>.<span class="type">FlatMap</span>&lt;<span class="type">Publishers</span>.<span class="type">Sequence</span>&lt;[<span class="type">Int</span>], <span class="type">Never</span>&gt;, <span class="type">Publishers</span>.<span class="type">Sequence</span>&lt;[[<span class="type">Int</span>]], <span class="type">Never</span>&gt;&gt;, <span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="返回值一致性"><a href="#返回值一致性" class="headerlink" title="返回值一致性"></a>返回值一致性</h2><p>使用 some 关键字有一个需要注意的地方是，当作为返回值修饰词时，some 要求整个方法的返回值是唯一确定的类型，例如下面的代码就是不合法的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCollection</span><span class="params">()</span></span> -&gt; some <span class="type">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">Int</span>.random(<span class="keyword">in</span>: <span class="number">0</span>...<span class="number">10</span>).isMultiple(of: <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"0"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体报错信息是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Function declares an opaque return type 'some Collection', but the return statements in its body do not have matching underlying types</span><br></pre></td></tr></table></figure>

<p>因为这个函数的返回值类型可能是 Int 数组也可能是字符串数组，这样编译阶段就无法确定 makeCollection 的返回值类型，换句话说，some 表达的是存在且只存在一种确定的类型，假如希望返回不同类型的值，可以用到后面的 any 关键字。</p>
<p>当然如果是支持泛型约束的函数，也可以用 some 关键字修饰，比如下面的代码就是合法的，这是因为泛型函数本身的类型通过泛型参数 T 是可以唯一确定的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCollection</span>&lt;T&gt;<span class="params">()</span></span> -&gt; some <span class="type">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="type">T</span>]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="any-关键字"><a href="#any-关键字" class="headerlink" title="any 关键字"></a>any 关键字</h1><p>any 关键字是 Swift 5.6 引入的，any 修饰的协议类型称为存在类型，也叫做盒子类型，它表达的意思是某个对象具体的类型需要在运行时阶段确定，编译期只能模糊确定它遵循某种协议，像是一个盒子，盒子里可以装任意符合条件的具体类型，也就是”存在类型”的含义。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0932cb8cf7174473a0bf26361335c9df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt=""></p>
<p>但存在类型由于需要在运行时阶段才能确定具体类型和内存分布，因此编译器无法针对存在类型做更多有效的优化，比如泛型特化(Specialization)，以及方法调用时只能采用动态派发而不是直接静态派发的方式，所以性能上会有损耗。Swift 为了让开发者意识到使用存在类型存在的这种性能损耗，所以强制让开发者在使用存在类型时加上关键字，换句话说，any 的存在并没有在编译层面起到太多作用，更多是为了提醒开发者。</p>
<p>这种存在类型的使用是很常见，例如下面的代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Food</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">(<span class="number">_</span> food: Food)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Country</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">meet</span><span class="params">(<span class="number">_</span> person: Person)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Unit</span>: <span class="title">Equatable</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(<span class="number">_</span> a: Unit, <span class="number">_</span> b: Unit)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>其中，meet 和 compare 函数在 Swift 5.7 都会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Use of protocol 'Person' as a type must be written 'any Person'</span><br><span class="line"></span><br><span class="line">Use of protocol 'Unit' as a type must be written 'any Unit'</span><br></pre></td></tr></table></figure>

<p>而 eat 函数虽然也用到了存在类型，但是 Swift 团队计划在 Swift 6 再提示编译错误。</p>
<p>any 确实可以去除上述编译报错，但是 Swift 团队的本意其实是希望尽可能少使用 any ，或者说尽可能少使用存在类型，转而用泛型和具体类型实现相同的逻辑。</p>
<p>我们可以将前面的代码改写为下述代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Food</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">(<span class="number">_</span> food: some Food)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Country</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">meet</span><span class="params">(<span class="number">_</span> person: some Person)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Unit</span>: <span class="title">Equatable</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span>&lt;U: Unit&gt;<span class="params">(<span class="number">_</span> a: U, <span class="number">_</span> b: U)</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>这会让我们的代码语义更明确，同时在编译阶段也能确定函数接受的具体类型参数。</p>
<p>事实上，大部分场景下，any 关键字都可以用泛型、具体类型、不透明类型来代替，功能上没有什么区别，而性能上优于存在类型，目前可以想到的只能用 any 关键字的地方，是某些需要返回不同类型的场景，例如下面的代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeFood</span><span class="params">()</span></span> -&gt; any <span class="type">Food</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ... &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Meat</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Vegetable</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://www.avanderlee.com/swift/some-opaque-types/" target="_blank" rel="noopener">Some keyword in Swift: Opaque types explained with code examples</a></li>
<li><a href="https://swiftsenpai.com/swift/understanding-some-and-any/" target="_blank" rel="noopener">Understanding the “some” and “any” keywords in Swift 5.7 - Swift Senpai</a></li>
<li><a href="https://juejin.cn/post/7119062263406788616" target="_blank" rel="noopener">【译】Understanding the “some” and “any” keywords in Swift 5.7 - 掘金</a></li>
<li><a href="https://www.donnywals.com/what-is-the-some-keyword-in-swift/" target="_blank" rel="noopener">What is the “some” keyword in Swift? – Donny Wals</a></li>
<li><a href="https://www.donnywals.com/what-is-the-any-keyword-in-swift/" target="_blank" rel="noopener">What is the “any” keyword in Swift? – Donny Wals</a></li>
<li><a href="https://juejin.cn/post/7116463990724624421" target="_blank" rel="noopener">【译】What is the “any” keyword in Swift? - 掘金</a></li>
<li><a href="https://www.donnywals.com/what-are-primary-associated-types-in-swift-5-7/" target="_blank" rel="noopener">What are primary associated types in Swift 5.7? – Donny Wals</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0346-light-weight-same-type-syntax.md" target="_blank" rel="noopener">swift-evolution/0346-light-weight-same-type-syntax.md at main · apple/swift-evolution · GitHub</a></li>
<li><a href="https://juejin.cn/post/6993316954916257822" target="_blank" rel="noopener">【Swift-不透明类型】从SwiftUI看some关键字 - 掘金</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>iOS开发/Swift 并发中 Task 隐式捕获 self 的问题</title>
    <url>/2023/04/24/iOS%E5%BC%80%E5%8F%91/Swift%20%E5%B9%B6%E5%8F%91%E4%B8%AD%20Task%20%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7%20self%20%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<p>title: Swift 并发中 Task 隐式捕获 self 的问题<br>date: 2023-04-24<br>category: iOS开发<br>description: “Task 会隐式捕获 self 但没有编译提示，在大部分场景下这种特性并没有问题，但是遇到无限异步序列时容易造成循环引用问题”<br>tags:  [Swift, Swift 并发]</p>
<hr>
<h1 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h1><p>Swift Concurrency 的 Task 有两个常用的初始化方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(priority: <span class="type">TaskPriority?</span> = <span class="literal">nil</span>, operation: @escaping @<span class="type">Sendable</span> () async -&gt; <span class="type">Success</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">detached</span><span class="params">(priority: TaskPriority? = <span class="literal">nil</span>, operation: @escaping @Sendable <span class="params">()</span></span></span> async -&gt; <span class="type">Success</span>) -&gt; <span class="type">Task</span>&lt;<span class="type">Success</span>, <span class="type">Failure</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，两个方法的 <code>operation</code> 参数都是用 @escaping 修饰的，意味着 operation 是一个逃逸闭包，逃逸闭包会在声明后延长生命周期再执行，因此如果在一个类当中使用 Task，Task 内部又调用了类的方法，就会造成对 self 的隐式捕获。</p>
<p>这种 self 的隐式捕获是一个很常见的问题，例如下面的代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            handle()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们用到了 GCD 调用 handle 方法，如果直接这样写就会触发 Xcode 的编译错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Call to method 'handle' in closure requires explicit use of 'self' to make capture semantics explicit</span><br></pre></td></tr></table></figure>

<p>这是因为 Xcode 希望开发者通过显式调用 self.handle 的方式，提醒开发者这里发生了隐式捕获。需要注意的是，隐式捕获并不一定会造成内存泄漏，例如在这里，隐式捕获仅仅会因为捕获 self，导致 self 的生命周期延长到了下一个 runloop，一旦 GCD 执行结束，self 就可以正常释放，所以这里可以简单改为</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.handle()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在 Task 这里，情况有些不同，对于下面的代码，Xcode 是不会有任何提示的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            handle()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为前面提到的 Task 的两个初始化方法，在源码内部实际上会用 <code>_implicitSelfCapture</code> 关键词修饰 operation，<code>_implicitSelfCapture</code> 关键词可以让被修饰的 block 捕获 self 而不会触发显式捕获的错误，因为 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md#implicit-self" target="_blank" rel="noopener">Swift Concurrency 的设计者认为</a>，显式捕获 self 的意图是为了发现隐藏的循环引用，而 Task 的闭包会被 <strong>立即执行</strong>，所以看起来并不需要传递这种意图。</p>
<blockquote>
<p>The intent behind requiring self. when capturing self in an escaping closure is to warn the developer about potential reference cycles. The closure passed to Task is executed immediately, and the only reference to self is what occurs in the body. Therefore, the explicit self. isn’t communicating useful information and should not be required.  </p>
</blockquote>
<h1 id="隐式捕获的问题"><a href="#隐式捕获的问题" class="headerlink" title="隐式捕获的问题"></a>隐式捕获的问题</h1><p>看起来确实是这样，Task 通常情况下，包括在前面提到的场景下，都是会立即执行并结束的，它最多可能只会延长 self 的生命周期，并不会发生循环引用。</p>
<p>但在一些特殊情况下，这种预想就失效了，比如如果遇到了无限的异步序列 (AsyncSequence)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">            <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">                <span class="built_in">print</span>(notification)</span><br><span class="line">                handle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 Task 内部的 operation 监听了应用进入后台的通知，并通过 for await 对  notifications 异步序列进行了监听，也没有增加监听停止的条件，这样的代码就会造成 self 无法被释放。进一步分析会发现，这里真正捕获 self 的并不是 <strong>最外层的 Task</strong>，之所以这样说是因为如果我们将代码改为下面的形式，内存泄漏依然存在。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            await <span class="keyword">self</span>?.observeAppEnterBackground()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">observeAppEnterBackground</span><span class="params">()</span></span> async &#123;</span><br><span class="line">        <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">        <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">            <span class="built_in">print</span>(notification)</span><br><span class="line">            handle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在初始化 Task 时，我们通过捕获列表已经将 self 弱引用捕获了，但是执行代码后， TestView 仍然无法释放。</p>
<p>实际上真正引发泄漏的是下面的代码，我们通过 for await 遍历无限异步序列 notifications，相当于代码陷入了死循环，而每一次 await 操作又会隐式捕获 self，造成了 self 无法被释放，可以简单认为，每一次 await 操作都会隐式生成一个新的 Task，而新的 Task 又会捕获 self，这才是造成循环引用的原因。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">    <span class="built_in">print</span>(notification)</span><br><span class="line">    handle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><h2 id="弱捕获-self"><a href="#弱捕获-self" class="headerlink" title="弱捕获 self"></a>弱捕获 self</h2><p>既然明确了在监听无限序列时因为捕获 self 导致了循环引用，解决思路也就有了，最传统的方式就是类似 GCD 和闭包引用一样，我们通过捕获列表将 self 引用变为弱引用，从而避免 Task 持有 self。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">            <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                <span class="built_in">print</span>(notification)</span><br><span class="line">                <span class="keyword">self</span>.handle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，由于真正发生捕获行为的地方是在 for await 的地方，因此如果像下面这样弱引用 self，是不能解决内存泄漏问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">    <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">        <span class="built_in">print</span>(notification)</span><br><span class="line">        <span class="keyword">self</span>.handle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然通过 weakself 捕获， TestView 此时确实可以正常释放了，但是 Task 本身其实是脱离 TestView 的生命周期存在的，所以代码对 notifications 的监听并没有停止，验证这一点也很简单，我们将打印语句移动一下，就会发现即使 TestView 释放了，打印语句仍然会被执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">    <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">        <span class="built_in">print</span>(notification)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.handle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此正确的思路应该是取消 Task 执行。</p>
<h2 id="取消-Task"><a href="#取消-Task" class="headerlink" title="取消 Task"></a>取消 Task</h2><p>实际上 Swift Concurrency 并不推荐我们直接初始化一个 Task，因为这样初始化的 Task 是一个独立的根 Task，没有所属的父 Task，也就意味着 Task 的生命周期是独立存在的。Swift Concurrency 建议所有的 Task 都应该形成一个任务树，从而实现结构化编程。</p>
<blockquote>
<p>结构化编程：并发操作保证控制流路径的单一入口和单一出口  </p>
</blockquote>
<p>所以最合理的方式是这样修复。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task: <span class="type">Task</span>&lt;<span class="type">Void</span>, <span class="type">Never</span>&gt;?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        task?.cancel()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        task = <span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">            <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                <span class="built_in">print</span>(notification)</span><br><span class="line">                <span class="keyword">self</span>.handle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当 TestView 被释放时，对 UIApplication.didEnterBackgroundNotification 的监听也能正常取消。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://forums.swift.org/t/why-task-doesnt-need-explicit-use-of-self/58748/6" target="_blank" rel="noopener">Why Task { } doesn’t need explicit use of self? - #6 by AlexSedykh - Using Swift - Swift Forums</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md#implicit-self" target="_blank" rel="noopener">swift-evolution/0304-structured-concurrency.md at main · apple/swift-evolution · GitHub</a></li>
<li><a href="https://forums.swift.org/t/explicit-self-not-required-for-task-closures/54364/19" target="_blank" rel="noopener">Explicit self not required for Task closures? - #19 by kevinc - Using Swift - Swift Forums</a></li>
<li><a href="https://developer.apple.com/forums/thread/691814" target="_blank" rel="noopener">Swift 5.5 Task { … } weak self | Apple Developer Forums</a></li>
<li><a href="https://www.swiftwithvincent.com/blog/three-mistakes-to-avoid-with-async-await-in-swift" target="_blank" rel="noopener">3 mistakes to avoid with async / await — Swift with Vincent</a></li>
<li><a href="https://www.swiftbysundell.com/articles/memory-management-when-using-async-await/" target="_blank" rel="noopener">Memory management when using async/await in Swift | Swift by Sundell</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>关于美的本能——《乔布斯传》</title>
    <url>/2020/03/28/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E%E7%BE%8E%E7%9A%84%E6%9C%AC%E8%83%BD%E2%80%94%E2%80%94%E3%80%8A%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E3%80%8B/</url>
    <content><![CDATA[<p>很久以来乔布斯都是一个教父级的人物，或者更确切地说，是互联网行业的教父。他创建的苹果公司注定是 21 世纪最伟大的公司之一，iPhone、iPad、Mac、Ipod 也注定是 21 世纪最伟大的产品，所以关于他的传记也几乎出现在了每一个互联网从业者的书单里，至少我从微信读书里大概获得了这样一个粗略的统计结果。</p>
<p>但是我对人物传记类的书籍一直不是很感兴趣，另一方面对大众狂热吹捧或者推崇的事物也时常保持刻意的距离，希望不至于陷入被动思考的境地，所以直到最近才突然找到了这本《乔布斯传》，然后花了一个周读完了。</p>
<p>虽然我并不遗憾这么晚才读到这本书，但是尽管已经耳濡目染了无数次后人对乔布斯的评价，读完书以后我仍然能产生出重新认识他的感觉，这是一个值得敬仰的疯子，他热忱于改变世界，也真真切切地改变了世界，不止一次。</p>
<p>乔布斯关于产品的一个重要理念是，做创造用户需求、而非满足用户需求的产品，因为很多时候用户并不真正知道他们想要什么，除非将产品放到他们面前。如果只是为了满足用户当下的需求，真正改变世界的产品就永远还在幻想中。陷入对用户需求的追逐当中，产生出来的不是新事物，而是对原有事物的改善，这种改善有时候甚至是妥协，是从一开始就没有想清楚要解决的问题本质，盲目出发前进，然后一次次妥协于现实的问题，一点一点在错误的方向上修修补补。</p>
<p>如果个人电脑最开始仍然是以零散元件的形式售卖，需要用户自己拼装想要的计算机，那么计算机就不会成为一个大众消费品，而只能是一个小圈子里的事物，至于圈子外的事物，他们也不会想要计算机，因为他们根本不知道计算机能帮他们做什么。而 Apple I 则将计算机打包成一个整体，成为一个能够开箱即用的消费品，才将 PC 市场打开了新的广阔的天地，更多的人开始购买个人电脑，进而发掘出个人电脑的创造力和生产力。</p>
<p>而在产品的创造过程当中，乔布斯的特质又让产品免于陷入平庸和粗陋，书中强调过他的宗教信仰、使用迷幻药的经历对创造伟大产品的影响，但是我觉得这其实是一种对艺术的追求和对美的判断。艺术与美不是外部强加的，它应该是一种人的本能，而外部因素仅仅是唤醒了这种本能而已，因为如果是外部强加的，那么就会像宗教一样，最终产生出偏执和极端，但是人们对美的认识却是趋同的，对艺术的感悟也是如此，例如音乐、美术、雕塑、书法，不同地区、不同时代、不同文化背景的人都可以欣赏同样的艺术品。</p>
<p>乔布斯认为伟大的产品也应当如此，它应当由充满艺术与美的元素组成，并产生出任何人都可以由衷欣赏的事物，比如 iPhone 和 iPad，你可以认为它们不是十全十美的，但是你不能说服自己它们不够艺术性，尤其是当你真正接触过这些产品，目光扫过屏幕、手指触碰到金属机身、玻璃、实体按钮，你体会到的不仅仅是技术的先进性，还包括产品的创造者对美的理解与呈现，它能调动你的情绪，让你心生喜爱之情，而这恰好是艺术的体现。想一想一个不了解古典音乐的人，当他听到巴赫、贝多芬、门德尔松、布鲁赫，听到勃兰登堡协奏曲、命运交响曲，他也会产生情感的触动和情绪的波动，这是本能的唤醒，不需要他一定要信仰什么、经历什么。</p>
<p>另一方面，用户体验也是一种美的体现，这种体现更加注重统一和一致，当你在使用 iPhone 的应用程序时，你接触的是相同的视觉风格、操作体验、使用习惯，你会知道点击按钮可以进入下一页、弹窗会浮在页面最顶部、滑动列表能够预览更多内容，而这些在乔布斯眼里，必须依赖对硬件、软件、操作系统、应用程序的统一要求，从细节上又要足够细致入微、关注到产品的方方面面，即使是用户感知不到的地方也要保持一致的外观和设计，甚至是一致的实现机制。这样做出的 iPhone 和 iPad，即使是一个 5 岁小孩也可以快速上手，不需要任何用户手册的帮助，因为所有设计都满足人类最熟悉的规律和最本能的美的体验。</p>
<p>想想 iOS 上的第三方应用程序，虽然并非出自 Apple 工程师，但是上架前也必须经过 Apple 的审查，必须包含标志性的流程和元素，才能最终以统一的用户体验出现在任何一台 iPhone 上而不会令人唐突。很多人觉得这是乔布斯因幼年时期的领养导致的控制欲造成的，但是即使乔布斯过世了这么多年，苹果的产品仍然保持着一贯的统一性和封闭性，因为这已经成为了一种理念，它的出发点不是某一个人的特性，而是为了做出伟大的产品而确定的路线和方向，即使苹果没有选择这条路，也一定会有另一个香蕉或者菠萝公司会采取相似的理念，关键在于这种理念是否能够落实到公司的每个组织和每个产品线，能够在即使用户感知不到的地方也保持着高度认真的状态。</p>
<p>总之，在读完这本书以后，我开始反思，程序员和工程师的工作是不是也应该像乔布斯创造的产品一样，代码不仅仅是为了完成某个任务而堆砌起来的，它也应该具备足够的美感和艺术性，即使用户不能感知到 app 背后的工作，即使一坨屎山也能提供一样的功能，但是这样的产品很难不归于平庸，因为完成它的人没有将它看做是一件作品，而仅仅是一份工作、一场交易、一个任务。</p>
<p>在代码的设计上，不合理的设计是一眼就可以观察到的，那种纠缠不清的逻辑判断、零散冗杂的片段、模块间的藕断丝连，完全违背了人对世界的认识和掌控的规律，所以会让人觉得难懂和烦躁。至繁归于至简，复杂精密的电子元器件也可以有协调简单的外观，能让普通人去欣赏它，代码也同样可以达到即使是一个不懂编程的人也能欣赏到它的美与艺术的效果；它应该有统一的风格，有结构简单、内涵丰富、功能完备的逻辑，有符合美感和自然规律的架构；一个函数的段落感应该像音乐的旋律一样，在合适的地方短促而欢快，在合适的地方稍作休憩；多想想当其他人阅读自己代码的时候，希望他们拥有什么样的体验，尽可能简化这种体验，让它变得异常简单、唾手可得。最关键的，作为代码的主人，你应该有无微不至的控制欲，对看得见和看不见的地方负责。</p>
<p>致敬疯狂和伟大的产品，也致敬美的本能，我们实在太缺乏它们了，才会觉得原本理所应当的事情是人类的奇迹。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>什么造就了文明——《枪炮、病菌与钢铁：人类社会的命运》</title>
    <url>/2020/03/13/%E9%9A%8F%E7%AC%94/%E4%BB%80%E4%B9%88%E9%80%A0%E5%B0%B1%E4%BA%86%E6%96%87%E6%98%8E%E2%80%94%E2%80%94%E3%80%8A%E6%9E%AA%E7%82%AE%E3%80%81%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%EF%BC%9A%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90%E3%80%8B/</url>
    <content><![CDATA[<p>我玩过的时间最久的一款游戏是《Civilization V》（文明五），一开始还是在塞班系统上无意中接触到的手机版文明五，一上手就被它的游戏机制和玩法所吸引，进而在 PC 上完整地沉浸到文明五的棋盘上，从原版到神佑君王，从盘古大陆到大岛地图，再到真实地球，最初最爱玩中国的诸葛连弩，然后喜欢巴比伦和朝鲜的科技 UA，最后迷上了叶卡捷琳娜女王的双倍战略资源。一款游戏能够吸引玩家玩上十年也不觉得腻，甚至时不时还忍不住开一局，毫无疑问文明五的魅力是惊人的。</p>
<p>而最近读了贾雷德·戴蒙德的《枪炮、病菌与钢铁：人类社会的命运》（简称GGS）以后，我有一种强烈的感觉，文明五的作者 Sid Meier 老爷子一定也读过这本书，因为文明五当中有非常多设计理念和游戏机制与 GGS 的观点高度一致，甚至就是 GGS 观点的游戏版呈现，所以读起来倍感亲切。</p>
<p>GGS 主要阐述了一个问题：是什么造就了当今世界各个大陆和各个地区人类社会的不同？对于这个问题，主流的观点包括地区间科技发展的差异，文化的差异，甚至激进的民族天生差异和”人种论”，认为先进的文明之所以先进完全是因为生理学上的”先进性”导致的。作者则通过多个角度一一反驳了这一观点，并最终提出，造就人类社会差异性的不是人类生理学的差异，而是地理环境的差异，这种差异从几万年前人类还处于狩猎采集阶段开始就已经左右着人类社会的发展，并持续到了今天。</p>
<p>公元前一万年以前的地球上，人类的生存手段还是狩猎采集，通过采集野生植物、捕猎野生生物来补充食物，这种方式非常低效，并且严重依赖环境，造成的结果就是无法提供足够的食物以支持稳定的人口增长，也不能支持人类在一个地方长久定居下来。没有稳定的人口增长，就意味着不能形成高度分工、政治一体化、经济多样化的社会，没有长久定居，就不能产生陶器、水利和冶金等技术，进而无法产生文字和书写系统、轮子、城市和国家，也即我们常说的文明的概念。</p>
<p>那么什么时候开始，情况发生了转变呢？文明五的科技树可以体现这一点，文明五开局每个文明都默认自动获得一个科技——“农业”，科技树的起点就是从”农业”开始。也就是说，农业的产生标志着文明的诞生，这一点是显而易见的，农业让人类能够在一个地方定居下来，从而避免了四处颠簸居无定所，农业提供的稳定高效的食物产量允许人口进入稳定的增长阶段，从而扩大群体规模，从一开始的一小波采集者，慢慢形成村庄、村落，然后是部落、城镇，最终组成一个国家。</p>
<p><img src="/images/CIV5_agriculture.png" alt=""></p>
<p>但是农业并不是突然就在世界范围内风靡起来的，农业一开始只在地球上少数几个地方产生，包括新月沃地、中国、安第斯山脉等地区，这些地区大约在公元前8500年以后逐步诞生了大规模的农田和数目庞大的农民。那么为什么农业的起点只是这几个地方呢，是因为这些地方的人类有什么”先进性”吗？</p>
<p>并非如此，农业的集中出现绝不是一蹴而就的，不是有一天早晨，一个人类醒来，灵光一闪，”要不我们种地吧！”，然后全村人都跟着他一起种地。农业的出现必须伴随狩猎采集者对周围环境、野生动植物和气候的了解，也必须满足粮食生产的食物产量达到甚至超出狩猎采集的食物产量的苛刻条件，否则狩猎采集者就不会放弃狩猎采集的生活方式。</p>
<p>首先是野生动植物，我们通常认为地球是一个孕育生命的星球，有不计其数的物种在地球上生存繁衍，但是回到人类自身，我们每天的食谱上出现的物种又有多少？在这些可食用的物种当中，哪些又是蛋白质丰富、能充当主食的食物？这些物种自诞生时起就注定要成为人类的盘中餐吗？如果不是狩猎采集者长年累月在野外生存和摸索掌握了各种野生植物的毒性、营养、驯化特点，如果不是狩猎采集者冒着生命危险从野外将大型哺乳动物（牛、猪、羊）带回家中驯养，减轻了种田的人力负担，增加了蛋白质的摄入，农业就无从谈起。</p>
<p>但生命的残酷性在于，并不是只要付出努力就一定有回报，虽然一万多年前的地球上到处都是野生动植物和狩猎采集者，但是能够被人类驯化的野生植物和动物绝大多数都只在欧亚大陆出现，甚至只在欧亚大陆的部分区域出现，因而造就了寥寥几处农业发源地的出现。另一方面的残酷性在于地球的环境多种多样，地理差异非常巨大，有些地区如非洲撒哈拉沙漠、太平洋群岛、美洲的绵延山地，就算有了集中种植的农田，产量也非常低，难以维持生存，农业在当地无法对野生采集者形成优势，因而也不能出现农田、村庄和定居的农民。</p>
<p>所以农业产生的差异性并不是各地区人类的生理差异性，而完全是环境的差异性造成的，换句话说，一万年前的地球上，无论人类如何分布，粮食生产都注定只能在那几处产生。我们可以从另一方面来验证这个事实，那就是当欧亚大陆驯化的植物和大型哺乳动物传入到美洲的时候，美洲的农业迅速发展了起来，当耐寒的水稻传到了朝鲜半岛，增加了当地粮食产量以后，日本九州岛的狩猎采集者就逐渐被农民所代替。今天的南美洲是咖啡和甘蔗的主要产地，可实际上这两种植物分别是在非洲的埃塞俄比亚和亚洲的印度驯化的，如果一万年前美洲、非洲也和欧亚大陆一样有丰富的可驯化植物，有牛犁地，有马运输，那么十九世纪的殖民浪潮将不是从欧洲涌向美洲，而是从美洲涌向欧洲，贩卖奴隶的将不是欧洲诸国而是非洲。</p>
<p>农业产生了以后，科技树才能继续发展，科技的发展离不开传播，例如在欧亚大陆上，冶炼工艺、造纸术、罗盘甚至是语言文字一直有从发源地向四周扩散传播的现象，进而带动整个大陆的发展和人口增长，但是为什么这一现象并没有在美洲或非洲出现呢？原因还是跟环境有关，美洲和非洲的大陆主轴线是南北走向，而欧亚大陆是东西走向，东西走向的欧亚大陆大部分地区处于同一纬度，意味着在一个地方能够种植的植物可以很快移植到另一个地方，在一个地方适用的种植技术也能迅速传播到其他地方去，而这种传播作为载体，进而引发了人类的迁移和更多技术文化的传播。但是在非洲和美洲，南北主轴线甚至跨越了赤道，从极寒到酷暑，气候变化很大，非洲北部的植物和动物要传播到南非，要穿过撒哈拉沙漠和充满致命虫蚊的雨林，南美洲的植物则需要穿过狭长的中美洲地带才能到达北美洲。所以尽管从中国到法国的跨度远远超过了从北非到南非的距离，中国的瓷器、造纸术可以在几千年前就传播到西欧，而南非出现马和牛却是一千年内发生的事情。</p>
<p>还有一个因素也影响着科技文化的传播，那就是大陆之间的传播，这是很容易论证的，亚洲与欧洲的紧密连接带来了数千年繁荣的贸易和高频的交流，但欧亚大陆与美洲的交流则因为太平洋和大西洋的阻隔而彻底切断，直到哥伦布发现新大陆，两个大陆上的人类才历史性的走到了一起。但是传播和交流这些词还是显得有些”中性”，如果我们考虑发现新大陆以后的事情，会发现文明之间友好和谐的交流实在罕见，历史上更多的是弱肉强食和征服战争，想想文明五当中，两个文明签订一份科研协定需要多少前期准备，而点击宣战按钮则不需要任何条件。农业发展促进科技的进步，进而给欧洲带来了钢铁和枪炮武装的士兵，大型哺乳动物包括牛、猪、羊的圈养则将传染性疾病从动物身上带到了人类身上，而长期的驯养已经让欧亚大陆的人拥有了抵抗这些病菌的抗体。至于美洲的印第安人、爱斯基摩人、阿兹特克、印加帝国则什么也没有，它们的农业不够先进，没有驯化的动物，没有接触过鼠疫、流感，没有钢铁、枪炮，没有轮子和战车，甚至没有能够记录历史的文字，这种差异造就了欧洲对美洲的殖民、残忍的屠杀、大规模的瘟疫，以及欧洲人内心油然而生的高贵感，但其实如果在一万年前，我们将欧洲与美洲的狩猎采集者互相交换一下位置，今天我们看到的将仍然是同样的殖民、屠杀和瘟疫，以及所谓的高贵感。</p>
<p>我又想到了文明五当中的文明，每一个都有自己独特的特性、单位和建筑，游戏当中不存在开局必胜的文明，也没有绝对的文明对文明的碾压，决定每一局游戏发展和结局的，很大程度上是文明开局的地形以及采取的科技树、政策，是首发城市周围地块的粮食、产能、科技点，是奢侈资源的多寡，是接触到其他文明和城邦的便利性，是对资源、领土、军事力量的合理利用，而不是因为你是 XX 文明，所以你一定能在地图上横着走。</p>
<p>所以是什么造就了文明？不是枪炮、病菌和钢铁，也不是优良的生理特性和与生俱来的高贵血统，而是随机的环境差异和拥有想象力、创造力的人类自身，随机的环境带来迥异的外部因素，想象力和创造力带来永生的内部动力，一时的辉煌并不代表永远的辉煌，一时的落后也不代表永远的落后。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>WKWebView的TSL安全性校验</title>
    <url>/2019/07/08/iOS%E5%BC%80%E5%8F%91/WKWebView%E7%9A%84TSL%E5%AE%89%E5%85%A8%E6%80%A7%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>WKWebView 允许 native 介入到 HTTP 的验证流程，类似于 URLSession 一样对 Challenge 进行校验，具体代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> * _Nullable credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123; <span class="comment">// 非服务端校验流程，走默认</span></span><br><span class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>, <span class="literal">nil</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    <span class="keyword">int</span> err = SecTrustEvaluate(challenge.protectionSpace.serverTrust, &amp;result); <span class="comment">// 用系统证书进行服务端证书校验</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 证书校验失败</span></span><br><span class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>, <span class="literal">nil</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed) &#123;</span><br><span class="line">        <span class="comment">// 校验通过</span></span><br><span class="line">        <span class="comment">// kSecTrustResultProceed：验证成功，且该验证得到了用户认可(例如在弹出的是否信任的alert框中选择always trust)</span></span><br><span class="line">        <span class="comment">// kSecTrustResultUnspecified：验证成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书</span></span><br><span class="line">        <span class="built_in">NSURLCredential</span> *credential = [[<span class="built_in">NSURLCredential</span> alloc] initWithTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengeUseCredential</span>,credential);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 证书校验失败</span></span><br><span class="line">        completionHandler(<span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>, <span class="literal">nil</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接</p>
<p><a href="https://www.jianshu.com/p/ebee00c785bd" target="_blank" rel="noopener">iOS中HTTP/HTTPS授权访问(二)</a></p>
<p><a href="http://southpeak.github.io/2014/07/16/url-load-system-4/" target="_blank" rel="noopener">URL加载系统之四：认证与TLS链验证</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title>AFNetworking（二）AFNetworking对form-data请求体的处理</title>
    <url>/2019/01/20/AFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/AFNetworking%EF%BC%88%E4%BA%8C%EF%BC%89AFNetworking%E5%AF%B9form-data%E8%AF%B7%E6%B1%82%E4%BD%93%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>AFNetworking 发送 GET、POST 等请求时可以直接将参数按照字典结构传入，最终编码到 url 中或者是 body 实体中，同时也支持按照 multipart/form-data 格式，将多种不同的数据合入到 body 中进行发送，而这些就涉及到 AFNetworking 的请求序列化类，也就是 AFURLRequestSerialization。</p>
<p>AFURLRequestSerialization 是一个协议，它定义了一个方法用于序列化参数到 NSURLRequest 中，AFHTTPRequestSerializer 实现了这个协议，并实现了相应的方法。它不仅提供了普通的参数编码方法，也提供了 form-data 格式的 request 构建方法，也就是下面的方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)multipartFormRequestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                              URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                             parameters:(<span class="built_in">NSDictionary</span> *)parameters</span><br><span class="line">                              constructingBodyWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                                  error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br></pre></td></tr></table></figure>

<h2 id="1-form-data"><a href="#1-form-data" class="headerlink" title="1. form-data"></a>1. form-data</h2><p>首先简单介绍一下 form-data，multipart/form-data 主要用于 POST方法中传递多种格式和含义的数据，在 body 中引入 boundary 的概念，用分割线将多部分数据融合到一个 body 中发送给服务端。那么对于一个简单的 form-data，它发送的 body 内容可能如下</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">--<span class="keyword">Boundary+FD2E180F039993ED</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Content-Disposition: </span>form-data<span class="comment">; name="myArray[]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">v1</span></span><br><span class="line"></span><br><span class="line">--<span class="keyword">Boundary+FD2E180F039993ED</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Content-Disposition: </span>form-data<span class="comment">; name="myArray[]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v2</span><br><span class="line"></span><br><span class="line">--<span class="keyword">Boundary+FD2E180F039993ED</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Content-Disposition: </span>form-data<span class="comment">; name="myArray[]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v3</span><br><span class="line"></span><br><span class="line">--<span class="keyword">Boundary+FD2E180F039993ED</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Content-Disposition: </span>form-data<span class="comment">; name="mydic[key1]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">value1</span><br><span class="line"></span><br><span class="line">--<span class="keyword">Boundary+FD2E180F039993ED</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">Content-Disposition: </span>form-data<span class="comment">; name="mydic[key2]"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">value2</span><br><span class="line"></span><br><span class="line">--<span class="keyword">Boundary+FD2E180F039993ED</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">header: </span>headerkey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">BodyData</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">--Boundary+FD2E180F039993ED--</span></span><br></pre></td></tr></table></figure>

<p>它的特点是</p>
<ul>
<li>每一部分都可以包含 header，一般默认必须包含的标识 header 是 Content-Disposition</li>
<li>头部和每一部分需要以 –Boundary+{XXX} 格式分割</li>
<li>末尾以 –Boundary+{XXX}– 结束</li>
<li>请求头中，要设置 Content-Type: multipart/form-data; boundary=Boundary+{XXX}</li>
<li>请求头要设置 Content-Length 为 body 总长度</li>
</ul>
<h2 id="2-一个-form-data-类型的-POST-请求"><a href="#2-一个-form-data-类型的-POST-请求" class="headerlink" title="2. 一个 form-data 类型的 POST 请求"></a>2. 一个 form-data 类型的 POST 请求</h2><p>在 AFNetworking 中，要发送 form-data，可以通过如下方式发送</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">manager.requestSerializer.timeoutInterval = <span class="number">100</span>;</span><br><span class="line">manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">manager.responseSerializer.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"text/plain"</span>, <span class="string">@"text/html"</span>,<span class="string">@"application/json"</span>, <span class="string">@"text/json"</span> ,<span class="string">@"text/javascript"</span>, <span class="literal">nil</span>];;</span><br><span class="line">[manager POST:<span class="string">@"https://www.baidu.com"</span> parameters:@&#123;<span class="string">@"mydic"</span>:@&#123;<span class="string">@"key1"</span>:<span class="string">@"value1"</span>,<span class="string">@"key2"</span>:<span class="string">@"value2"</span>&#125;,</span><br><span class="line">                                                      <span class="string">@"myArray"</span>:@[<span class="string">@"v1"</span>, <span class="string">@"v2"</span>, <span class="string">@"v3"</span>]</span><br><span class="line">                                                      &#125; headers:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class="line">                                                          [formData appendPartWithFileData:[<span class="string">@"Data"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]</span><br><span class="line">                                                                                      name:<span class="string">@"DataName"</span></span><br><span class="line">                                                                                  fileName:<span class="string">@"DataFileName"</span></span><br><span class="line">                                                                                  mimeType:<span class="string">@"data"</span>];</span><br><span class="line">                                                      &#125; progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line"></span><br><span class="line">                                                      &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line"></span><br><span class="line">                                                      &#125;];</span><br></pre></td></tr></table></figure>

<p>主要用到 AFHTTPSessionManager 定义的如下方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                             parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">              constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                               progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgress</span><br><span class="line">                                success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                                failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br></pre></td></tr></table></figure>

<p>它的内部实现，主要做了这几件事</p>
<ul>
<li>通过 requestSerializer 的 multipartFormRequestWithMethod 方法构建 NSMutableURLRequest 对象</li>
<li>设置头部</li>
<li>通过 AFURLSessionManager 创建 NSURLSessionUploadTask 对象</li>
</ul>
<p>从中可以看出，请求序列化主要发生在 multipartFormRequestWithMethod 方法中，而 AFHttpSessionManager 默认的 requestSerializer 是 AFHTTPAFHTTPRequestSerializer。</p>
<h2 id="3-请求序列化"><a href="#3-请求序列化" class="headerlink" title="3. 请求序列化"></a>3. 请求序列化</h2><p>AFHTTPAFHTTPRequestSerializer 对于 form-data 提供了如下方法进行序列化</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)multipartFormRequestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                              URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                             parameters:(<span class="built_in">NSDictionary</span> *)parameters</span><br><span class="line">                              constructingBodyWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                                  error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br></pre></td></tr></table></figure>

<p>在方法实现里主要做了以下事情</p>
<ul>
<li>与普通的 urlencode 请求类似，先设置 request 相关参数，仍然是通过 KVO 记录需要设置的参数，其他都走默认逻辑</li>
<li>构造 AFStreamingMultipartFormData 对象，将传入的参数深度遍历后一一通过 <code>appendPartWithFormData: name:</code> 方法添加到 AFStreamingMultipartFormData 中</li>
<li>提供外部 block，对 AFStreamingMultipartFormData 对象进一步添加数据</li>
<li>通过 AFStreamingMultipartFormData 的  <code>requestByFinalizingMultipartFormData</code> 方法构建 request</li>
</ul>
<p>那么 AFStreamingMultipartFormData 是一个什么类呢。</p>
<h2 id="4-构造-form-data-数据"><a href="#4-构造-form-data-数据" class="headerlink" title="4. 构造 form-data 数据"></a>4. 构造 form-data 数据</h2><p>AFNetworking 定义的 AFStreamingMultipartFormData 类用于表征一个 form-data 格式 body 的数据，它遵循 AFMultipartFormData 协议，能管理 boundary 字符串、用于向 request 传输数据的 NSInputStream 对象。</p>
<p>其中对于 form-data 的每一个 part，AFNetworking 定义了一个 AFHTTPBodyPart 类，其中包含如下信息</p>
<ul>
<li>这个 part 的头部 header</li>
<li>分割字符串 boundary</li>
<li>内容区长度</li>
<li>id 类型的 body</li>
<li>数据流 inputStream</li>
</ul>
<p>AFStreamingMultipartFormData 所包含的 NSInputStream 类，实质上是继承自 NSInputStream 的子类 AFMultipartBodyStream，AFMultipartBodyStream 有一个 HTTPBodyParts 属性，是一个 AFHTTPBodyPart 类型的数组，所有 append 到 AFStreamingMultipartFormData 的 part，最后都转化为一个 AFHTTPBodyPart 对象加入到了 AFMultipartBodyStream 的 HTTPBodyParts 中。</p>
<p>具体来说，AFMultipartFormData 协议（也就是 AFStreamingMultipartFormData 类）定义了如下一些 append 方法</p>
<ul>
<li><code>appendPartWithFileURL: name: error:</code> 添加文件路径内的文件内容到 form-data</li>
<li><code>appendPartWithFileURL: name: fileName: mimeType: error:</code> 添加文件路径内的文件内容到 form-data，指定文件名和 mimeType</li>
<li><code>appendPartWithInputStream: name: fileName: length: mimeType:</code> 添加 inputStream 到 form-data</li>
<li><code>appendPartWithFileData: name: fileName: mimeType:</code> 添加 NSData 到 form-data</li>
<li><code>appendPartWithFormData: name:</code> 添加 NSData 到 form-data</li>
<li><code>appendPartWithHeaders: body:</code> 添加自定义 header 和 body 到 form-data</li>
</ul>
<p>下面以 appendPartWithFormData 为例看下具体实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)appendPartWithFormData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">// 每一块数据，默认带上 Content-Disposition 作为头部</span></span><br><span class="line">    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"form-data; name=\"%@\""</span>, name] forKey:<span class="string">@"Content-Disposition"</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> appendPartWithHeaders:mutableHeaders body:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)appendPartWithHeaders:(<span class="built_in">NSDictionary</span> *)headers</span><br><span class="line">                         body:(<span class="built_in">NSData</span> *)body</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(body);</span><br><span class="line"></span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line">    bodyPart.stringEncoding = <span class="keyword">self</span>.stringEncoding;</span><br><span class="line">    bodyPart.headers = headers;</span><br><span class="line">    <span class="comment">// 复用一个 boundary</span></span><br><span class="line">    bodyPart.boundary = <span class="keyword">self</span>.boundary;</span><br><span class="line">    <span class="comment">// body 长度</span></span><br><span class="line">    bodyPart.bodyContentLength = [body length];</span><br><span class="line">    bodyPart.body = body;</span><br><span class="line">    <span class="comment">// 添加到 stream 中</span></span><br><span class="line">    [<span class="keyword">self</span>.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，就是根据数据构造一个 AFHTTPBodyPart 对象添加到 bodyStream 属性中；至于文件和 inputStream，则是直接将文件 url 和 inputStream 对象赋值给 id 类型的 body。</p>
<p>这样将所有数据都 append 到了 AFStreamingMultipartFormData 中以后，再调用 AFStreamingMultipartFormData 的 requestByFinalizingMultipartFormData 方法就可以构造一个 NSMutableURLRequest 对象了，而在 requestByFinalizingMultipartFormData 方法中，主要做了如下工作</p>
<ul>
<li>将构造出来的 NSMutableURLRequest 的 HTTPBodyStream 属性设置为 AFStreamingMultipartFormData 的 bodyStream 对象，也就是 AFMultipartBodyStream 作为 NSMutableURLRequest 的 body 数据源</li>
<li>设置 Content-Type </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"multipart/form-data; boundary=%@"</span>, <span class="keyword">self</span>.boundary] forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 Content-Length</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%llu"</span>, [<span class="keyword">self</span>.bodyStream contentLength]] forHTTPHeaderField:<span class="string">@"Content-Length"</span>];</span><br></pre></td></tr></table></figure>

<h2 id="5-从-bodyStream-读取数据"><a href="#5-从-bodyStream-读取数据" class="headerlink" title="5. 从 bodyStream 读取数据"></a>5. 从 bodyStream 读取数据</h2><p>AFMultipartBodyStream 直接继承自 NSInputStream，它维护一个 包含全部 AFHTTPBodyPart 的数组，当通过 request 发起一个 NSURLSessionUploadTask 以后，由于设置了 request 的 HTTPBodyStream，则系统会尝试从 AFMultipartBodyStream 读取 body 数据，这里就涉及到了 AFMultipartBodyStream 的 <code>read: maxLength:</code> 方法，它从流中读取数据到 buffer 中，并返回实际读取的数据长度（该长度最大为 len）。而实际上 AFMultipartBodyStream 的 numberOfBytesInPacket 属性就可以限制读取数据的最大长度。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> streamStatus] == <span class="built_in">NSStreamStatusClosed</span>) &#123;</span><br><span class="line">        <span class="comment">// 流已关闭，返回长度 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInteger</span> totalNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 一直从 HTTPBodyParts 读取到字节数达到 length 为止</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead &lt; MIN(length, <span class="keyword">self</span>.numberOfBytesInPacket)) &#123;</span><br><span class="line">        <span class="comment">// 如果还未开始读取，或者当前 part 已经读取结束，则进入下一个</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.currentHTTPBodyPart || ![<span class="keyword">self</span>.currentHTTPBodyPart hasBytesAvailable]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="keyword">self</span>.currentHTTPBodyPart = [<span class="keyword">self</span>.HTTPBodyPartEnumerator nextObject])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> maxLength = MIN(length, <span class="keyword">self</span>.numberOfBytesInPacket) - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead;</span><br><span class="line">            <span class="comment">// 从 part 中读取数据</span></span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesRead = [<span class="keyword">self</span>.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength];</span><br><span class="line">            <span class="keyword">if</span> (numberOfBytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取出错</span></span><br><span class="line">                <span class="keyword">self</span>.streamError = <span class="keyword">self</span>.currentHTTPBodyPart.inputStream.streamError;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 更新总读取字节数</span></span><br><span class="line">                totalNumberOfBytesRead += numberOfBytesRead;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.delay &gt; <span class="number">0.0</span>f) &#123;</span><br><span class="line">                    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="keyword">self</span>.delay];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalNumberOfBytesRead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过一个 currentHTTPBodyPart 对象对 AFMultipartBodyStream 维护的 AFHTTPBodyPart 数组进行遍历，读取其中每一个 AFHTTPBodyPart 对象的数据到 buffer 中。AFHTTPBodyPart 类也实现了同名的 read 方法，在这个方法里，按照如下顺序，读取相应部分的数据</p>
<ul>
<li>AFEncapsulationBoundaryPhase 顶部边界</li>
<li>AFHeaderPhase 头部数据</li>
<li>AFBodyPhase 实体</li>
<li>AFFinalBoundaryPhase 底部边界</li>
</ul>
<p>例如读取顶部边界数据如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *encapsulationBoundaryData = [([<span class="keyword">self</span> hasInitialBoundary] ? AFMultipartFormInitialBoundary(<span class="keyword">self</span>.boundary) : AFMultipartFormEncapsulationBoundary(<span class="keyword">self</span>.boundary)) dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">totalNumberOfBytesRead += [<span class="keyword">self</span> readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br></pre></td></tr></table></figure>

<p>但是当读取到 body 部分时要注意，由于 body 是一个 id 类型，外界主要设置的可能值有 NSData、NSURL、NSInputStream 等，AFNetworking 在这里统一将 body 的读取归一化为 inputStream 流方式读取，按照如下规则构建 inputStream</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInputStream</span> *)inputStream &#123;</span><br><span class="line">    <span class="comment">// inputStream 根据 body 的类别返回不同的数据源</span></span><br><span class="line">    <span class="keyword">if</span> (!_inputStream) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithData:<span class="keyword">self</span>.body];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithURL:<span class="keyword">self</span>.body];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSInputStream</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = <span class="keyword">self</span>.body;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithData:[<span class="built_in">NSData</span> data]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _inputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取到 body 部分时则启动 stream，读取完 body 以后关闭 stream</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是根据当前 phase 切换到下一端 phase 的逻辑</span></span><br><span class="line">        <span class="keyword">case</span> AFHeaderPhase:</span><br><span class="line">            <span class="comment">// header -&gt; body</span></span><br><span class="line">            [<span class="keyword">self</span>.inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">            [<span class="keyword">self</span>.inputStream open];</span><br><span class="line">            _phase = AFBodyPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFBodyPhase:</span><br><span class="line">            <span class="comment">// body -&gt; 底部边界</span></span><br><span class="line">            [<span class="keyword">self</span>.inputStream close];</span><br><span class="line">            _phase = AFFinalBoundaryPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>以上就是 AFNetworking 对于 form-data 请求的完整处理，基于 inputStream，将多种不同类型的 form-data 用统一的代码模型处理，对外暴露的方法简洁一致，因而便于使用和理解。</p>
]]></content>
      <categories>
        <category>AFNetworking源码解析</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title>AFNetworking（一）从一次请求了解AFHTTPSessionManager</title>
    <url>/2019/01/18/AFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/AFNetworking%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8E%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E4%BA%86%E8%A7%A3AFHTTPSessionManager/</url>
    <content><![CDATA[<p>AFNetworking 的核心类是 AFHTTPSessionManager，负责各种 HTTP 请求的发起和处理，它继承自 AFURLSessionManager，是各种请求的直接执行者。</p>
<h2 id="1-AFHTTPSessionManager的初始化"><a href="#1-AFHTTPSessionManager的初始化" class="headerlink" title="1. AFHTTPSessionManager的初始化"></a>1. AFHTTPSessionManager的初始化</h2><p>初始化方法主要接收 baseURL 和 sessionConfiguration 两个参数。</p>
<p>其中对于 baseURL，初始化方法进行了如下判断</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@"/"</span>]) &#123;</span><br><span class="line">    url = [url URLByAppendingPathComponent:<span class="string">@""</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样判断的原因是，对于一个形如 “<a href="https://www.baidu.com/foo&quot;" target="_blank" rel="noopener">https://www.baidu.com/foo&quot;</a> 格式的 baseURL，如果末尾不带正斜杠，则当调用 URLWithString:relativeToURL: 方法，对诸如 “text” 的 path 添加完整路径时，会得到 “”<a href="https://www.baidu.com/text&quot;" target="_blank" rel="noopener">https://www.baidu.com/text&quot;</a> 的结果，所以需要调用 <code>URLByAppendingPathComponent</code>，这个方法的说明讲到了如果原始 url 非空字符串且末尾不带正斜杠，而新的 url 开头也不带正斜杠，则方法会在中间插入正斜杠。</p>
<blockquote>
<p>If the original URL does not end with a forward slash and pathComponent does not begin with a forward slash, a forward slash is inserted between the two parts of the returned URL, unless the original URL is the empty string.</p>
</blockquote>
<p>对于 configuration，AFHTTPSessionManager 交给了父类 AFURLSessionManager 执行，具体操作包含如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化操作队列，并设置为串行队列</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的响应序列化器为 JSON 序列化器</span></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 SSL 所需的 securityPolicy</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// task 的 id 作为 key，代理对象作为 value</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 获取所有的 task，设置一遍 delegate</span></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [strongSelf addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [strongSelf addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [strongSelf addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于序列化器，AFHTTPSessionManager 初始化方法里也指定了默认对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求序列化器用 AFHTTPRequestSerializer，响应序列化器用 AFJSONResponseSerializer</span></span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br></pre></td></tr></table></figure>

<h2 id="2-一次完整的请求与响应过程"><a href="#2-一次完整的请求与响应过程" class="headerlink" title="2 一次完整的请求与响应过程"></a>2 一次完整的请求与响应过程</h2><p>这里以 GET 为例，发起一次 GET 请求的具体过程可以分为发起请求和处理响应两步，下面详细说明。</p>
<h3 id="2-1-发起请求"><a href="#2-1-发起请求" class="headerlink" title="2.1 发起请求"></a>2.1 发起请求</h3><p>AFHTTPSessionManager 支持创建 GET、HEAD、POST、PUT、PATCH、DELETE 等请求，其中 GET 请求支持以下方法发起</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                      success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                      failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                            parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                              progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgress</span><br><span class="line">                               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                            parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                               headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                              progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgress</span><br><span class="line">                               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br></pre></td></tr></table></figure>

<p>最终调用到的方法都是第三个方法，在这个方法里 HTTPSessionManager 创建了一个 HTTP 类型的 dataTask，并发起请求。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                      headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                     progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                          headers:headers</span><br><span class="line">                                                   uploadProgress:<span class="literal">nil</span></span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">    </span><br><span class="line">    [dataTask resume];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 dataTaskWithHTTPMethod 方法里，则做了以下事情</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                         headers:(<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                  uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</span><br><span class="line">                                         failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 1. 设置 request 属性以及参数</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    <span class="comment">// 2. 设置 header</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *headerField <span class="keyword">in</span> headers.keyEnumerator) &#123;</span><br><span class="line">        [request addValue:headers[headerField] forHTTPHeaderField:headerField];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 序列化失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 传给 URLSessionManager 创建 dataTask</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                                   failure(dataTask, error);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                                   success(dataTask, responseObject);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-设置-request-属性以及参数"><a href="#2-1-1-设置-request-属性以及参数" class="headerlink" title="2.1.1 设置 request 属性以及参数"></a>2.1.1 设置 request 属性以及参数</h4><figure class="highlight plain"><figcaption><span>方法主要做了创建和配置 Request 的工作，具体来说包括</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 利用 url 创建 NSMutableURLRequest</span><br><span class="line">* 设置 HTTPMethod</span><br><span class="line">* 设置 request 的 allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies、HTTPShouldUsePipelining、networkServiceType、timeoutInterval等属性</span><br><span class="line">* 对参数编码后加入到 url 或者 body 中</span><br><span class="line"></span><br><span class="line">其中能设置的 request 具体作用如下</span><br><span class="line"></span><br><span class="line">* allowsCellularAccess 是否允许使用服务商蜂窝网络</span><br><span class="line">* cachePolicy 缓存策略枚举</span><br><span class="line">  * NSURLRequestUseProtocolCachePolicy &#x3D; 0 默认的缓存策略， 如果缓存不存在，直接从服务端获取。如果缓存存在，会根据 response 中的 Cache-Control 字段判断下一步操作，如: Cache-Control 字段为 must-revalidata, 则询问服务端该数据是否有更新，无更新的话直接返回给用户缓存数据，若已更新，则请求服务端</span><br><span class="line">  * NSURLRequestReloadIgnoringLocalCacheData &#x3D; 1 忽略本地缓存数据，直接请求服务端</span><br><span class="line">  * NSURLRequestReloadIgnoringLocalAndRemoteCacheData &#x3D; 4 __未实现__，忽略本地缓存，代理服务器以及其他中介，直接请求源服务端</span><br><span class="line">  * NSURLRequestReloadIgnoringCacheData &#x3D; NSURLRequestReloadIgnoringLocalCacheData 忽略本地缓存数据，直接请求服务端</span><br><span class="line">  * NSURLRequestReturnCacheDataElseLoad &#x3D; 2 有缓存就使用，不管其有效性(即忽略 Cache-Control 字段), 无则请求服务端</span><br><span class="line">  * NSURLRequestReturnCacheDataDontLoad &#x3D; 3 只加载本地缓存. 没有就失败(确定当前无网络时使用)</span><br><span class="line">  * NSURLRequestReloadRevalidatingCacheData &#x3D; 5 __未实现__，缓存数据必须得得到服务端确认有效才使用</span><br><span class="line">* HTTPShouldHandleCookies 设置发送请求时是否发送cookie数据</span><br><span class="line">* HTTPShouldUsePipelining 设置请求时是否按顺序收发 默认禁用 在某些服务器中设为YES可以提高网络性能 </span><br><span class="line">* networkServiceType 网络请求的服务类型</span><br><span class="line">  * NSURLNetworkServiceTypeDefault &#x3D; 0 普通网络传输，默认使用这个</span><br><span class="line">  * NSURLNetworkServiceTypeVoIP &#x3D; 1 网络语音通信传输，只能在VoIP使用</span><br><span class="line">  * NSURLNetworkServiceTypeVideo &#x3D; 2 影像传输</span><br><span class="line">  * NSURLNetworkServiceTypeBackground &#x3D; 3 网络后台传输，优先级不高时可使用。对用户不需要的网络操作可使用</span><br><span class="line">  * NSURLNetworkServiceTypeVoice &#x3D; 4 语音传输</span><br><span class="line">* timeoutInterval 请求超时时间</span><br><span class="line"></span><br><span class="line">具体到 AFNetworking 中，是利用了 KVO 特性，将一系列 set 方法手动触发 KVO，然后对于触发过设置方法的属性，均加入到了mutableObservedChangedKeyPaths 集合中，创建 request 时会针对设置过的属性，设置相对应的属性</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;objectivec</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 只有设置过此属性，才会触发 KVO，mutableObservedChangedKeyPaths 这个 set 里才有此属性</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-对参数编码"><a href="#2-1-2-对参数编码" class="headerlink" title="2.1.2 对参数编码"></a>2.1.2 对参数编码</h4><p>编码参数用到了 AFURLRequestSerialization 协议类的 <code>requestBySerializingRequest:withParameters:error:</code> 方法，而 HTTPSessionManager 用到的 AFHTTPRequestSerializer 则实现了此方法，主要做了几件事</p>
<ul>
<li>没有设置过相关必要的 header 字段，则设置成默认值</li>
<li>编码 query 参数</li>
<li>针对 HTTPMethod，将参数放入到 url 或 body 里</li>
</ul>
<p>首先是设置一些默认 header，目前包含以下两个键值对</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"Accept-Language"</span> = <span class="string">"en;q=1"</span>;</span><br><span class="line">    <span class="string">"User-Agent"</span> = <span class="string">"iOS Example/1.0 (iPhone; iOS 11.3; Scale/3.00)"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是编码 query，AFNetworking 接受的字典类型的参数作为编码 query 的数据，编码过程如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    <span class="comment">// 序列化 query 参数</span></span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里提供了一个 block 参数 queryStringSerialization，它可以支持外部设置，从而将编码序列化工作交给外部处理。AFNetworking 内部则使用了 AFQueryStringFromParameters 方法来编码参数，下面是它的实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        <span class="comment">// 将字典参数打平成一层AFQueryStringPair，进行url编码后，放入数组</span></span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">    <span class="keyword">return</span> AFQueryStringPairsFromKeyAndValue(<span class="literal">nil</span>, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 description 正序排序</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"description"</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = value;</span><br><span class="line">        <span class="comment">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedKey <span class="keyword">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="keyword">id</span> nestedValue = dictionary[nestedKey];</span><br><span class="line">            <span class="keyword">if</span> (nestedValue) &#123;</span><br><span class="line">                <span class="comment">// 字典类型的参数，需要转为 dicName[key] = value 形式</span></span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@[%@]"</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedValue <span class="keyword">in</span> array) &#123;</span><br><span class="line">            <span class="comment">// 数组类型的参数，需要转为 arrayName[] = value 形式</span></span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@[]"</span>, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSSet</span> *set = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="comment">// 集合类型的参数，直接取出元素添加到 query</span></span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最终遍历到字符串类型参数截止</span></span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过深度优先遍历，将字典内所有元素均转化为 AFQueryStringPair 对象后，每个对象调用自身的 URLEncodedStringValue 方法，实现编码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.value || [<span class="keyword">self</span>.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@=%@"</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]), AFPercentEscapedStringFromString([<span class="keyword">self</span>.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里具体编码工作是由 AFPercentEscapedStringFromString 方法完成，在这个方法里，AFNetworking 首先将系统提供的 URLQueryAllowedCharacterSet 集合中的 #[] 三个字符去除了，意味着这三个字符也需要参与编码。然后以每 50 个字符为一个单元，调用 stringByAddingPercentEncodingWithAllowedCharacters 方法进行编码处理。</p>
<p>为了避免对完整的 emoji 进行错误的截断，这里还用到了 rangeOfComposedCharacterSequencesForRange 方法获取完整的子字符串，而不是 substringToIndex 方法获取字符串。</p>
<p>编码后的字符，通过 &amp; 字符连接起来后，就将被加入到 request 中，其中对于 GET、HEAD、DELETE 方法，也就是 HTTPMethodsEncodingParametersInURI 属性包含的方法，需要将参数补到 url 末尾，而对于其他方法，则直接加入到 body 中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// url 有 query 和无 query 时需要区别处理</span></span><br><span class="line">        mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">    <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">        query = <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// request 没设置 Content-Type 时，设置为默认的 application/x-www-form-urlencoded</span></span><br><span class="line">    <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</span><br><span class="line">        [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-设置-header"><a href="#2-1-3-设置-header" class="headerlink" title="2.1.3 设置 header"></a>2.1.3 设置 header</h4><p>设置 header 就是遍历传入的 headers 字典，加入到 request 的 headerField 中即可。</p>
<h4 id="2-1-4-序列化失败回调"><a href="#2-1-4-序列化失败回调" class="headerlink" title="2.1.4 序列化失败回调"></a>2.1.4 序列化失败回调</h4><p>对于序列化过程中出现的错误，实际上就是 queryStringSerialization 外部编码出现的错误可以走 failure 回调，结束此次请求。</p>
<h4 id="2-1-5-传给-URLSessionManager-创建-dataTask"><a href="#2-1-5-传给-URLSessionManager-创建-dataTask" class="headerlink" title="2.1.5 传给 URLSessionManager 创建 dataTask"></a>2.1.5 传给 URLSessionManager 创建 dataTask</h4><p>URLSessionManager 持有了创建 dataTask 所需的 NSURLSession 对象，因此需要最后由 URLSessionManager 创建对应的 task，它所做的工作如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">url_session_manager_create_task_safely(^&#123;</span><br><span class="line">    <span class="comment">// 利用 request 创建一个 dataTask</span></span><br><span class="line">    dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dataTask;</span><br></pre></td></tr></table></figure>

<p>除了创建 task 以外，URLSessionManager 需要对每一个 task 设置它的代理对象，具体在 addDelegateForDataTask 方法里，这个方法的实现如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line">AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">delegate.manager = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 传入回调</span></span><br><span class="line">delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"><span class="comment">// 将 task 与其代理对象的键值对加入到 mutableTaskDelegatesKeyedByTaskIdentifier</span></span><br><span class="line"><span class="comment">// 并监听 task 启动和挂起通知</span></span><br><span class="line">[<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进度回调</span></span><br><span class="line">delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">delegate.downloadProgressBlock = downloadProgressBlock;</span><br></pre></td></tr></table></figure>

<p>可以看到 URLSessionManager 对象其实并未细致到每一个 task 进行控制和处理，更多是对 task 的汇聚和管理，具体的回调、更新、异常处理都在每一个 task 对应的代理对象中实现。</p>
<h3 id="2-2-处理响应"><a href="#2-2-处理响应" class="headerlink" title="2.2 处理响应"></a>2.2 处理响应</h3><p>AFNetworking 3.0 内部使用的网络 API 是 URLSession，它有一系列的回调方法，涵盖 SSL 建立、发送数据、收到响应行、收到响应实体、异常处理和结束请求等关键过程，具体又分为以下几个协议类</p>
<ul>
<li>NSURLSessionDelegate : session-level 的代理方法</li>
<li>NSURLSessionTaskDelegate : task-level 面向 all 的代理方法</li>
<li>NSURLSessionDataDelegate : task-level 面向 data 和 upload 的代理方法</li>
<li>NSURLSessionDownloadDelegate : task-level 面向 download 的代理方法</li>
<li>NSURLSessionStreamDelegate : task-level 面向 stream 的代理方法</li>
</ul>
<h4 id="2-2-1-接收数据"><a href="#2-2-1-接收数据" class="headerlink" title="2.2.1 接收数据"></a>2.2.1 接收数据</h4><p>GET 请求主要关注 NSURLSessionDataDelegate 方法，当收到数据时，系统会回调 URLSessionManager 的 <code>URLSession:dataTask:didReceiveData:</code> 方法，原因是初始化 URLSessionManager 时，session 的代理对象设置的就是 URLSessionManager。</p>
<p>这个方法的实现很简单，主要做了以下工作</p>
<ul>
<li>回调此事件给 task 的代理对象</li>
<li>回调 dataTaskDidReceiveData block</li>
</ul>
<p>具体如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 查找 task 对应的 delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    <span class="comment">// 回调给代理对象同名方法</span></span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// manager 类统一回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于每一个 task 的代理对象 AFURLSessionManagerTaskDelegate 类，也要实现一个同名方法，这个方法具体做的事情是将收到的数据汇聚到一个 NSData 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    self.downloadProgress.totalUnitCount &#x3D; dataTask.countOfBytesExpectedToReceive;</span><br><span class="line">    self.downloadProgress.completedUnitCount &#x3D; dataTask.countOfBytesReceived;</span><br><span class="line"></span><br><span class="line">    [self.mutableData appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-完成响应"><a href="#2-2-2-完成响应" class="headerlink" title="2.2.2 完成响应"></a>2.2.2 完成响应</h4><p>这里就有两个问题了，其一是每一个 task 总会结束，结束后它的代理对象也就没有意义需要销毁，其二是，数据何时才能结束添加并最终回调给调用者。其实这些都在 NSURLSessionTaskDelegate 协议的 <code>URLSession:task:didCompleteWithError:</code> 中，仍然像上面一样，首先系统会回调到 URLSessionManager 中，在这里 Manager 找到 task 的代理对象，调用它的同名方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取代理对象</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        <span class="comment">// 回调同名方法</span></span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 mutableTaskDelegatesKeyedByTaskIdentifier 移除task的代理对象，同时销毁对 task 的监听</span></span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 AFURLSessionManagerTaskDelegate 的同名方法里则完成了数据的解析、序列化和回调，主要来说有以下工作</p>
<ul>
<li>对系统回调返回的 error 走异常处理，此时 responseObject 为 nil</li>
<li>对响应中的二进制数据进行序列化操作，默认通过 AFJSONResponseSerializer 进行序列化</li>
<li>回调到网络请求方</li>
</ul>
<h4 id="2-2-3-序列化操作"><a href="#2-2-3-序列化操作" class="headerlink" title="2.2.3 序列化操作"></a>2.2.3 序列化操作</h4><p>这里主要看一下序列化 response 的操作，AFHTTPSessionManager 默认使用的序列化类是 AFJSONResponseSerializer，除此之外还有 AFHTTPResponseSerializer、AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer、AFImageResponseSerializer 等序列化器。</p>
<p>下面分析几个主要的序列化器的内部逻辑。</p>
<h5 id="2-2-3-1-AFJSONResponseSerializer"><a href="#2-2-3-1-AFJSONResponseSerializer" class="headerlink" title="2.2.3.1 AFJSONResponseSerializer"></a>2.2.3.1 AFJSONResponseSerializer</h5><p>序列化的核心方法是 <code>responseObjectForResponse:data:error:</code> ，这个方法由 AFURLResponseSerialization 协议类定义，AFJSONResponseSerializer 的实现做了如下工作</p>
<ul>
<li>验证合法性</li>
<li>调用 NSJSONSerialization 转化为 JSON 对象</li>
<li>去除值为 NSNULL 的情况（可选）</li>
</ul>
<p>验证合法性这一步，AFJSONResponseSerializer 用到了它的父类 AFHTTPResponseSerializer 定义的 <code>validateResponse:data:error:</code> 方法，这个方法主要检查</p>
<ul>
<li>MIMEType 是否在 AFHTTPResponseSerializer 定义的 acceptableContentTypes 中，不同的序列化器包含了不同的 MTMEType，对于 AFJSONResponseSerializer，包含以下类型application/json、text/json、text/javascript</li>
<li>状态码在 acceptableStatusCodes 中，即 200-299</li>
</ul>
<p>验证合法性结束后就调用 NSJSONSerialization 的 <code>+ (nullable id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error;</code> 方法，将数据转为 JSON 对象，可能是字典或者数组。如果外部设置了 removesKeysWithNullValues，即代表需要将 value 为 NSNULL 的键值对去除，这一步操作在 AFJSONObjectByRemovingKeysWithNullValues 方法中实现。</p>
<h5 id="2-2-3-2-AFHTTPResponseSerializer"><a href="#2-2-3-2-AFHTTPResponseSerializer" class="headerlink" title="2.2.3.2 AFHTTPResponseSerializer"></a>2.2.3.2 AFHTTPResponseSerializer</h5><p>作为父类，AFHTTPResponseSerializer 的序列化操作仅仅检查了合法性就直接返回数据了</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，它的 acceptableContentTypes 为 nil。</p>
<h5 id="2-2-3-3-AFXMLParserResponseSerializer"><a href="#2-2-3-3-AFXMLParserResponseSerializer" class="headerlink" title="2.2.3.3 AFXMLParserResponseSerializer"></a>2.2.3.3 AFXMLParserResponseSerializer</h5><p>AFXMLParserResponseSerializer 接受 “application/xml” 及 “text/xml” 类型的 MIMEType，它的序列化过程主要调用如下方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-4-AFXMLDocumentResponseSerializer"><a href="#2-2-3-4-AFXMLDocumentResponseSerializer" class="headerlink" title="2.2.3.4 AFXMLDocumentResponseSerializer"></a>2.2.3.4 AFXMLDocumentResponseSerializer</h5><p>AFXMLDocumentResponseSerializer 接受 “application/xml” 及 “text/xml” 类型的 MIMEType，它的序列化过程主要调用如下方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSXMLDocument</span> *document = [[<span class="built_in">NSXMLDocument</span> alloc] initWithData:data options:<span class="keyword">self</span>.options error:&amp;serializationError];</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-5-AFPropertyListResponseSerializer"><a href="#2-2-3-5-AFPropertyListResponseSerializer" class="headerlink" title="2.2.3.5 AFPropertyListResponseSerializer"></a>2.2.3.5 AFPropertyListResponseSerializer</h5><p>AFPropertyListResponseSerializer 接受 “application/x-plist” 类型的 MIMEType，它的序列化过程主要调用如下方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> responseObject = [<span class="built_in">NSPropertyListSerialization</span> propertyListWithData:data options:<span class="keyword">self</span>.readOptions format:<span class="literal">NULL</span> error:&amp;serializationError];</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-6-AFImageResponseSerializer"><a href="#2-2-3-6-AFImageResponseSerializer" class="headerlink" title="2.2.3.6 AFImageResponseSerializer"></a>2.2.3.6 AFImageResponseSerializer</h5><p>AFImageResponseSerializer 定义了许多与图片相关 MIMEType，包括 “image/tiff”, “image/jpeg”, “image/gif”, “image/png”, “image/ico”, “image/x-icon”, “image/bmp”, “image/x-bmp”, “image/x-xbitmap”, “image/x-win-bitmap” 等等。</p>
<p>图片序列化的过程如果细分会很复杂，这里简单概括一下如下</p>
<ul>
<li>验证合法性</li>
<li>是否自动解码，需要自动解码则通过 CGContextDrawImage 解码图片</li>
<li>返回图片</li>
</ul>
<h5 id="2-2-3-7-AFCompoundResponseSerializer"><a href="#2-2-3-7-AFCompoundResponseSerializer" class="headerlink" title="2.2.3.7 AFCompoundResponseSerializer"></a>2.2.3.7 AFCompoundResponseSerializer</h5><p>AFCompoundResponseSerializer 是一个混合序列化器，它接受一系列的序列化器，当收到 response 时，一个一个去尝试能否解析出最终结果，如果都无法解析，则会调用到 AFHTTPResponseSerializer 的默认实现。</p>
]]></content>
      <categories>
        <category>AFNetworking源码解析</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中的Base64编码</title>
    <url>/2019/01/02/iOS%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E7%9A%84Base64%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>Base64 是一种基于 64 个可打印字符来表示二进制数据编码方式，广泛运用在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</p>
<p>通过 Base64 编码后的数据比原始数据略长，为原来的 4/3，原因是 Base64 是将三个字节拆分成 4 个 6bit 段进行编码。</p>
<p>Base64 编码的具体步骤如下</p>
<ul>
<li>对于原始数据，以每 3 个 8bit 为一组，获得 24bit</li>
<li>将 24bit 划分为 4 组，每组 6bit</li>
<li>将每组 bit 的高位补充 2 个 0，获得 4 个 8bit</li>
<li>将 4 个 8bit 转换为 10 进制，对照 Base64 参照表进行编码替换</li>
</ul>
<p><img src="/images/1796842-9199cc037816d81c.png" alt=""></p>
<p>这里需要注意的点</p>
<ul>
<li>对于 URL 而言，Base64 参照表的 “+” 和 “/“ 是保留字，不会进行 URL 编码，这样会对解析 URL 产生错误，因此需要先将它们替换成诸如 “-_” 等字符，然后参与 URL 编码</li>
<li>由于编码的是 8bit 字符，因此对于超过 8bit 的字符，如中文字符等，需要进行 UTF8 编码后再进行 Base64 编码</li>
<li>字符串末尾有时不足 3 个字符，需要补充 “=” 进行占位，具体来说<ul>
<li>对于末尾只有 1 个字符的情况，转换为 8bit 二进制数据后，末尾补 0，填充至 12bit，转换为 2 个 Base64 编码字符，然后再补充 2 个 “=” 作为结束符</li>
<li>对于末尾只有 2 个字符的情况，转换为 8bit 二进制数据后，末尾补 0，填充至 18bit，转换为 3 个 Base64 编码字符，然后再补充 1 个 “=” 作为结束符</li>
</ul>
</li>
</ul>
<p><img src="/images/1000992-786171faf2a04e09.png" alt=""></p>
<p>iOS 中的 Base64 编码与解码如下所示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *target = <span class="string">@"TEST"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *data = [target dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSString</span> *base64Str = [data base64EncodedStringWithOptions:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSString</span> *base64DecodeStr = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title>iOS中错误处理CYMK颜色空间的问题</title>
    <url>/2018/10/23/iOS%E5%BC%80%E5%8F%91/iOS%E4%B8%AD%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86CYMK%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>今天在处理一张图片时图片处理后变成了纯黑色图片，其中定位到处理图片时进行了 CGContext 绘制操作，初始化 context 的代码如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, <span class="built_in">CGImageGetColorSpace</span>(image.CGImage), kCGImageAlphaNoneSkipLast|kCGBitmapByteOrderDefault);</span><br></pre></td></tr></table></figure>

<p>报错信息如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[Unknown process name] CGBitmapContextCreate: unsupported parameter combination: <span class="keyword">set</span> CGBITMAP_CONTEXT_LOG_ERRORS environmental <span class="keyword">variable</span> <span class="keyword">to</span> see the details</span><br><span class="line">[<span class="literal">Unknown</span> process <span class="keyword">name</span>] CGContextDrawImage: invalid <span class="keyword">context</span> <span class="number">0x0</span>. <span class="keyword">If</span> you want <span class="keyword">to</span> see the backtrace, please <span class="keyword">set</span> CG_CONTEXT_SHOW_BACKTRACE environmental variable.</span><br><span class="line">[<span class="literal">Unknown</span> process <span class="keyword">name</span>] CGBitmapContextCreateImage: invalid <span class="keyword">context</span> <span class="number">0x0</span>. <span class="keyword">If</span> you want <span class="keyword">to</span> see the backtrace, please <span class="keyword">set</span> CG_CONTEXT_SHOW_BACKTRACE environmental variable.</span><br></pre></td></tr></table></figure>

<p>最终发现图片的颜色空间是 CYMK 格式的</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">po CGImageGetColorSpace(<span class="name">image</span>.CGImage)</span><br><span class="line">&lt;CGColorSpace <span class="number">0</span>x282631ce0&gt; (<span class="name">kCGColorSpaceICCBased</span><span class="comment">; kCGColorSpaceModelCMYK; Japan Color 2001 Coated)</span></span><br></pre></td></tr></table></figure>

<p>按照 Quartz 2D Programming Guide 的 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-TPXREF101" target="_blank" rel="noopener">Graphics Contexts</a> 中介绍的有关位图上下文支持的像素格式，iOS 设备仅支持 RGB 和 GRAY，不支持 CYMK 格式，所以导致无法创建位图上下文，从而不能进行画布绘制等操作。</p>
<p>CS|Pixel format and bitmap information constant|Availability|<br>—|—|—|—|<br>Null|8 bpp, 8 bpc, kCGImageAlphaOnly|Mac OS X, iOS|<br>Gray|8 bpp, 8 bpc,kCGImageAlphaNone|Mac OS X, iOS|<br>Gray|8 bpp, 8 bpc,kCGImageAlphaOnly|Mac OS X, iOS|<br>Gray|16 bpp, 16 bpc, kCGImageAlphaNone|Mac OS X|<br>Gray|32 bpp, 32 bpc, kCGImageAlphaNone|kCGBitmapFloatComponents|Mac OS X|<br>RGB|16 bpp, 5 bpc, kCGImageAlphaNoneSkipFirst|Mac OS X, iOS|<br>RGB|32 bpp, 8 bpc, kCGImageAlphaNoneSkipFirst|Mac OS X, iOS|<br>RGB|32 bpp, 8 bpc, kCGImageAlphaNoneSkipLast|Mac OS X, iOS|<br>RGB|32 bpp, 8 bpc, kCGImageAlphaPremultipliedFirst|Mac OS X, iOS|<br>RGB|32 bpp, 8 bpc, kCGImageAlphaPremultipliedLast|Mac OS X, iOS|<br>RGB|64 bpp, 16 bpc, kCGImageAlphaPremultipliedLast|Mac OS X|<br>RGB|64 bpp, 16 bpc, kCGImageAlphaNoneSkipLast|Mac OS X|<br>RGB|128 bpp, 32 bpc, kCGImageAlphaNoneSkipLast、kCGBitmapFloatComponents|Mac OS X|<br>RGB|128 bpp, 32 bpc, kCGImageAlphaPremultipliedLast、kCGBitmapFloatComponents|Mac OS X|<br>CMYK|32 bpp, 8 bpc, kCGImageAlphaNone|Mac OS X|<br>CMYK|64 bpp, 16 bpc, kCGImageAlphaNone|Mac OS X|<br>CMYK|128 bpp, 32 bpc, kCGImageAlphaNone、kCGBitmapFloatComponents|Mac OS X|</p>
<p>更深入的说，Quartz 2D 支持颜色管理系统使用的标准颜色空间，也支持通用的颜色空间、索引颜色空间和模式(pattern)颜色空间，但 iOS 仅支持使用设备颜色空间，设备颜色空间创建方式如下</p>
<ul>
<li>CGColorSpaceCreateDeviceGray：创建设备依赖灰度颜色空间</li>
<li>CGColorSpaceCreateDeviceRGB：创建设备依赖RGB颜色空间</li>
<li>CGColorSpaceCreateDeviceCMYK：创建设备依赖CMYK颜色空间</li>
</ul>
<p>而 CoreGraphic 支持两种图形上下文，bitmapContext 和 PDFContext，通常使用的 bitmapContext 仅支持 RGB 和 Gray。</p>
<p>因此当创建 bitmap 时，不应当调用 <code>CGImageGetColorSpace</code> 从图片获取 colorSpace 来设置上下文。</p>
<p>此外，如果是通过 PhotoFramework 从相册直接获取到 UIImage 对象则 PhotoFramework 会帮你将其 colorSpace 转换为 RGB，但是获取 NSData 到内存中自己通过 imageWithData 方法转换则会保留它的 colorSpace 信息。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS实现键盘弹起时tableview第一响应者cell不被遮挡的效果</title>
    <url>/2018/10/12/iOS%E5%BC%80%E5%8F%91/iOS%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%E6%97%B6tableview%E7%AC%AC%E4%B8%80%E5%93%8D%E5%BA%94%E8%80%85cell%E4%B8%8D%E8%A2%AB%E9%81%AE%E6%8C%A1%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>近期在调研 XLForm 框架，一个集成多种表单常见功能的框架，其中对于 UITableView 中的输入框与键盘弹出隐藏逻辑进行了相关处理以避免输入区域被遮挡。</p>
<p>下面是我的实现</p>
<p>首先实现一个 cell，其中包含一个 UITextField，用于获取第一响应者，弹出键盘</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)&#123;</span><br><span class="line">        [<span class="keyword">self</span> addViews];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addViews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.textInput];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITextField</span> *)textInput</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_textInput) &#123;</span><br><span class="line">        _textInput = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">44</span>, <span class="number">100</span>, <span class="number">44</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _textInput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次对键盘事件进行监听，包括 UIKeyboardWillShowNotification 和 UIKeyboardWillHideNotification</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加键盘弹出事件监听</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(keyboardWillShow:)</span><br><span class="line">                                             name:<span class="built_in">UIKeyboardWillShowNotification</span></span><br><span class="line">                                           object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键盘隐藏事件监听</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(keyboardWillHide:)</span><br><span class="line">                                             name:<span class="built_in">UIKeyboardWillHideNotification</span></span><br><span class="line">                                           object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>这里主要关注了键盘弹出事件，实现原理是通过弹出事件获取到键盘高度以及动画时间等信息，然后对 tableview 也做一个动画，将它的 contentInset 的 bottom 值设置为键盘区域顶部，这样做的目的是改变 tableView 的可滑动区域，再结合 scrollToRowAtIndexPath 方法，保证 UITextField 所在的 cell 完全展示不被遮挡。这里存在一些问题，稍后解释。</p>
<p>下面是具体的代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)keyboardWillShow:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出当前第一响应者</span></span><br><span class="line">    <span class="built_in">UIView</span> *firstResponderView = [<span class="keyword">self</span>.inputTableView findFirstResponder];</span><br><span class="line">    <span class="comment">// 取出第一响应者所在的 cell</span></span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [firstResponderView findAttachedCell];</span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出 userInfo，其中包含一些与键盘相关的信息，如</span></span><br><span class="line">    <span class="comment">// UIKeyboardFrameEndUserInfoKey 键盘在屏幕坐标系中最终展示的矩形 frame 尺寸</span></span><br><span class="line">    <span class="comment">// UIKeyboardAnimationDurationUserInfoKey 键盘弹出动画时长</span></span><br><span class="line">    <span class="comment">// UIKeyboardAnimationCurveUserInfoKey 键盘弹出动画曲线</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *keyboardInfo = [notification userInfo];</span><br><span class="line">    <span class="comment">// 将键盘 frame 转换到 tableView 上</span></span><br><span class="line">    <span class="built_in">CGRect</span> keyboardFrame = [<span class="keyword">self</span>.inputTableView.window convertRect:[keyboardInfo[<span class="built_in">UIKeyboardFrameEndUserInfoKey</span>] <span class="built_in">CGRectValue</span>] toView:<span class="keyword">self</span>.inputTableView.superview];</span><br><span class="line">    <span class="comment">// 计算出 tableview 底部被键盘遮挡的区域</span></span><br><span class="line">    <span class="built_in">CGFloat</span> newBottomInset = <span class="keyword">self</span>.inputTableView.frame.origin.y + <span class="keyword">self</span>.inputTableView.frame.size.height - keyboardFrame.origin.y;</span><br><span class="line">    <span class="built_in">UIEdgeInsets</span> tableContentInset = <span class="keyword">self</span>.inputTableView.contentInset;</span><br><span class="line">    <span class="built_in">NSNumber</span> *currentBottomTableContentInset = @(tableContentInset.bottom);</span><br><span class="line">    <span class="keyword">if</span> (newBottomInset &gt; [currentBottomTableContentInset floatValue]) &#123; <span class="comment">// 的确遮挡了 tableview</span></span><br><span class="line">        tableContentInset.bottom = newBottomInset;</span><br><span class="line">        <span class="comment">// 启动动画</span></span><br><span class="line">        [<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="built_in">UIView</span> setAnimationDuration:[keyboardInfo[<span class="built_in">UIKeyboardAnimationDurationUserInfoKey</span>] doubleValue]];</span><br><span class="line">        [<span class="built_in">UIView</span> setAnimationCurve:[keyboardInfo[<span class="built_in">UIKeyboardAnimationCurveUserInfoKey</span>] intValue]];</span><br><span class="line">        <span class="comment">// 改变 tableView 的 contentInset</span></span><br><span class="line">        <span class="keyword">self</span>.inputTableView.contentInset = tableContentInset;</span><br><span class="line">        <span class="comment">// 滚动到第一响应者所在的 cell，UITableViewScrollPositionNone 保证以最小的滚动完全展示 cell</span></span><br><span class="line">        <span class="built_in">NSIndexPath</span> *selectedRow = [<span class="keyword">self</span>.inputTableView indexPathForCell:cell];</span><br><span class="line">        [<span class="keyword">self</span>.inputTableView scrollToRowAtIndexPath:selectedRow atScrollPosition:<span class="built_in">UITableViewScrollPositionNone</span> animated:<span class="literal">NO</span>];</span><br><span class="line">        [<span class="built_in">UIView</span> commitAnimations];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释基本解释清楚了整个过程，但仍然存在一个问题，即为什么必须要修改 contentInset。</p>
<p>实际上大概是 iOS4 版本以后（“大概是”表示消息来源不可靠），UITextField 就有一个特性，如果在 UITableView 中展示的 UITextField 被遮挡了，即使仅遮挡一部分，UITextField 也会滚动整个 tableview，以确保自身被完全展示出来。</p>
<p>单纯考虑这一条，我尝试去除了所有代码，不设置 contentInset，也不滚动到 cell，结果发现键盘弹出时并不会将 UITextField 展示出来，其判断是否自身被“遮挡”，即“不可见”并不是依赖于键盘遮挡这种情况，甚至就算放一个 view 到 tableview 上挡住这个 UITextField，也不会被 UITextField 认为是遮挡。UITextField 是按照自己是否在 UItableView 的“可视区域”来判断是否遮挡，而可视区域是根据 UITableView 的 frame，去除 contentInset 以后得到的区域来确定的。</p>
<p>所以这里如果不设置 contentInset，即使调用了 scrollToRowAtIndexPath 也没有用，UITableViewScrollPositionNone 仍然是按照“可视区域”来决定是否 cell 已经完全展示的。</p>
<blockquote>
<p>UITableViewScrollPositionNone</p>
<p>The table view scrolls the row of interest to be fully visible with a minimum of movement. If the row is already fully visible, no scrolling occurs. For example, if the row is above the visible area, the behavior is identical to that specified by UITableViewScrollPositionTop. This is the default.</p>
</blockquote>
<p>所以当设置了 contentInset 的 bottom 间距刚好为键盘高度时，就可以实现获取第一响应者的 UITextField 自动滑动到屏幕可视范围了，scrollToRowAtIndexPath 也能正常滚动了。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 利用 Metal 实现 LUT 滤镜</title>
    <url>/2018/09/26/iOS%E5%BC%80%E5%8F%91/iOS%20%E5%88%A9%E7%94%A8%20Metal%20%E5%AE%9E%E7%8E%B0%20LUT%20%E6%BB%A4%E9%95%9C/</url>
    <content><![CDATA[<p>之前探究过 iOS 上通过 CoreImage、OpenGLES 等技术实现 LUT 滤镜的对比 – <a href="https://www.jianshu.com/p/f054464e1b40" target="_blank" rel="noopener">iOS 针对 LUT 滤镜的实现对比</a>，但是其实在图形处理这块，Apple 更推崇自家公司的 Metal，这是一个和 OpenGLES 类似的面向底层的图形编程接口，最早在 2014 年的 WWDC 的时候发布，可用于从 CPU 发送指令到 GPU 驱动 GPU 进行大量并行矩阵运算。</p>
<p>Metal 提供以下特性：</p>
<ul>
<li>低开销接口。Metal 被设计用于消灭像状态检查一类的隐性性能瓶颈，你可以控制 GPU 的异步行为，以实现用于并行创建和提交命令缓冲区的高效多线程操作</li>
<li>内存和资源管理。Metal 框架提供了表示 GPU 内存分配的缓冲区和纹理对象，纹理对象具有确切的像素格式，能被用于纹理图像或附件</li>
<li>集成对图形和计算操作的支持。Metal 对图形操作和计算操作使用了相同的数据结构和资源（如 buffer、texture、command queue），Metal 的着色器语言同时支持图形函数和计算函数，Metal 框架支持在运行时接口（CPU）、图形着色器和计算方法间共享资源</li>
<li>预编译着色器。Metal 的着色器函数能与代码一同在编译器编译，并在运行时加载，这样的流程能提供更方便的着色器调试功能。</li>
</ul>
<p>Metal 的对象关系如图所示</p>
<img src="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Art/Cmd-Model-1_2x.png">

<p>其中连接 CPU 和 GPU 的就是命令队列 Command Queue，其上装载多个命令缓冲 Command Buffer，Command Buffer 里能承载 Metal 定义的多种图形、计算命令编码器，在编码器中就是开发者创建的实际的命令和资源，它们最终被传送到 GPU 中进行计算和渲染。</p>
<p>接下来就用 Metal 实现一个图片 LUT 滤镜。</p>
<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><p>Metal 初始化工作主要将一些初始化开销大、能够复用的对象进行预先生成和持有.</p>
<p>首先初始化 GPU 接口，可以理解为持有 GPU，在 Metal 中它被定义为 MTLDevice 类型的对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.mtlDevice = <span class="built_in">MTLCreateSystemDefaultDevice</span>(); <span class="comment">// 获取 GPU 接口</span></span><br></pre></td></tr></table></figure>

<p>其次初始化一个 MTKView，它相当于画布，用于 GPU 渲染内容到屏幕上</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.mtlView];</span><br><span class="line">[<span class="keyword">self</span>.mtlView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.left.top.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">    make.width.height.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>Metal 的渲染流程与 OpenGLES 很类似，大致如下图所示</p>
<p><img src="/images/1000992-8b96799868a5e202" alt=""></p>
<p>因此同样的，需要传入顶点数据、顶点着色器和片段着色器</p>
<p>顶点数据定义如下，每一行的前四个分量为顶点坐标，后两个分量为纹理坐标（归一化）。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> vertexArrayData[] = &#123;</span><br><span class="line">    <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后加载到顶点 buffer 中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.vertexBuffer = [<span class="keyword">self</span>.mtlDevice newBufferWithBytes:vertexArrayData length:<span class="keyword">sizeof</span>(vertexArrayData) options:<span class="number">0</span>]; <span class="comment">// 利用数组初始化一个顶点缓存，MTLResourceStorageModeShared 资源存储在CPU和GPU都可访问的系统存储器中</span></span><br></pre></td></tr></table></figure>

<p>Metal 搜索顶点着色器和片段着色器的范围是以 Bundle 为维度的，在一个 Bundle 内放进任意名称的 Metal 文件，其中的着色器函数都可以被 Metal 搜索并加载到内存中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLLibrary</span>&gt; library = [<span class="keyword">self</span>.mtlDevice newDefaultLibraryWithBundle:[<span class="built_in">NSBundle</span> bundleWithPath:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"XXXXXX"</span> ofType:<span class="string">@"bundle"</span>]] error:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLFunction</span>&gt; vertextFunc = [library newFunctionWithName:<span class="string">@"vertex_func"</span>];</span><br><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLFunction</span>&gt; fragFunc = [library newFunctionWithName:<span class="string">@"fragment_func"</span>]; <span class="comment">//从 bundle 中获取顶点着色器和片段着色器</span></span><br></pre></td></tr></table></figure>

<p>接下来要将着色器函数装配到渲染管线上，需要用到 MTLRenderPipelineDescriptor 对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MTLRenderPipelineDescriptor</span> *pipelineDescriptor = [<span class="built_in">MTLRenderPipelineDescriptor</span> new];</span><br><span class="line">pipelineDescriptor.vertexFunction = vertextFunc;</span><br><span class="line">pipelineDescriptor.fragmentFunction = fragFunc;</span><br><span class="line">pipelineDescriptor.colorAttachments[<span class="number">0</span>].pixelFormat = <span class="built_in">MTLPixelFormatBGRA8Unorm</span>; <span class="comment">//此设置配置像素格式，以便通过渲染管线的所有内容都符合相同的颜色分量顺序（在本例中为Blue(蓝色)，Green(绿色)，Red(红色)，Alpha(阿尔法)）以及尺寸（在这种情况下，8-bit(8位)颜色值变为 从0到255）</span></span><br><span class="line"><span class="keyword">self</span>.pipelineState = [<span class="keyword">self</span>.mtlDevice newRenderPipelineStateWithDescriptor:pipelineDescriptor error:<span class="literal">nil</span>]; <span class="comment">// 初始化一个渲染管线状态描述位，相当于 CPU 和 GPU 之间建立的管道</span></span><br></pre></td></tr></table></figure>

<p>最后是初始化渲染队列，以及创建纹理缓存</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.commandQueue = [<span class="keyword">self</span>.mtlDevice newCommandQueue]; <span class="comment">// 获取一个渲染队列，其中装载需要渲染的指令 MTLCommandBuffer    </span></span><br><span class="line">CVMetalTextureCacheCreate(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="keyword">self</span>.mtlDevice, <span class="literal">NULL</span>, &amp;_textureCache); <span class="comment">// 创建纹理缓存</span></span><br></pre></td></tr></table></figure>

<h2 id="2-图片纹理加载"><a href="#2-图片纹理加载" class="headerlink" title="2. 图片纹理加载"></a>2. 图片纹理加载</h2><p>Metal 为加载图片纹理提供了便捷类 MTKTextureLoader，能够根据多种参数生成 MTLTexture 纹理对象，但是实际使用中发现了两个问题：</p>
<ul>
<li>问题1：BGRA 问题</li>
</ul>
<p>Metal 的渲染视图 MTKView 默认支持的 pixelFormat 是 MTLPixelFormatBGRA8Unorm，而说明文档上说 MTKView 还支持以下格式</p>
<blockquote>
<p>The color pixel format for the current drawable’s texture.<br>The pixel format for a MetalKit view must be MTLPixelFormatBGRA8Unorm, MTLPixelFormatBGRA8Unorm_sRGB, MTLPixelFormatRGBA16Float, MTLPixelFormatBGRA10_XR, or MTLPixelFormatBGRA10_XR_sRGB.</p>
</blockquote>
<p>但是我尝试设置为其他值时都发生了 crash，所以整个渲染流程、命令编码过程中都需要设置 pixelFormat 为 BGRA 格式，这样遇到的问题就是针对一些内部像素排列顺序是 RGBA 格式的图片，生成的纹理和最终渲染出来的图片会发蓝，为了确保传入的图片都是 BGRA 格式的图片，我预先将传入的图片按 BGRA 渲染到 CGContext 上，再提取出 UIImage 对象传入</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)bitmapFromImage:(<span class="built_in">UIImage</span> *)targetImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = targetImage.CGImage;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSUInteger</span> iWidth = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> iHeight = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> iBytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> iBytesPerRow = iBytesPerPixel * iWidth;</span><br><span class="line">    <span class="built_in">NSUInteger</span> iBitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *imageBytes = malloc(iWidth * iHeight * iBytesPerPixel);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorspace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(imageBytes,</span><br><span class="line">                                                 iWidth,</span><br><span class="line">                                                 iHeight,</span><br><span class="line">                                                 iBitsPerComponent,</span><br><span class="line">                                                 iBytesPerRow,</span><br><span class="line">                                                 colorspace,</span><br><span class="line">                                                 kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst); <span class="comment">// 转 BGRA 格式</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, iWidth, iHeight);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, rect, imageRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorspace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="keyword">return</span> imageBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSData</span> *)imageDataFromBitmap:(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)imageBytes imageSize:(<span class="built_in">CGSize</span>)imageSize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(imageBytes,</span><br><span class="line">                                                 imageSize.width,</span><br><span class="line">                                                 imageSize.height,</span><br><span class="line">                                                 <span class="number">8</span>,</span><br><span class="line">                                                 imageSize.width * <span class="number">4</span>,</span><br><span class="line">                                                 colorSpace,</span><br><span class="line">                                                 kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *result = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">    <span class="built_in">NSData</span> *imageData = <span class="built_in">UIImagePNGRepresentation</span>(result);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">    <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题2：sRGB 问题</li>
</ul>
<p>这个问题的表现现象是最终渲染出来的图片偏暗，即使是原图也会偏暗，StackOverflow 上有很多对这个 strange color 问题的回答，均提到将 MTKTextureLoader 的 MTKTextureLoaderOptionSRGB 选项设置为 NO，它默认为 YES。</p>
<p>我的理解是，sRGB 实际上是一种对颜色的编码，其效果是增加暗色域的编码精度，降低亮色域的编码精度。那么针对 sRGB 编码的图片就需要进行一次 gamma 校正，以确保进行诸如 LUT 对照计算时能够严格按照线性 RGB 计算。但是实际上我传入的图片都是以 RGB 格式排列，因此不需要进行 gamma 校正，如果不设置关闭 sRGB 的校正，就会对线性 RGB 格式的数据进行校正，导致最终图片偏暗。这个问题在我做 CoreImage 的滤镜调研时也出现过，下面是效果图</p>
<p><img src="/images/1000992-2811944b586055db.jpeg" alt=""></p>
<ul>
<li>最终代码</li>
</ul>
<p>生成 LUT 纹理代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *imageBytes = [<span class="keyword">self</span> bitmapFromImage:lutImage];</span><br><span class="line"><span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span> imageDataFromBitmap:imageBytes imageSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGImageGetWidth</span>(lutImage.CGImage), <span class="built_in">CGImageGetHeight</span>(lutImage.CGImage))];</span><br><span class="line">free(imageBytes);</span><br><span class="line"><span class="keyword">self</span>.lutTexture = [loader newTextureWithData:imageData options:@&#123;<span class="built_in">MTKTextureLoaderOptionSRGB</span>:@(<span class="literal">NO</span>)&#125; error:&amp;err]; <span class="comment">// 生成 LUT 滤镜纹理</span></span><br></pre></td></tr></table></figure>

<p>生成原图纹理代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *imageBytes = [<span class="keyword">self</span> bitmapFromImage:image];</span><br><span class="line"><span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span> imageDataFromBitmap:imageBytes imageSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGImageGetWidth</span>(image.CGImage), <span class="built_in">CGImageGetHeight</span>(image.CGImage))];</span><br><span class="line">free(imageBytes);    </span><br><span class="line"><span class="built_in">MTKTextureLoader</span> *loader = [[<span class="built_in">MTKTextureLoader</span> alloc] initWithDevice:<span class="keyword">self</span>.mtlDevice];</span><br><span class="line"><span class="built_in">NSError</span>* err;</span><br><span class="line"><span class="keyword">self</span>.originalTexture = [loader newTextureWithData:imageData options:@&#123;<span class="built_in">MTKTextureLoaderOptionSRGB</span>:@(<span class="literal">NO</span>)&#125; error:&amp;err];</span><br></pre></td></tr></table></figure>

<h2 id="3-着色器代码"><a href="#3-着色器代码" class="headerlink" title="3. 着色器代码"></a>3. 着色器代码</h2><p>Metal 着色器代码与 OpenGLES 的着色器类似，因为它们的原理都是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;metal_stdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> metal;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">    packed_float4 <span class="built_in">position</span>;</span><br><span class="line">    packed_float2 texCoords;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColoredVertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 <span class="built_in">position</span> [[<span class="built_in">position</span>]];</span><br><span class="line">    float2 texCoords;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vertex ColoredVertex <span class="title">vertex_func</span><span class="params">(constant Vertex *vertices [[<span class="built_in">buffer</span>(<span class="number">0</span>)]], uint vid [[vertex_id]])</span> </span>&#123;</span><br><span class="line">    Vertex inVertex = vertices[vid];</span><br><span class="line">    ColoredVertex outVertex;</span><br><span class="line">    outVertex.<span class="built_in">position</span> = inVertex.<span class="built_in">position</span>;</span><br><span class="line">    outVertex.texCoords = inVertex.texCoords;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> outVertex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fragment half4 <span class="title">fragment_func</span><span class="params">(ColoredVertex vert [[stage_in]], texture2d&lt;half&gt; originalTexture [[texture(<span class="number">0</span>)]], texture2d&lt;half&gt; lutTexture [[texture(<span class="number">1</span>)]])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stage_in 修饰光栅化顶点</span></span><br><span class="line">    <span class="keyword">float</span> <span class="built_in">width</span> = originalTexture.get_width();</span><br><span class="line">    <span class="keyword">float</span> <span class="built_in">height</span> = originalTexture.get_height();</span><br><span class="line">    uint2 gridPos = uint2(vert.texCoords.x * <span class="built_in">width</span> ,vert.texCoords.y * <span class="built_in">height</span>);</span><br><span class="line">    </span><br><span class="line">    half4 color = originalTexture.<span class="built_in">read</span>(gridPos);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> blueColor = color.b * <span class="number">63.0</span>;</span><br><span class="line">    </span><br><span class="line">    int2 quad1;</span><br><span class="line">    quad1.y = <span class="built_in">floor</span>(<span class="built_in">floor</span>(blueColor) / <span class="number">8.0</span>);</span><br><span class="line">    quad1.x = <span class="built_in">floor</span>(blueColor) - (quad1.y * <span class="number">8.0</span>);</span><br><span class="line">    </span><br><span class="line">    int2 quad2;</span><br><span class="line">    quad2.y = <span class="built_in">floor</span>(<span class="built_in">ceil</span>(blueColor) / <span class="number">8.0</span>);</span><br><span class="line">    quad2.x = <span class="built_in">ceil</span>(blueColor) - (quad2.y * <span class="number">8.0</span>);</span><br><span class="line">    </span><br><span class="line">    half2 texPos1;</span><br><span class="line">    texPos1.x = (quad1.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * color.r);</span><br><span class="line">    texPos1.y = (quad1.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * color.g);</span><br><span class="line">    </span><br><span class="line">    half2 texPos2;</span><br><span class="line">    texPos2.x = (quad2.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * color.r);</span><br><span class="line">    texPos2.y = (quad2.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * color.g);</span><br><span class="line">    </span><br><span class="line">    half4 newColor1 = lutTexture.<span class="built_in">read</span>(uint2(texPos1.x * <span class="number">512</span>,texPos1.y * <span class="number">512</span>));</span><br><span class="line">    half4 newColor2 = lutTexture.<span class="built_in">read</span>(uint2(texPos2.x * <span class="number">512</span>,texPos2.y * <span class="number">512</span>));</span><br><span class="line">    </span><br><span class="line">    half4 newColor = mix(newColor1, newColor2, half(fract(blueColor)));</span><br><span class="line">    half4 finalColor = mix(color, half4(newColor.rgb, <span class="number">1.0</span>), half(<span class="number">1.0</span>));</span><br><span class="line">    </span><br><span class="line">    half4 realColor = half4(finalColor);</span><br><span class="line">    <span class="keyword">return</span> realColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处不再赘述。</p>
<h2 id="4-渲染到屏幕"><a href="#4-渲染到屏幕" class="headerlink" title="4. 渲染到屏幕"></a>4. 渲染到屏幕</h2><p>渲染过程首先要获取到下一个内容区缓存，即“画布”</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">CAMetalDrawable</span>&gt; drawable = [(<span class="built_in">CAMetalLayer</span>*)[<span class="keyword">self</span>.mtlView layer] nextDrawable]; <span class="comment">// 获取下一个可用的内容区缓存，用于绘制内容</span></span><br><span class="line"><span class="keyword">if</span> (!drawable) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后生成 MTLRenderPassDescriptor，相当于对此次渲染流程的描述符</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MTLRenderPassDescriptor</span> *renderPassDescriptor = [<span class="keyword">self</span>.mtlView currentRenderPassDescriptor]; <span class="comment">// 获取当前的渲染描述符</span></span><br><span class="line"><span class="keyword">if</span> (!renderPassDescriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">renderPassDescriptor.colorAttachments[<span class="number">0</span>].clearColor = <span class="built_in">MTLClearColorMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1.0</span>); <span class="comment">// 设置颜色附件的清除颜色</span></span><br><span class="line">renderPassDescriptor.colorAttachments[<span class="number">0</span>].loadAction = <span class="built_in">MTLLoadActionClear</span>; <span class="comment">// 用于避免渲染新的帧时附带上旧的内容</span></span><br></pre></td></tr></table></figure>

<p>接下来从命令队列中取出一个可用的命令 buffer，装载进去一个命令编码器，命令编码器里包含着色器所需的顶点、纹理等</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLCommandBuffer</span>&gt; commandBuffer = [<span class="keyword">self</span>.commandQueue commandBuffer]; <span class="comment">// 获取一个可用的命令 buffer</span></span><br><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">MTLRenderCommandEncoder</span>&gt; commandEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor]; <span class="comment">// 通过渲染描述符构建 encoder</span></span><br><span class="line">[commandEncoder setCullMode:<span class="built_in">MTLCullModeBack</span>]; <span class="comment">// 设置剔除背面</span></span><br><span class="line">[commandEncoder setFrontFacingWinding:<span class="built_in">MTLWindingClockwise</span>]; <span class="comment">// 设定按顺时针顺序绘制顶点的图元是朝前的</span></span><br><span class="line">[commandEncoder setViewport:(<span class="built_in">MTLViewport</span>)&#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="keyword">self</span>.mtlView.drawableSize.width, <span class="keyword">self</span>.mtlView.drawableSize.height, <span class="number">-1.0</span>, <span class="number">1.0</span> &#125;]; <span class="comment">// 设置可视区域</span></span><br><span class="line">[commandEncoder setRenderPipelineState:<span class="keyword">self</span>.pipelineState];<span class="comment">// 设置渲染管线状态位</span></span><br><span class="line">[commandEncoder setVertexBuffer:<span class="keyword">self</span>.vertexBuffer offset:<span class="number">0</span> atIndex:<span class="number">0</span>]; <span class="comment">// 设置顶点buffer</span></span><br><span class="line">[commandEncoder setFragmentTexture:<span class="keyword">self</span>.originalTexture atIndex:<span class="number">0</span>]; <span class="comment">// 设置纹理 0，即原图</span></span><br><span class="line">[commandEncoder setFragmentTexture:<span class="keyword">self</span>.lutTexture atIndex:<span class="number">1</span>]; <span class="comment">// 设置纹理 1，即 LUT 图</span></span><br><span class="line">[commandEncoder drawPrimitives:<span class="built_in">MTLPrimitiveTypeTriangle</span> vertexStart:<span class="number">0</span> vertexCount:<span class="number">6</span>]; <span class="comment">// 绘制三角形图元</span></span><br></pre></td></tr></table></figure>

<p>最终提交到队列中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[commandEncoder endEncoding];</span><br><span class="line">[commandBuffer presentDrawable:drawable];</span><br><span class="line">[commandBuffer commit];</span><br></pre></td></tr></table></figure>

<p>仍然选取如下原图做测试</p>
<p><img src="/images/1000992-f4f2b4f9b2b2e681.png" alt=""></p>
<p>选择如下 LUT 图</p>
<p><img src="/images/1000992-ceed2484542cebb4.png" alt=""></p>
<p>最终滤镜效果</p>
<p><img src="/images/1000992-ad53a1779a2fce71.png" alt=""></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
        <tag>滤镜</tag>
        <tag>Metal</tag>
      </tags>
  </entry>
  <entry>
    <title>利用category定义一段宏代码</title>
    <url>/2018/08/22/iOS%E5%BC%80%E5%8F%91/%E5%88%A9%E7%94%A8category%E5%AE%9A%E4%B9%89%E4%B8%80%E6%AE%B5%E5%AE%8F%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>近期在对 iOS 页面生命周期进行测速跟踪时，需要在 UIVIewController 的生命周期方法里加入打点代码，同时还需要持有打点任务对象，对 VC 类的侵入较大，且冗余代码较多。本来计划采用 hook 方法，考虑到风险并未实行，最终决定采用宏定义代码的方式实现。</p>
<p>首先实现一个 UIViewController 的分类，在分类里通过关联对象将追踪任务对象 task 加入给 VC 对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Track</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *speedTask = <span class="string">@"pageSpeedTask"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trackDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Yasic track Did Load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSObject</span> *)metricsSpeedTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *task = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;speedTask);</span><br><span class="line">    <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">        task = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;speedTask, task, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这里仅仅用 NSObject 作为举例，打点方法也只打印一句日志用作标识。</p>
<p>objectivec 的所有关联对象都存在于一个全局 map 里面，map 的 key 是这个对象的指针地址，而这个 map 的 value 又是另外一个 map，里面保存了此对象对应关联对象的 kv 对。</p>
<p>category 会在运行时执行时将方法注册到对应的类对象上，即使不引入 category 头文件也可以通过反射调用对应方法，因此可以直接在某个 VC 中执行下面的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"trackDidLoad"</span>)]) &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"trackDidLoad"</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样会带来一个编译期警告</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">PerformSelector may cause a leak because its selector is unknown</span><br></pre></td></tr></table></figure>

<p>原因是 ARC 在编译期需要知道所有方法的参数和返回值，根据方法返回值来加入管理内存引用计数的代码，具体来说</p>
<ul>
<li>基本类型直接忽略</li>
<li>常用对象先 retain，等到用不到的时候再 release</li>
<li>初始化方法返回的对象不 retain，等到用不到的时候直接 release</li>
<li>什么也不做，默认返回值在返回前后是始终有效的（一直到最近的 release pool 结束为止，用于标注ns_returns_autoreleased的方法）</li>
</ul>
<p>然而 NSSelectorFromString 不能确定这些，因而无法加入合适的 ARC 代码。</p>
<p>消除警告的方式是临时忽略 clang 中对于 perform 的警告</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"trackDidLoad"</span>)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"trackDidLoad"</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure>

<p><strong>但是这样仍然会有风险，如果调用了类似 init 的方法，会因为没有执行 release 操作的代码而不能释放这个对象。</strong></p>
<p>这段代码也很冗余，所以接下来在某个全局的宏定义文件里定义一个宏用于调用这段代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VC_TRACK_VIEW_DID_LOAD \</span></span><br><span class="line">_Pragma(<span class="string">"clang diagnostic push"</span>)\</span><br><span class="line">_Pragma(<span class="string">"clang diagnostic ignored \"-Warc-performSelector-leaks\""</span>)\</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"sak_pageTrackViewDidLoad"</span>)]) &#123;\</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"sak_pageTrackViewDidLoad"</span>)];\</span><br><span class="line">&#125;\</span><br><span class="line">_Pragma(<span class="string">"clang diagnostic pop"</span>)</span><br></pre></td></tr></table></figure>

<p>使用 <code>_Pragma</code> 格式是为了在宏定义中实现换行效果</p>
<p>最终需要调用时直接调用 <code>VC_TRACK_VIEW_DID_LOAD</code> 即可。</p>
<p>更推荐的 perform 方式如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"trackDidLoad"</span>);</span><br><span class="line">IMP imp = [<span class="keyword">self</span> methodForSelector:selector];</span><br><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">id</span>, SEL) = (<span class="keyword">void</span> *)imp;</span><br><span class="line">func(<span class="keyword">self</span>, selector);</span><br></pre></td></tr></table></figure>

<hr>
<p>关于 category</p>
<blockquote>
<p>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA</p>
</blockquote>
<blockquote>
<p>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</p>
</blockquote>
<p>参考链接</p>
<ul>
<li><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">https://tech.meituan.com/DiveIntoCategory.html</a></li>
<li><a href="https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown" target="_blank" rel="noopener">https://stackoverflow.com/questions/7017281/performselector-may-cause-a-leak-because-its-selector-is-unknown</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>OC Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS实现LUT滤镜的几种方式的探究</title>
    <url>/2018/05/31/iOS%E5%BC%80%E5%8F%91/iOS%E5%AE%9E%E7%8E%B0LUT%E6%BB%A4%E9%95%9C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<p>在 app 内利用各种图形算法可以对图片进行一些变换，这样的效果也称为“滤镜”，滤镜效果大致可以分为以下几类：</p>
<ul>
<li>独立像素点变换，包括亮度、对比、饱和度、色调、灰色化、分离RGB通道等</li>
<li>像素卷积变换，包括边缘检测、浮雕化、模糊、锐化</li>
<li>仿射矩阵变换。包括缩放、旋转、倾斜、扭曲、液化等</li>
<li>多图像合成</li>
</ul>
<p>其中最简单的就是进行独立像素点变换，利用 LUT 技术还可以提供给设计师灵活的方式来自定义各种滤镜效果。</p>
<h2 id="1-LUT-技术"><a href="#1-LUT-技术" class="headerlink" title="1.LUT 技术"></a>1.LUT 技术</h2><h3 id="1-1-LUT-技术简介"><a href="#1-1-LUT-技术简介" class="headerlink" title="1.1 LUT 技术简介"></a>1.1 LUT 技术简介</h3><p>LUT 是 LookUpTable 的简称，也称作颜色查找表技术，它可以分为一维 LUT（1DLUT） 和 三维 LUT（3DLUT）。简单来说，LUT 就是一个 RGB 组合到 RGB 组合的映射，对于一维 LUT，假设映射关系为 LUT1，则</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">LUT</span><span class="params">(R1)</span></span> = R2</span><br><span class="line"><span class="function"><span class="title">LUT</span><span class="params">(G1)</span></span> = G2</span><br><span class="line"><span class="function"><span class="title">LUT</span><span class="params">(B1)</span></span> = B2</span><br></pre></td></tr></table></figure>

<p>其中 R1、G1、B1 为原像素值，R2、G2、B2 为映射像素值，可以看出 1DLUT 的映射颜色值的每一个分量仅与其原始像素值的分量有关，用图像表示如下</p>
<p><img src="/images/1000992-852f4c476db2f3c3.jpg" alt=""></p>
<p>对于 3DLUT，假设其映射关系为 LUT3，则</p>
<p>LUT(R1, G1, B1) = (R2, G2, B2)</p>
<p>3DLUT 相比于 1DLUT 能够实现全立体的色彩空间控制，非常适合用于精确的颜色控制工作，它的示意图如下</p>
<p><img src="/images/1000992-c777bfc79da65659.jpg" alt=""></p>
<p>可以简单做一个计算，如果 RGB 三个分量分别可以取 256 种值的话，那么 3DLUT 技术就可以包含 256X256X256 种情况，大约占 48MB 空间，这样一个 3DLUT 映射关系的数据量有些庞大，通常会采取采样方式来降低数据量，例如可以对每一个分量按照每 4 个变化值为间距，进行 64 次采样，获得一个 64X64X64 大小的映射关系表，对于不在表内的颜色值进行内插法获得其相似结果。</p>
<p>那么获得了 LUT 映射表以后，如何对任意一张图片进行滤镜变换呢。我们可以遍历图片的像素点，对于每一个像素点，获得其 RGB 组合，在 LUT 表格中查找此 RGB 组合及其对应的 RGB 映射值，然后用 RGB 映射值替换原图的像素点，就可以完成滤镜变换了。</p>
<h3 id="1-2-3DLUT-数据存储方式"><a href="#1-2-3DLUT-数据存储方式" class="headerlink" title="1.2 3DLUT 数据存储方式"></a>1.2 3DLUT 数据存储方式</h3><p>3DLUT 是一个三维颜色空间体，通过下面的方式可以将其数据压入一张二维图片中。这里以一张 64X64X64 数据量的 LUT 图为例，它的大小是 512X512</p>
<p><img src="/images/1000992-fd3714627648e7e7.png" alt=""></p>
<p>它在横竖方向上分成了 8X8 一共 64 个小方格，每一个小方格内的 B 分量为一个定值，总共就表示了 B 分量的 64 种可能值。同时对于每一个小方格，横竖方向又各自分为 64 个小格，横向小格的 R 分量依次增加，纵向小格的 G 分量依次增加，通过放大图片可以看到如下细节</p>
<p><img src="/images/1000992-eac5e0a21b8b8746.png" alt=""></p>
<p>这样就将所有数据都存储到一张 LUT 图中了，从图中也可以看出色值随着 RGB 分量变化而变化的情况。</p>
<p>上面所展示的 LUT 图是一张特殊的 LUT 图，因为它的映射关系最简单，原始 RGB 颜色是什么，映射 RGB 颜色就是什么，这样的 LUT 图我们可以将其作为 LUT 参照图，设计师将想实现的滤镜效果分别作用于 LUT  参照图上，可以生成 LUT 滤镜图，其可能情况如下图所示</p>
<p><img src="/images/1000992-5d77580d41cbe1cc.png" alt=""></p>
<p>通过对比 LUT 参照图和 LUT 滤镜图，就能获知任何原始 RGB 色值的映射颜色值是多少了。</p>
<h2 id="2-LUT-滤镜变换过程实现"><a href="#2-LUT-滤镜变换过程实现" class="headerlink" title="2. LUT 滤镜变换过程实现"></a>2. LUT 滤镜变换过程实现</h2><p>iOS 中与图像处理有关的框架大致有以下几个：CoreImage，Metal，OpenGL-ES，第三方框架 GPUImage 等，它们都可以实现 LUT 映射。下面分点阐述。</p>
<h3 id="2-1-CoreImage"><a href="#2-1-CoreImage" class="headerlink" title="2.1 CoreImage"></a>2.1 CoreImage</h3><p>CoreImage 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了 180 种)。CoreImage 实现 LUT 有两种方式：</p>
<ul>
<li>CIColorCube 过滤器</li>
<li>CIKernel</li>
</ul>
<h4 id="2-1-1-CIColorCube-过滤器"><a href="#2-1-1-CIColorCube-过滤器" class="headerlink" title="2.1.1 CIColorCube 过滤器"></a>2.1.1 CIColorCube 过滤器</h4><p>CIColorCube 接受一个 LUT 映射颜色矩阵作为输入参数，对于输入图片进行色值映射，具体实现如下</p>
<ul>
<li>获取 LUT 图的 bitmap</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)createRGBABitmapFromImage:(<span class="built_in">CGImageRef</span>)image</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *bitmap;</span><br><span class="line">    <span class="built_in">NSInteger</span> bitmapSize;</span><br><span class="line">    <span class="built_in">NSInteger</span> bytesPerRow;</span><br><span class="line">    </span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(image);</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(image);</span><br><span class="line">    </span><br><span class="line">    bytesPerRow = width * <span class="number">4</span>;</span><br><span class="line">    bitmapSize = bytesPerRow * height;</span><br><span class="line">    </span><br><span class="line">    bitmap = malloc(bitmapSize);</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="keyword">if</span> (colorSpace == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free(bitmap);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    context = <span class="built_in">CGBitmapContextCreate</span> (bitmap,</span><br><span class="line">                                     width,</span><br><span class="line">                                     height,</span><br><span class="line">                                     <span class="number">8</span>,</span><br><span class="line">                                     bytesPerRow,</span><br><span class="line">                                     colorSpace,</span><br><span class="line">                                     kCGImageAlphaPremultipliedLast);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), image);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成 CIColorCube 所需的 inputCubeData</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">CIFilter</span> *)filterWithLUTImage:(<span class="built_in">UIImage</span> *)image dimension:(<span class="built_in">NSInteger</span>)n</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> width = <span class="built_in">CGImageGetWidth</span>(image.CGImage);</span><br><span class="line">    <span class="built_in">NSInteger</span> height = <span class="built_in">CGImageGetHeight</span>(image.CGImage);</span><br><span class="line">    <span class="built_in">NSInteger</span> row = height/n;</span><br><span class="line">    <span class="built_in">NSInteger</span> column = width/n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((width % n != <span class="number">0</span>) || (height % n != <span class="number">0</span>) || (row * column != n)) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *bitmap = [<span class="keyword">self</span> createRGBABitmapFromImage:image.CGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!bitmap) &#123;<span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> size = n * n * n * <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">4</span>; <span class="comment">// 所有像素点的 rgba 值个数 64 * 64 * 64 * 4</span></span><br><span class="line">    <span class="keyword">float</span> *data = malloc(size); <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="built_in">NSInteger</span> bitmapOffest = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> rowIndex = <span class="number">0</span>; rowIndex &lt; row; rowIndex++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> originalZ = z;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> columnIndex = <span class="number">0</span>; columnIndex &lt; column; columnIndex++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSInteger</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> r = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)bitmap[bitmapOffest];</span><br><span class="line">                    <span class="keyword">double</span> g = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)bitmap[bitmapOffest + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">double</span> b = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)bitmap[bitmapOffest + <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">double</span> a = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)bitmap[bitmapOffest + <span class="number">3</span>];</span><br><span class="line">                    <span class="built_in">NSInteger</span> dataOffset = (z * n * n + y * n + x) * <span class="number">4</span>; <span class="comment">// 在大存储空间中的偏移，z 从 0 开始，z 偏移一个，总共偏移 64 * 64 个点，y 偏移一个，总共偏移 64 个点，加上 x 个点，乘以 rgba 的 4 个点</span></span><br><span class="line">                    <span class="comment">// 存储值</span></span><br><span class="line">                    data[dataOffset] = r / <span class="number">255.0</span>;</span><br><span class="line">                    data[dataOffset + <span class="number">1</span>] = g / <span class="number">255.0</span>;</span><br><span class="line">                    data[dataOffset + <span class="number">2</span>] = b / <span class="number">255.0</span>;</span><br><span class="line">                    data[dataOffset + <span class="number">3</span>] = a / <span class="number">255.0</span>;</span><br><span class="line">                    </span><br><span class="line">                    bitmapOffest += <span class="number">4</span>; <span class="comment">// 偏移 4 个点</span></span><br><span class="line">                &#125;</span><br><span class="line">                z++;</span><br><span class="line">            &#125;</span><br><span class="line">            z = originalZ; <span class="comment">// 每一行遍历完，z 恢复到行头所属块的 index</span></span><br><span class="line">        &#125;</span><br><span class="line">        z += column;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(bitmap); <span class="comment">// 释放位图</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIColorCube"</span>];</span><br><span class="line">    [filter setValue:[<span class="built_in">NSData</span> dataWithBytesNoCopy:data length:size freeWhenDone:<span class="literal">YES</span>] forKey:<span class="string">@"inputCubeData"</span>];</span><br><span class="line">    [filter setValue:[<span class="built_in">NSNumber</span> numberWithInteger:n] forKey:<span class="string">@"inputCubeDimension"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里读取的时候就是按照 3DLUT 存储方式来读取到一个存储空间里的。</p>
<ul>
<li>封装并使用</li>
</ul>
<p>将上述过程封装为一个 Category，传入原图，得到处理后的图片</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CIImage</span> *image = [[<span class="built_in">CIImage</span> alloc] initWithImage:<span class="keyword">self</span>.mediaAsset.assetImage];</span><br><span class="line"><span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithLUTImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"lookup_yth002"</span>] dimension:<span class="number">64</span>];</span><br><span class="line">[filter setValue:image forKey:<span class="string">@"inputImage"</span>];</span><br><span class="line"><span class="built_in">CIImage</span> *outputImage = [filter outputImage];</span><br><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CGImageRef</span> cgImage = [context createCGImage:outputImage fromRect:[outputImage extent]];</span><br><span class="line"><span class="built_in">UIImage</span> *result = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];</span><br><span class="line"><span class="built_in">CGImageRelease</span>(cgImage);</span><br></pre></td></tr></table></figure>

<p>下面以一个具体图片进行效果对比</p>
<p>我们用下面这张图作为原始待处理的图片</p>
<p><img src="/images/1000992-f4f2b4f9b2b2e681.png" alt=""></p>
<p>通过 PS 进行一系列处理后的目标效果图如下</p>
<p><img src="/images/1000992-ad53a1779a2fce71.png" alt=""></p>
<p>对 LUT 参照图进行相同处理后得到 LUT 滤镜图</p>
<p><img src="/images/1000992-0c81388b8bbb48b2.png" alt=""></p>
<p>拿着 LUT 通过 CIColorCube 过滤器得到效果图如下</p>
<p><img src="/images/1000992-c9d57726bad5d5f0.png" alt=""></p>
<p>可以看到效果不是太理想，因此我换了一种方式进行转换。</p>
<h3 id="2-2-CIKernel"><a href="#2-2-CIKernel" class="headerlink" title="2.2 CIKernel"></a>2.2 CIKernel</h3><p>CoreImage 除了自带的很多 Filter，还支持用户自定义 Filter，这需要用到 CIKernel 脚本，它使用 Core Image Kernel Language (CIKL) 语言来编写，CIKL 语言是 OpenGL Shading Language (GLSL) 的子集，因此很多语法、变量都和 GLSL 类似。</p>
<p>这里我们编写一个 CIKernel 脚本，传入原图和 LUT 图，并进行颜色映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">kernel vec4 <span class="title">YasicLUT</span><span class="params">(sampler inputImage, sampler inputLUT, <span class="keyword">float</span> intensity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sample 函数从图片的指定坐标提取颜色值 rgba</span></span><br><span class="line">    vec4 textureColor = sample(inputImage,samplerCoord(inputImage));</span><br><span class="line">    <span class="comment">// clamp 函数对 rgba 进行归一化，转化为 0 到 1.0 之间的值</span></span><br><span class="line">    textureColor = clamp(textureColor, vec4(<span class="number">0.0</span>), vec4(<span class="number">1.0</span>));</span><br><span class="line">    <span class="comment">// 获取 b 值，从而确定在 LUT 图中的大方格下标</span></span><br><span class="line">    <span class="keyword">float</span> blueColor = textureColor.b * <span class="number">63.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取下边界方格和上边界方格，下边界指与此 b 分量最接近的下边界方格，如 b 分量为 2，则下边界方格 为 0 方格，上边界方格为 1 方格 </span></span><br><span class="line">    highp vec2 quad1;</span><br><span class="line">    quad1.y = <span class="built_in">floor</span>(<span class="built_in">floor</span>(blueColor) / <span class="number">8.0</span>);</span><br><span class="line">    quad1.x = <span class="built_in">floor</span>(blueColor) - (quad1.y * <span class="number">8.0</span>);</span><br><span class="line">    highp vec2 quad2;</span><br><span class="line">    quad2.y = <span class="built_in">floor</span>(<span class="built_in">ceil</span>(blueColor) / <span class="number">7.999</span>);</span><br><span class="line">    quad2.x = <span class="built_in">ceil</span>(blueColor) - (quad2.y * <span class="number">8.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从下边界大方格中，获取对应的小方格坐标，通过 r 值确定横坐标，通过 g 值确定纵坐标</span></span><br><span class="line">    <span class="comment">// 这里进行的乘法操作是为了将坐标进行归一化，也就是都除了 LUT 图宽 512，同时由于所求坐标值必须是每个像素格的中心位置，所以进行了 0.5 像素偏移和 1 像素偏移，它的效果是，如果 r 或者 g 分量为 0，则刚好向右偏移 0.5 像素，不为 0 则向左偏移 0.5 像素，从而保证取到正确的像素格。</span></span><br><span class="line">    highp vec2 texPos1;</span><br><span class="line">    texPos1.x = (quad1.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r);</span><br><span class="line">    texPos1.y = (quad1.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g);</span><br><span class="line"></span><br><span class="line">    highp vec2 texPos2;</span><br><span class="line">    texPos2.x = (quad2.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r);</span><br><span class="line">    texPos2.y = (quad2.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取上下边界对应像素值</span></span><br><span class="line">    vec4 newColor1 = sample(inputLUT, texPos1);</span><br><span class="line">    vec4 newColor2 = sample(inputLUT, texPos2);</span><br><span class="line">    <span class="comment">// mix 方法根据 b 分量进行两个像素值的混合</span></span><br><span class="line">    vec4 newColor = mix(newColor1, newColor2, fract(blueColor));</span><br><span class="line">    <span class="keyword">return</span> mix(textureColor, vec4(newColor.rgb, textureColor.a), intensity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将此 kernel 文件读取到内存中，生成对应的 CIKernel 对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *kernelString = [[<span class="built_in">NSString</span> alloc] initWithContentsOfURL:[[<span class="built_in">NSBundle</span> bundleForClass:<span class="keyword">self</span>.class] URLForResource:<span class="string">@"YasicLUT"</span> withExtension:<span class="string">@"cikernel"</span>] encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CIKernel</span> *kernel = [<span class="built_in">CIKernel</span> kernelWithString:kernelString];</span><br></pre></td></tr></table></figure>

<p>然后对图片进行变换</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.resultImageView.image = [<span class="built_in">UIImage</span> imageWithCIImage:[kernel applyWithExtent:ciTargetImage.extent roiCallback:^<span class="built_in">CGRect</span>(<span class="keyword">int</span> index, <span class="built_in">CGRect</span> destRect) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 原图</span></span><br><span class="line">        <span class="keyword">return</span> destRect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// LUT 图</span></span><br><span class="line">        <span class="keyword">return</span> ciLUTImage.extent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; arguments:@[ciTargetImage, ciLUTImage], @(<span class="number">1.0</span>)]]];</span><br></pre></td></tr></table></figure>

<p>这里用到了一个重要函数</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">CIImage</span> *)applyWithExtent:(<span class="built_in">CGRect</span>)extent</span><br><span class="line">                          roiCallback:(<span class="built_in">CIKernelROICallback</span>)callback</span><br><span class="line">                            arguments:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&gt; *)args;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数</p>
<ul>
<li>extent，表示当前 Filter 处理的图片区域，此处就是待处理图片的区域</li>
<li>callBack，需要返回 ROI，即在一定的时间内特别感兴趣的区域，这里根据 index 值，如果 index 为 0，表示是原图，就将传入的 destRect 直接返回即可，如果 index 为 1，表示 LUT 图，则需要将整个 LUT 图的区域都返回，因为我们并不能根据原图待处理区域确定 LUT 图对应的感兴趣区域</li>
<li>arguments，CIKernel 脚本所需参数，根据我们前面写的 CIKernel 脚本，这里依次传入原图和 LUT  图即可。</li>
</ul>
<p>下面是 CIKernel 处理的效果图</p>
<p><img src="/images/1000992-2811944b586055db.jpeg" alt=""></p>
<p>效果也不是很理想，猜测可能是 CIImage 内部对图片进行了一些处理，导致 LUT 映射出现偏差，我们用 GPUImage 库验证 LUT 技术的可行性。</p>
<h3 id="2-3-GPUImage"><a href="#2-3-GPUImage" class="headerlink" title="2.3 GPUImage"></a>2.3 GPUImage</h3><p>GPUImage 是一个非常强大的开源图像处理库，基于 GPU 进行图像处理，性能相比 CoreImage 要好很多。GPUImage 本身提供一个 GPUImageLookupFilter 滤镜，只需要传入 LUT 图即可实现 LUT 映射效果，使用如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)generateImage:(<span class="built_in">UIImage</span> *)inputImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *outputImage;</span><br><span class="line">    GPUImagePicture *stillImageSource = [[GPUImagePicture alloc] initWithImage:inputImage];    </span><br><span class="line">    <span class="comment">//添加滤镜</span></span><br><span class="line">    GPUImageLookupFilter *lookUpFilter = [[GPUImageLookupFilter alloc] init];</span><br><span class="line">    GPUImagePicture *lookupImg = [[GPUImagePicture alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"lookup_freeze"</span>]];    </span><br><span class="line">    [lookupImg addTarget:lookUpFilter atTextureLocation:<span class="number">1</span>];    </span><br><span class="line">    [stillImageSource addTarget:lookUpFilter atTextureLocation:<span class="number">0</span>];    </span><br><span class="line">    [lookUpFilter useNextFrameForImageCapture];    </span><br><span class="line">    <span class="keyword">if</span>([lookupImg processImageWithCompletionHandler:<span class="literal">nil</span>] &amp;&amp; [stillImageSource processImageWithCompletionHandler:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        outputImage = [lookUpFilter imageFromCurrentFramebuffer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终 GPUImage 的处理效果图如下</p>
<p><img src="/images/1000992-e04ccbd090519eb2.jpeg" alt=""></p>
<p>可以看到跟 PS 处理的目标效果图非常接近了，证明用 LUT 技术实现滤镜效果是可行的，接下来可以用 OpenGL-ES 实现这一效果。</p>
<h3 id="2-4-OpenGL-ES"><a href="#2-4-OpenGL-ES" class="headerlink" title="2.4 OpenGL-ES"></a>2.4 OpenGL-ES</h3><p>OpenGL-ES 的基础知识网上有很多，这里列举一些我觉得写得不错的教程和博客，下面就不再赘述一些技术性的概念和函数</p>
<ul>
<li><a href="http://colin1994.github.io/2017/04/01/OpenGLES-Lesson01/" target="_blank" rel="noopener">OpenGL ES 基础概念及系列文章</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31202175" target="_blank" rel="noopener">从 0 打造一个 GPUImage 系列文章</a></li>
<li><a href="https://www.jianshu.com/nb/2135411" target="_blank" rel="noopener">OpenGLES 系列文章</a></li>
</ul>
<p>iOS 原生支持 OpenGL-ES，OpenGL-ES 利用图形渲染管线（Graphic Pipeline）将原始图像数据经过变换处理后展示到屏幕上，其具体的流程如下</p>
<p><img src="/images/1000992-8b96799868a5e202" alt=""></p>
<p>其中顶点着色器（VertexShader）和片段着色器（FragmentShader）是可编程部分，也是主要开发部分，它们就是用前面提到的 GLSL 语法实现的。简单来说，我们需要向 OpenGL-ES 输入一系列的顶点，它们标识了某一帧的边界，以及每一个顶点上的色值或者纹理坐标值（用于寻找对应的纹理贴图），OpenGL-ES 执行顶点着色器处理顶点数据，然后将顶点间划分成一个个片段，并行地进行片段着色，也就是执行片段着色器，最终形成完整的图形数据。</p>
<p>OpenGL-ES 将图形数据定义为帧缓存（frameBuffer），它类似于一个指针，而真正保存像素值等具体色值的对象是渲染缓存（renderBuffer），帧缓存则保存并维护了渲染缓存的索引。通过 OpenGL-ES 绘制一帧到屏幕的流程如下</p>
<ul>
<li>设置 EAGLContext</li>
<li>设置 RenderBuffer</li>
<li>设置 FrameBuffer</li>
<li>设置 ViewPort</li>
<li>编译 Shader</li>
<li>传入顶点数据</li>
<li>绘制到屏幕</li>
</ul>
<p>但是这里我们最终需要获取 OpenGL-ES 生成的图片，而不是将其渲染到屏幕上，所以流程略有不同</p>
<ul>
<li>设置 EAGLContext</li>
<li>创建离屏帧缓存</li>
<li>设置 ViewPort</li>
<li>编译 Shader</li>
<li>传入顶点数据和纹理数据</li>
<li>绘制到帧缓存</li>
<li>获取渲染图片</li>
</ul>
<p>具体代码如下</p>
<h4 id="2-4-1-设置-EAGLContext"><a href="#2-4-1-设置-EAGLContext" class="headerlink" title="2.4.1 设置 EAGLContext"></a>2.4.1 设置 EAGLContext</h4><p>需要确定使用的 OpenGL-ES 版本，这里选择 OpenGL-ES2.0 API，同时设置 CAEAGLLayer 对象作为绘制对象，它的作用有两个，其一是为渲染缓存分配共享存储，其二是将渲染缓存区呈现给 CoreAnimation，用 renderBuffer 的数据替换之前的内容，相当于是承接 RenderBuffer 和上层 UI 的抽象层。这里还设置了 kEAGLDrawablePropertyRetainedBacking 为 YES，表示每次显示时必须完全重绘，不保存上次显示的内容。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.eagLayer = (<span class="built_in">CAEAGLLayer</span> *)<span class="keyword">self</span>.layer;</span><br><span class="line"><span class="keyword">self</span>.eagLayer.drawableProperties = @&#123;kEAGLDrawablePropertyRetainedBacking: @YES,</span><br><span class="line">                                  kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8&#125;;</span><br><span class="line"><span class="keyword">self</span>.eaglContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-创建离屏帧缓存"><a href="#2-4-2-创建离屏帧缓存" class="headerlink" title="2.4.2 创建离屏帧缓存"></a>2.4.2 创建离屏帧缓存</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)createOffScreenFrameBuffer:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    glGenFramebuffers(<span class="number">1</span>, &amp;_offscreenFrameBuffer);</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _offscreenFrameBuffer);</span><br><span class="line">    </span><br><span class="line">    GLuint texture;</span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, image.size.width, image.size.height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    </span><br><span class="line">    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class="line">    <span class="keyword">if</span>(status != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">        printf(<span class="string">"failed to make complete framebuffer object %x"</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里并未将待渲染的图片纹理直接索引到帧缓存中，因为图片尚未处理过，所以只是开辟足够大的空间就可以了。</p>
<h4 id="2-4-3-设置-ViewPort"><a href="#2-4-3-设置-ViewPort" class="headerlink" title="2.4.3 设置 ViewPort"></a>2.4.3 设置 ViewPort</h4><p>ViewPort 能告诉 OpenGL-ES 应该把渲染之后的图形绘制在渲染窗体（如 CAEAGLLayer）的哪一部分</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.targetImage.size.width, <span class="keyword">self</span>.targetImage.size.height);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-4-编译-Shader"><a href="#2-4-4-编译-Shader" class="headerlink" title="2.4.4 编译 Shader"></a>2.4.4 编译 Shader</h4><p>GLSL 编写的顶点着色器和片段着色器都需要在运行时读取到内存中进行编译，这里将它们存储在 Bundle 中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">attribute vec4 <span class="built_in">position</span>;</span><br><span class="line">attribute vec2 a_texCoordIn;</span><br><span class="line">varying vec2 v_TexCoordOut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    v_TexCoordOut = a_texCoordIn;</span><br><span class="line">    gl_Position = <span class="built_in">position</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶点着色器传入顶点坐标后直接赋值给内部参数 gl_Position，纹理坐标传输给片段着色器用于采样纹理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">precision mediump <span class="keyword">float</span>;</span><br><span class="line"></span><br><span class="line">varying vec2 v_TexCoordOut;</span><br><span class="line">uniform sampler2D inputImageTexture;</span><br><span class="line">uniform sampler2D inputImageTexture2; <span class="comment">// lookup texture</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec4 textureColor = texture2D(inputImageTexture, v_TexCoordOut);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> blueColor = textureColor.b * <span class="number">63.0</span>;</span><br><span class="line">    </span><br><span class="line">    vec2 quad1;</span><br><span class="line">    quad1.y = <span class="built_in">floor</span>(<span class="built_in">floor</span>(blueColor) / <span class="number">8.0</span>);</span><br><span class="line">    quad1.x = <span class="built_in">floor</span>(blueColor) - (quad1.y * <span class="number">8.0</span>);</span><br><span class="line">    </span><br><span class="line">    vec2 quad2;</span><br><span class="line">    quad2.y = <span class="built_in">floor</span>(<span class="built_in">ceil</span>(blueColor) / <span class="number">8.0</span>);</span><br><span class="line">    quad2.x = <span class="built_in">ceil</span>(blueColor) - (quad2.y * <span class="number">8.0</span>);</span><br><span class="line">    </span><br><span class="line">    vec2 texPos1;</span><br><span class="line">    texPos1.x = (quad1.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r);</span><br><span class="line">    texPos1.y = (quad1.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g);</span><br><span class="line">    </span><br><span class="line">    vec2 texPos2;</span><br><span class="line">    texPos2.x = (quad2.x * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.r);</span><br><span class="line">    texPos2.y = (quad2.y * <span class="number">0.125</span>) + <span class="number">0.5</span>/<span class="number">512.0</span> + ((<span class="number">0.125</span> - <span class="number">1.0</span>/<span class="number">512.0</span>) * textureColor.g);</span><br><span class="line">    </span><br><span class="line">    vec4 newColor1 = texture2D(inputImageTexture2, texPos1);</span><br><span class="line">    vec4 newColor2 = texture2D(inputImageTexture2, texPos2);</span><br><span class="line">    </span><br><span class="line">    vec4 newColor = mix(newColor1, newColor2, fract(blueColor));</span><br><span class="line">    gl_FragColor = mix(textureColor, vec4(newColor.rgb, textureColor.w), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器与之前的 CIKernel 脚本类似，根据原图的 rgb 值，从 LUT 纹理中提取对应位置的色值，混合后赋值给内部参数 gl_FragColor。</p>
<p>然后进行着色器编译</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    GLuint vertexShader = [<span class="keyword">self</span> compileShader:<span class="string">@"MyTestVertexShader.vsh"</span> withType:GL_VERTEX_SHADER];</span><br><span class="line">    GLuint fragmentShader = [<span class="keyword">self</span> compileShader:<span class="string">@"MyTestFragmentShader.fsh"</span> withType:GL_FRAGMENT_SHADER];</span><br><span class="line">    <span class="keyword">self</span>.programHandle = glCreateProgram();</span><br><span class="line">    glAttachShader(<span class="keyword">self</span>.programHandle, vertexShader);</span><br><span class="line">    glAttachShader(<span class="keyword">self</span>.programHandle, fragmentShader);</span><br><span class="line">    glLinkProgram(<span class="keyword">self</span>.programHandle);</span><br><span class="line">    GLint linkSuccess;</span><br><span class="line">    glGetProgramiv(<span class="keyword">self</span>.programHandle, GL_LINK_STATUS, &amp;linkSuccess);</span><br><span class="line">    <span class="keyword">if</span> (linkSuccess == GL_FALSE) &#123;</span><br><span class="line">        GLchar messages[<span class="number">256</span>];</span><br><span class="line">        glGetProgramInfoLog(<span class="keyword">self</span>.programHandle, <span class="keyword">sizeof</span>(messages), <span class="number">0</span>, &amp;messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"GLGetProgramInfo error:%@"</span>, [<span class="built_in">NSString</span> stringWithUTF8String:messages]);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    glUseProgram(<span class="keyword">self</span>.programHandle);</span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (GLuint)compileShader:(<span class="built_in">NSString</span> *)shaderName withType:(GLenum)shaderType &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *shaderPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:shaderName ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *shaderString = [<span class="built_in">NSString</span> stringWithContentsOfFile:shaderPath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!shaderString) &#123;</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* shaderStringUTF8 = [shaderString UTF8String];</span><br><span class="line">    <span class="keyword">int</span> shaderStringLength = (<span class="keyword">int</span>)[shaderString length];</span><br><span class="line">    </span><br><span class="line">    GLuint shaderHandle = glCreateShader(shaderType);</span><br><span class="line">    </span><br><span class="line">    glShaderSource(shaderHandle, <span class="number">1</span>, &amp;shaderStringUTF8, &amp;shaderStringLength);</span><br><span class="line">    glCompileShader(shaderHandle);</span><br><span class="line">    </span><br><span class="line">    GLint compileSuccess;</span><br><span class="line">    glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &amp;compileSuccess);</span><br><span class="line">    <span class="keyword">if</span> (compileSuccess == GL_FALSE) &#123;</span><br><span class="line">        GLchar messages[<span class="number">256</span>];</span><br><span class="line">        glGetShaderInfoLog(shaderHandle, <span class="keyword">sizeof</span>(messages), <span class="number">0</span>, &amp;messages[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">NSString</span> *messageString = [<span class="built_in">NSString</span> stringWithUTF8String:messages];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"GLGetShaderiv error:%@"</span>, messageString);</span><br><span class="line">        exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shaderHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-5-传入顶点和纹理数据"><a href="#2-4-5-传入顶点和纹理数据" class="headerlink" title="2.4.5 传入顶点和纹理数据"></a>2.4.5 传入顶点和纹理数据</h4><p>OpenGL-ES 坐标系是三维空间坐标系，按照右手法则，以屏幕中心为原点，横向为 X 轴，竖向为 Y 轴，纵向为 Z 轴，进行了归一化，所以订单数据如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>,   <span class="comment">//左下</span></span><br><span class="line">    <span class="number">1</span>,  <span class="number">-1</span>, <span class="number">0</span>,   <span class="comment">//右下</span></span><br><span class="line">    <span class="number">-1</span>, <span class="number">1</span>,  <span class="number">0</span>,   <span class="comment">//左上</span></span><br><span class="line">    <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span> &#125;; <span class="comment">//右上</span></span><br><span class="line">glEnableVertexAttribArray(glGetAttribLocation(<span class="keyword">self</span>.programHandle, <span class="string">"position"</span>));</span><br><span class="line">glVertexAttribPointer(glGetAttribLocation(<span class="keyword">self</span>.programHandle, <span class="string">"position"</span>), <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, vertices);</span><br></pre></td></tr></table></figure>

<p>纹理数据与之对应，但是纹理数据是二维的，并且变化范围是 0 到 1。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLfloat coords[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">glVertexAttribPointer(glGetAttribLocation(<span class="keyword">self</span>.programHandle, <span class="string">"a_texCoordIn"</span>), <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, coords);</span><br><span class="line">glEnableVertexAttribArray(glGetAttribLocation(<span class="keyword">self</span>.programHandle, <span class="string">"a_texCoordIn"</span>));</span><br></pre></td></tr></table></figure>

<p>接下来还需要将待处理的图片和 LUT 转换为 2D 纹理</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (GLuint)getTextureFromImage:(<span class="built_in">UIImage</span> *)image needTranslate:(<span class="built_in">BOOL</span>)need &#123;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = [image <span class="built_in">CGImage</span>];</span><br><span class="line">    size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    GLubyte *textureData = (GLubyte *)malloc(width * height * <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerRow = bytesPerPixel * width;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(textureData, width, height, bitsPerComponent, bytesPerRow, colorSpaceRef, kCGImageAlphaPremultipliedLast|kCGBitmapByteOrder32Big);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (need) &#123;</span><br><span class="line">        <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, height);</span><br><span class="line">        <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>f, <span class="number">-1.0</span>f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextClearRect</span>(context, rect);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, rect, imageRef);</span><br><span class="line">    </span><br><span class="line">    glEnable(GL_TEXTURE_2D);</span><br><span class="line">    </span><br><span class="line">    GLuint texureName;</span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texureName);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texureName);</span><br><span class="line">    </span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    </span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, (GLsizei)width, (GLsizei)height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, textureData);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, <span class="number">0</span>); <span class="comment">//解绑</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(textureData);</span><br><span class="line">    <span class="keyword">return</span> texureName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据坐标系来看纹理图片从 UIKit 读取到 OpenGL 是需要进行上下翻转的，但是经过我实际使用发现，LUT 图不能进行翻转，具体原因不明，所以这里进行了翻转操作的 BOOL 控制</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">GLuint texName = [<span class="keyword">self</span> getTextureFromImage:<span class="keyword">self</span>.targetImage needTranslate:<span class="literal">YES</span>];</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texName);</span><br><span class="line">glUniform1i(glGetUniformLocation(<span class="keyword">self</span>.programHandle, <span class="string">"inputImageTexture"</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">GLuint LUTName = [<span class="keyword">self</span> getTextureFromImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"lookup_yth002"</span>] needTranslate:<span class="literal">NO</span>];</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, LUTName);</span><br><span class="line">glUniform1i(glGetUniformLocation(<span class="keyword">self</span>.programHandle, <span class="string">"inputImageTexture2"</span>), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>将两个纹理数据分别绑定到索引 0 和 1所属的纹理单元上，并传输给 shader 作为参数。</p>
<h4 id="2-4-6-绘制到帧缓存"><a href="#2-4-6-绘制到帧缓存" class="headerlink" title="2.4.6 绘制到帧缓存"></a>2.4.6 绘制到帧缓存</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">glBindFramebuffer(GL_FRAMEBUFFER, _offscreenFrameBuffer);    </span><br><span class="line">glDrawArrays(GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-7-获取渲染图片"><a href="#2-4-7-获取渲染图片" class="headerlink" title="2.4.7 获取渲染图片"></a>2.4.7 获取渲染图片</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getImageFromBuffe:(<span class="keyword">int</span>)width withHeight:(<span class="keyword">int</span>)height &#123;</span><br><span class="line">    GLint x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> dataLength = width * height * <span class="number">4</span>;</span><br><span class="line">    GLubyte *data = (GLubyte*)malloc(dataLength * <span class="keyword">sizeof</span>(GLubyte));</span><br><span class="line">    </span><br><span class="line">    glPixelStorei(GL_PACK_ALIGNMENT, <span class="number">4</span>);</span><br><span class="line">    glReadPixels(x, y, width, height, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGDataProviderRef</span> ref = <span class="built_in">CGDataProviderCreateWithData</span>(<span class="literal">NULL</span>, data, dataLength, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorspace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGImageRef</span> iref = <span class="built_in">CGImageCreate</span>(width, height, <span class="number">8</span>, <span class="number">32</span>, width * <span class="number">4</span>, colorspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast,</span><br><span class="line">                                    ref, <span class="literal">NULL</span>, <span class="literal">true</span>, kCGRenderingIntentDefault);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(width, height));</span><br><span class="line">    <span class="built_in">CGContextRef</span> cgcontext = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetBlendMode</span>(cgcontext, kCGBlendModeCopy);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(cgcontext, <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height), iref);</span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="keyword">self</span>.targetImageView.image = image;</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    free(data);</span><br><span class="line">    <span class="built_in">CFRelease</span>(ref);</span><br><span class="line">    <span class="built_in">CFRelease</span>(colorspace);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(iref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终效果图如下所示</p>
<p><img src="/images/1000992-e04ccbd090519eb2.jpeg" alt=""></p>
<p>可以看到 OpenGL 处理的效果很理想。</p>
<h3 id="2-5-CPU-像素替换与-OpenGL-ES-性能对比"><a href="#2-5-CPU-像素替换与-OpenGL-ES-性能对比" class="headerlink" title="2.5 CPU 像素替换与 OpenGL-ES 性能对比"></a>2.5 CPU 像素替换与 OpenGL-ES 性能对比</h3><p>其实考虑到 LUT 技术的原理就可以想到，对于图片的每一个像素进行查找替换的操作完全可以在 CPU 内存中就能完成，我们通过 CGContextDrawImage 方法获取到原始图片和 LUT 滤镜图的 bitmap，之后通过遍历原始图的 bitmap，根据每一个像素点的 RGB 值查找 LUT 图中对应的像素值，生成一个新的 bitmap，转换为图片，就是一次 LUT 转换。</p>
<p>具体代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bitmapTransition:(<span class="built_in">UIImage</span> *)originalImage LUTImage:(<span class="built_in">UIImage</span> *)LUTImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> width = <span class="built_in">CGImageGetWidth</span>(originalImage.CGImage);</span><br><span class="line">    <span class="built_in">NSInteger</span> height = <span class="built_in">CGImageGetHeight</span>(originalImage.CGImage);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *originalBitmap = [<span class="keyword">self</span> createRGBABitmapFromImage:originalImage.CGImage];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *LUTBitmap = [<span class="keyword">self</span> createRGBABitmapFromImage:LUTImage.CGImage];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *finalBitmap = malloc(width * height * <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; width; column++) &#123;</span><br><span class="line">            <span class="keyword">double</span> r = (<span class="keyword">double</span>)originalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">double</span> g = (<span class="keyword">double</span>)originalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> b = (<span class="keyword">double</span>)originalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> a = (<span class="keyword">double</span>)originalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> ro = r/<span class="number">255.0</span>;</span><br><span class="line">            <span class="keyword">double</span> go = g/<span class="number">255.0</span>;</span><br><span class="line">            <span class="keyword">double</span> bo = b/<span class="number">255.0</span>;</span><br><span class="line">            <span class="keyword">double</span> ao = a/<span class="number">255.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> bIndex = bo * <span class="number">63.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> y1 = floor(floor(bIndex) / <span class="number">8.0</span>);</span><br><span class="line">            <span class="keyword">double</span> x1 = floor(bIndex) - (y1 * <span class="number">8.0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> y2 = floor(ceil(bIndex) / <span class="number">7.99</span>);</span><br><span class="line">            <span class="keyword">double</span> x2 = ceil(bIndex) - (y2 * <span class="number">8.0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> xl1 = (x1 * <span class="number">64.0</span> + <span class="number">0.5</span> + ro * <span class="number">63.0</span>);</span><br><span class="line">            <span class="keyword">int</span> yl1 = (y1 * <span class="number">64.0</span> + <span class="number">0.5</span> + go * <span class="number">63.0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> xl2 = (x2 * <span class="number">64.0</span> + <span class="number">0.5</span> + ro * <span class="number">63.0</span>);</span><br><span class="line">            <span class="keyword">int</span> yl2 = (y2 * <span class="number">64.0</span> + <span class="number">0.5</span> + go * <span class="number">63.0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> rf1 = (<span class="keyword">double</span>)LUTBitmap[yl1 * <span class="number">512</span> * <span class="number">4</span> + xl1 * <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">double</span> gf1 = (<span class="keyword">double</span>)LUTBitmap[yl1 * <span class="number">512</span> * <span class="number">4</span>+ xl1 * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> bf1 = (<span class="keyword">double</span>)LUTBitmap[yl1 * <span class="number">512</span> * <span class="number">4</span> + xl1 * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> rf2 = (<span class="keyword">double</span>)LUTBitmap[yl2 * <span class="number">512</span> * <span class="number">4</span> + xl2 * <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">double</span> gf2 = (<span class="keyword">double</span>)LUTBitmap[yl2 * <span class="number">512</span> * <span class="number">4</span> + xl2 * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> bf2 = (<span class="keyword">double</span>)LUTBitmap[yl2 * <span class="number">512</span> * <span class="number">4</span> + xl2 * <span class="number">4</span> + <span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">double</span> rf0 = rf1 * (<span class="number">1.0</span> - bo) + rf2 * bo;</span><br><span class="line">            <span class="keyword">double</span> gf0 = gf1 * (<span class="number">1.0</span> - bo) + gf2 * bo;</span><br><span class="line">            <span class="keyword">double</span> bf0 = bf1 * (<span class="number">1.0</span> - bo) + bf2 * bo;</span><br><span class="line">            </span><br><span class="line">            finalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span>] = rf0;</span><br><span class="line">            finalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span> + <span class="number">1</span>] = gf0;</span><br><span class="line">            finalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span> + <span class="number">2</span>] = bf0;</span><br><span class="line">            finalBitmap[row * width * <span class="number">4</span> + column * <span class="number">4</span> + <span class="number">3</span>] = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(finalBitmap,</span><br><span class="line">                                                 width,</span><br><span class="line">                                                 height,</span><br><span class="line">                                                 <span class="number">8</span>,</span><br><span class="line">                                                 width * <span class="number">4</span>,</span><br><span class="line">                                                 colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 createRGBABitmapFromImage 方法在开头就提到了，下面的替换操作也是将之前的着色器代码进行了改写，基本思路是相同的，其最终效果图如下</p>
<p><img src="/images/1000992-e04ccbd090519eb2.jpeg" alt=""></p>
<p>可以看到效果和 OpenGL-ES 非常接近，也是很理想的处理效果。但是 CPU 处理像素相比于 GPU 的并行计算性能是很糟糕的，这里以几张不同尺寸的图片，在 iPhone 8 Plus 上对两种方式进行了测试，获得性能比较结果如下。</p>
<p><img src="/images/1000992-a38326e5fc51fd4c.png" alt=""></p>
<p>这样的耗时差距在处理一张图片时尚可接受，但是在相机捕获时实时渲染每一帧图片的时候，就会有显著的性能差别，尤其是 iPhone 8 Plus 相机捕获的每一帧大小几乎都是最后几种情况那么大（4032x3024），因此很有必要采用 OpenGL-ES 实现 LUT 滤镜效果。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
        <tag>滤镜</tag>
        <tag>Metal</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-视频与动画图层</title>
    <url>/2018/04/28/AVFoundation/AVFoundation-%E8%A7%86%E9%A2%91%E4%B8%8E%E5%8A%A8%E7%94%BB%E5%9B%BE%E5%B1%82/</url>
    <content><![CDATA[<p>在编辑视频的过程中，时常有场景需要对视频增添更多个性化的内容，如字幕、水印或者表情等，此时需要对视频增加一个动画叠加层，在实现上来讲就需要结合 AVFoundation 和 CoreAnimation 一同使用。</p>
<p>在 AVFoundation 中使用 CoreAnimation 和在 iOS 其他地方使用 CoreAnimation 一样，但是最大的差别在于时间模型。正常使用 CoreAnimation 的时候，时间模型取决于系统主机，但是视频动画有其自己的时间线，同时需要支持停止、暂停、回退或快进等效果，所以不能直接用系统主机的时间模型向一个视频中添加基于时间的动画。</p>
<p>针对这一特性，AVFoundation 在两个场景下提供了两个工具实现此效果</p>
<ul>
<li>需要在播放视频时加入 CoreAnimation，提供 AVSynchronizedLayer 类</li>
<li>需要在导出视频时加入 CoreAnimation，提供 AVVideoCompositionCoreAnimationTool</li>
</ul>
<p>不清楚为什么需要两个类实现同一个效果，这样做会导致在实现带有 CoreAnimation 的 layer 时，要保证 layer 的坐标与尺寸保持一致会非常麻烦。</p>
<h2 id="1-AVSynchronizedLayer-与播放"><a href="#1-AVSynchronizedLayer-与播放" class="headerlink" title="1. AVSynchronizedLayer 与播放"></a>1. AVSynchronizedLayer 与播放</h2><p>首先实现一个简单的 CALayer 来展示一段字符串组成的字幕</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> fontSize = <span class="number">32.0</span>f;</span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"GillSans-Bold"</span> size:fontSize];</span><br><span class="line"><span class="built_in">NSDictionary</span> *attrs = @&#123;<span class="built_in">NSFontAttributeName</span> : font, <span class="built_in">NSForegroundColorAttributeName</span> : (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> whiteColor].CGColor&#125;;</span><br><span class="line"><span class="built_in">NSAttributedString</span> *string = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@"hello yasic"</span> attributes:attrs];</span><br><span class="line"><span class="built_in">CGSize</span> textSize = [<span class="string">@"hello yasic"</span> sizeWithAttributes:attrs];</span><br><span class="line"><span class="built_in">CATextLayer</span> *layer = [<span class="built_in">CATextLayer</span> layer];</span><br><span class="line">layer.opacity = <span class="number">0.0</span>;</span><br><span class="line">layer.string = string;</span><br><span class="line">layer.frame = <span class="built_in">CGRectMake</span>((SCREEN_WIDTH - textSize.width)/<span class="number">2.0</span>, (SCREEN_HEIGHT - textSize.height)/<span class="number">2.0</span>, textSize.width, textSize.height);</span><br><span class="line">layer.backgroundColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br></pre></td></tr></table></figure>

<p>然后对这个 layer 加上 CoreAnimation</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CAKeyframeAnimation</span> *animation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"opacity"</span>];</span><br><span class="line">animation.values = @[@<span class="number">0.0</span>f, @<span class="number">1.0</span>f, @<span class="number">1.0</span>f, @<span class="number">0.0</span>f];</span><br><span class="line">animation.keyTimes = @[@<span class="number">0.0</span>f, @<span class="number">0.3</span>f, @<span class="number">0.7</span>f, @<span class="number">1.0</span>f];</span><br><span class="line">animation.beginTime = <span class="built_in">CMTimeGetSeconds</span>(<span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">animation.duration = <span class="number">5.0</span>f;</span><br><span class="line">animation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">[layer addAnimation:animation forKey:<span class="string">@"opacity"</span>];</span><br></pre></td></tr></table></figure>

<p>这里一定要设置起始时间，如果要表示影片片头，不能用 0.0 来赋值 beginTime，因为 CoreAnimation 会将 0.0 的 beginTime 转为 CACurrentMediaTime()，所以要用 AVCoreAnimationBeginTimeAtZero 来代替。</p>
<p>另外，需要注意要将 CoreAnimation 的 removedOnCompletion 属性设置为 NO，否则在播放过程中动画执行一次后就从图层树上移除了，之后就不会出现动画了。</p>
<p>CoreAnimation 提供了 CAAnimationGroup 来组合多个动画，但是书中建议在视频动画中避免使用 CAAnimationGroup。</p>
<p>最终将这个 layer 加入到 AVSynchronizedLayer 上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVSynchronizedLayer *syncLayer &#x3D; [AVSynchronizedLayer synchronizedLayerWithPlayerItem:self.avPlayerItem];</span><br><span class="line">[syncLayer addSublayer:[self makeTextLayer]];</span><br><span class="line">syncLayer.frame &#x3D; CGRectMake(0, 0, 1280, 720);</span><br><span class="line">[self.layer addSublayer:syncLayer];</span><br></pre></td></tr></table></figure>

<p>可以看到 AVSynchronizedLayer 是与 AVPlayerItem 绑定的，这样就能实现时间同步了。</p>
<h2 id="2-AVVideoCompositionCoreAnimationTool-与导出"><a href="#2-AVVideoCompositionCoreAnimationTool-与导出" class="headerlink" title="2. AVVideoCompositionCoreAnimationTool 与导出"></a>2. AVVideoCompositionCoreAnimationTool 与导出</h2><p>导出时也需要创建 CALayer</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *animationLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">animationLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1280.</span>f, <span class="number">720.</span>f);</span><br><span class="line"><span class="built_in">CALayer</span> *videoLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">videoLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1280.</span>f, <span class="number">720.</span>f);                            </span><br><span class="line">[animationLayer addSublayer:videoLayer];</span><br><span class="line">[animationLayer addSublayer:[<span class="keyword">self</span> makeTextLayer]];</span><br><span class="line">animationLayer.geometryFlipped = <span class="literal">YES</span>; <span class="comment">// 避免错位现象</span></span><br><span class="line"><span class="built_in">AVVideoCompositionCoreAnimationTool</span> *animationTool = [<span class="built_in">AVVideoCompositionCoreAnimationTool</span> videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer inLayer:animationLayer];</span><br></pre></td></tr></table></figure>

<p>得到 animationTool 后将其绑定到 AVMutableVideoComposition 上，即可用于导出了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoComposition</span> *finalVideocomposition = [videoComposition <span class="keyword">copy</span>];</span><br><span class="line">finalVideocomposition.animationTool = animationTool;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-混合音频</title>
    <url>/2018/04/27/AVFoundation/AVFoundation-%E6%B7%B7%E5%90%88%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<p>在组合媒体的过程中，需要用到 AVComposition 类，其中对于音频轨道可以使用与视频轨道一样的不重叠组合方式，同时音频轨道也可以重叠在一个时间段内，实现一种混音的效果，同时还可以设置不同轨道的音量变化。</p>
<h2 id="1-混音轨道"><a href="#1-混音轨道" class="headerlink" title="1. 混音轨道"></a>1. 混音轨道</h2><p>组合媒体时，分别生成了组合视频和音频的 AVMutableCompositionTrack 类，实现混音效果只需要在插入音频轨道时将时间轴直接覆盖即可。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioCompositionTrack = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *audioTracck = [[targetAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] firstObject];</span><br><span class="line">[audioCompositionTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, targetAsset.duration) ofTrack:audioTracck atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>这样生成的 AVMutableComposition 的多个音频轨道会同时发声。</p>
<h2 id="2-调节音量"><a href="#2-调节音量" class="headerlink" title="2. 调节音量"></a>2. 调节音量</h2><p>要调节某个音频轨道的音量，需要用到 AVMutableAudioMix 类，这个类接受 AVMutableAudioMixInputParameters 对象作为参数，AVMutableAudioMixInputParameters 则提供了两种方法来设置音量，对于具体音量的变化范围定义为 0.0 到 1.0 之间。</p>
<ul>
<li>一段时间内变化音量 (void)setVolumeRampFromStartVolume:(float)startVolume toEndVolume:(float)endVolume timeRange:(CMTimeRange)timeRange;</li>
<li>在某一时间点变化音量 - (void)setVolume:(float)volume atTime:(CMTime)time;</li>
</ul>
<p>其具体使用如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *audioAssetTracks = [[composition <span class="keyword">copy</span>] tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>]; <span class="comment">// 获取音轨组合</span></span><br><span class="line"><span class="built_in">AVMutableAudioMix</span> *audioMix = [<span class="built_in">AVMutableAudioMix</span> audioMix];</span><br><span class="line"><span class="built_in">NSMutableArray</span>&lt;<span class="built_in">AVMutableAudioMixInputParameters</span> *&gt; *params = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">__block <span class="built_in">CMTime</span> cursor = kCMTimeZero;</span><br><span class="line">[audioAssetTracks enumerateObjectsUsingBlock:^(<span class="built_in">AVAssetTrack</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123; <span class="comment">// 遍历音轨</span></span><br><span class="line">    <span class="built_in">AVMutableAudioMixInputParameters</span>  *parameters = [<span class="built_in">AVMutableAudioMixInputParameters</span> audioMixInputParametersWithTrack:obj]; <span class="comment">// 生成某一音轨的 AVMutableAudioMixInputParameters 对象</span></span><br><span class="line">    [parameters setVolumeRampFromStartVolume:begin toEndVolume:end timeRange:<span class="built_in">CMTimeRangeMake</span>(cursor, obj.timeRange.duration)]; <span class="comment">// 设置音量</span></span><br><span class="line">    begin = begin + end;</span><br><span class="line">    end = begin - end;</span><br><span class="line">    begin = begin - end;</span><br><span class="line">    cursor = <span class="built_in">CMTimeAdd</span>(cursor, obj.timeRange.duration);</span><br><span class="line">    [params addObject:parameters]; <span class="comment">// 加入到参数组合中</span></span><br><span class="line">&#125;];</span><br><span class="line">audioMix.inputParameters = params;<span class="comment">// 设置 audioMix 的参数组合</span></span><br></pre></td></tr></table></figure>

<p>得到 audioMix 后，可以将其赋值给 AVPlayerItem 用于播放，也可以赋值给 AVAssetExportSession 用于导出完整的媒体资源，还可以赋值给 AVAssetReaderAudioMixOutput。</p>
<p>要注意的是，对于同一音轨，设置音频轨道的时间区间不能出现重叠，否则会抛出运行时异常</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">Terminating app due <span class="keyword">to</span> uncaught exception <span class="comment">'NSInvalidArgumentException', reason: 'The timeRange of a volume ramp must not overlap the timeRange of an existing volume ramp.'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-视频过渡动画</title>
    <url>/2018/04/27/AVFoundation/AVFoundation-%E8%A7%86%E9%A2%91%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>两个独立的视频拼接起来以后很有可能会出现衔接处过于生硬的问题，此时就需要给视频添加过渡效果，这一效果需要用到 AVVideoComposition 及其子类 AVMutableVideoComposition。</p>
<p>AVMutableVideoComposition 是过渡效果实现的核心，它能够表示多个视频轨道的合并，同时表达合并的方式，也就是过渡效果，同时提供了配置视频组合的渲染尺寸、缩放、帧时长等。AVMutableVideoComposition 由一组 AVMutableVideoCompositionInstruction 组成，AVMutableVideoCompositionInstruction 定义了时间范围信息，以及每一帧的层级，也就是 AVMutableVideoCompositionLayerInstruction，AVMutableVideoCompositionLayerInstruction 用于真正实现各类模糊、变形和裁剪效果。</p>
<p>总结一下就是：</p>
<ul>
<li>AVMutableVideoCompositionLayerInstruction 负责执行具体的过渡动画</li>
<li>AVMutableVideoCompositionInstruction 负责管理过渡动画在何时执行</li>
<li>AVMutableVideoComposition 代表最终修改过的视频组合对象</li>
</ul>
<p>而 AVMutableVideoComposition 就可以被提供给 AVPlayerItem、AVAssetExportSession、AVAssetReaderVideoCompositionOutput 和 AVAssetImageGenerator 使用了，但是要注意的是，与 AVAudioMix 类似，AVMutableVideoComposition 并不能与 AVComposition 关联，这一点导致在编辑和传递 AVMutableVideoComposition 过程中，需要时时考虑附带 AVMutableVideoComposition 参数。</p>
<blockquote>
<p>AVVideoComposition 与 AVComposition 没有关系。</p>
</blockquote>
<p>实现过渡效果的基本步骤可以分为</p>
<ul>
<li>合并视频和音频，生成多视频轨道的 AVMutableComposition</li>
<li>对视频过渡区域，生成过渡动画</li>
<li>组装 AVMutableVideoComposition，提供给 AVPlayerItem 或 AVAssetExportSession 使用</li>
</ul>
<h2 id="1-合并媒体"><a href="#1-合并媒体" class="headerlink" title="1. 合并媒体"></a>1. 合并媒体</h2><p>由于 AVMutableVideoCompositionLayerInstruction 是与视频轨道绑定的，因此在处理过渡效果时，需要在不同轨道之间处理，常见的方式是交错放置多个视频，形成如下形式的视频布局</p>
<table>
<thead>
<tr>
<th>段1</th>
<th>段2</th>
<th>段3</th>
</tr>
</thead>
<tbody><tr>
<td>视频A</td>
<td></td>
<td>视频C</td>
</tr>
<tr>
<td></td>
<td>视频B</td>
<td></td>
</tr>
</tbody></table>
<p>可以用一个视频轨道数组来表达多个轨道。同时，为了实现过渡效果，两个相邻的视频，如视频 A 和 B 之间，应当在时间轴上有重叠区域，因此需要对时间轴进行如下区分</p>
<table>
<thead>
<tr>
<th>视频 A</th>
<th>AB 过渡区</th>
<th>视频 B</th>
<th>BC 过渡区</th>
<th>视频 C</th>
</tr>
</thead>
</table>
<p>这样的划分也需要记录下来，所以最终合并媒体的步骤如下</p>
<h3 id="1-1-初始化相关对象"><a href="#1-1-初始化相关对象" class="headerlink" title="1.1 初始化相关对象"></a>1.1 初始化相关对象</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *composition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line">__block <span class="built_in">CMTime</span> cursor = kCMTimeZero;</span><br><span class="line"><span class="built_in">CMTime</span> transitionTime = <span class="built_in">CMTimeMake</span>(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// 过渡时间</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *passRanges = [<span class="built_in">NSMutableArray</span> array];<span class="comment">// 视频独立区时间数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *transitionRanges = [<span class="built_in">NSMutableArray</span> array]; <span class="comment">// 过渡区时间数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *videoCompositionTrackA = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *videoCompositionTrackB = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"><span class="built_in">NSArray</span> *videoTracks = @[videoCompositionTrackA, videoCompositionTrackB]; <span class="comment">// 生成 AB 轨道</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-遍历资源"><a href="#1-2-遍历资源" class="headerlink" title="1.2 遍历资源"></a>1.2 遍历资源</h3><p>遍历资源过程中，首先需要将视频轨道和音频轨道加入到 AVMutableComposition 中，其次需要更独立区时间数组和过渡区时间数组</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视频轨道</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *videoCompositionTrack = videoTracks[idx % <span class="number">2</span>];</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoTrack = [[targetAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] firstObject];</span><br><span class="line">[videoCompositionTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, targetAsset.duration) ofTrack:videoTrack atTime:cursor error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音频轨道</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioCompositionTrack = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *audioTracck = [[targetAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] firstObject];</span><br><span class="line">[audioCompositionTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, targetAsset.duration) ofTrack:audioTracck atTime:cursor error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMTimeRange</span> timeRange = <span class="built_in">CMTimeRangeMake</span>(cursor, targetAsset.duration);</span><br><span class="line"><span class="comment">// 去除每一个视频的头部过渡区</span></span><br><span class="line"><span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123; <span class="comment">// 第一个视频只需要裁剪尾部过渡区，不需要裁剪头部过渡区</span></span><br><span class="line">    timeRange.start = <span class="built_in">CMTimeAdd</span>(timeRange.start, transitionTime);</span><br><span class="line">    timeRange.duration = <span class="built_in">CMTimeSubtract</span>(timeRange.duration, transitionTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去除每一个视频的尾部过渡区</span></span><br><span class="line"><span class="keyword">if</span> (idx + <span class="number">1</span> &lt; mediaAssets.count) &#123; <span class="comment">// 末尾视频没有尾部过渡区，其他视频还需要去除尾部过渡区</span></span><br><span class="line">    timeRange.duration = <span class="built_in">CMTimeSubtract</span>(timeRange.duration, transitionTime);</span><br><span class="line">&#125;</span><br><span class="line">[passRanges addObject:[<span class="built_in">NSValue</span> valueWithCMTimeRange:timeRange]];</span><br><span class="line"></span><br><span class="line">cursor = <span class="built_in">CMTimeAdd</span>(cursor, targetAsset.duration);</span><br><span class="line">cursor = <span class="built_in">CMTimeSubtract</span>(cursor, transitionTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (idx + <span class="number">1</span> &lt; mediaAssets.count) &#123; <span class="comment">// 末尾一个视频没有尾部过渡区</span></span><br><span class="line">    timeRange = <span class="built_in">CMTimeRangeMake</span>(cursor, transitionTime);</span><br><span class="line">    [transitionRanges addObject:[<span class="built_in">NSValue</span> valueWithCMTimeRange:timeRange]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将视频错开放入了两个视频轨道里，要注意由于视频轨道内具有 z 索引行为，因此目前是不能播放多个视频轨道的。</p>
<h2 id="2-过渡动画"><a href="#2-过渡动画" class="headerlink" title="2. 过渡动画"></a>2. 过渡动画</h2><p>现在我们有了两个视频轨道，一个表示独立区的时间数组，一个表示过渡区的时间数组，接下来需要在每一个过渡区里定义具体的过渡动画，并将所有</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *compositionInstructions = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">NSArray</span> *tracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">[passRanges enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> trackIndex = idx % <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AVMutableCompositionTrack</span> *currentTrack = tracks[trackIndex]; <span class="comment">// 取出对应轨道</span></span><br><span class="line">    <span class="built_in">AVMutableVideoCompositionInstruction</span> *instruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line">    instruction.timeRange = [obj <span class="built_in">CMTimeRangeValue</span>];<span class="comment">// 取出独立分区的 duration</span></span><br><span class="line">    <span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *layerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:currentTrack];<span class="comment">// 取出当前轨道的 layerInstruction</span></span><br><span class="line">    instruction.layerInstructions = @[layerInstruction];</span><br><span class="line">    [compositionInstructions addObject:instruction];<span class="comment">// 将 AVMutableVideoCompositionInstruction 加入到数组里</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (idx &lt; transitionRanges.count) &#123; <span class="comment">// 过渡区处理</span></span><br><span class="line">        <span class="built_in">AVCompositionTrack</span> *foregroundTrack = tracks[trackIndex];<span class="comment">//当前的track</span></span><br><span class="line">        <span class="built_in">AVCompositionTrack</span> *backgroundTrack = tracks[<span class="number">1</span> - trackIndex];<span class="comment">// 下一个 track</span></span><br><span class="line">        <span class="built_in">AVMutableVideoCompositionInstruction</span> *instruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line">        instruction.timeRange = [transitionRanges[idx] <span class="built_in">CMTimeRangeValue</span>];</span><br><span class="line">        <span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *frontLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:foregroundTrack];<span class="comment">// 取出当前轨道的 layerInstruction</span></span><br><span class="line">        <span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *backLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:backgroundTrack];<span class="comment">// 取出下一个轨道的 layerInstruction</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实际过渡动画的定义</span></span><br><span class="line">        </span><br><span class="line">        instruction.layerInstructions = @[frontLayerInstruction, backLayerInstruction];</span><br><span class="line">        [compositionInstructions addObject:instruction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>要注意，compositionInstructions 数组必须按顺序组装 AVMutableVideoCompositionInstruction 对象。</p>
<p>AVMutableVideoCompositionLayerInstruction 本身支持三种过渡动画效果</p>
<ul>
<li>opacity 透明度变化、溶解效果</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[frontLayerInstruction setOpacityRampFromStartOpacity:<span class="number">1.0</span> toEndOpacity:<span class="number">0.0</span> timeRange:[transitionRanges[idx] <span class="built_in">CMTimeRangeValue</span>]];</span><br><span class="line">[backLayerInstruction setOpacityRampFromStartOpacity:<span class="number">0.0</span> toEndOpacity:<span class="number">1.0</span> timeRange:[transitionRanges[idx] <span class="built_in">CMTimeRangeValue</span>]];</span><br></pre></td></tr></table></figure>

<ul>
<li>Transform 矩阵变换、推入效果</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGAffineTransform</span> identityTransform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> videoWidth = <span class="number">1280.</span>f;</span><br><span class="line"><span class="built_in">CGAffineTransform</span> from = <span class="built_in">CGAffineTransformMakeTranslation</span>(-videoWidth, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">CGAffineTransform</span> to = <span class="built_in">CGAffineTransformMakeTranslation</span>(videoWidth, <span class="number">0.0</span>);</span><br><span class="line">[frontLayerInstruction setTransformRampFromStartTransform:identityTransform toEndTransform:from timeRange:[transitionRanges[idx] <span class="built_in">CMTimeRangeValue</span>]];</span><br><span class="line">[backLayerInstruction setTransformRampFromStartTransform:to toEndTransform:identityTransform timeRange:[transitionRanges[idx] <span class="built_in">CMTimeRangeValue</span>]];</span><br></pre></td></tr></table></figure>

<ul>
<li>CropRectangle 裁剪区域、擦除效果</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> videoWidth = <span class="number">1280.</span>f;</span><br><span class="line"><span class="built_in">CGFloat</span> videoHeight = <span class="number">720.</span>f;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGRect</span> startRect = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, videoWidth, videoHeight);</span><br><span class="line"><span class="built_in">CGRect</span> endRect = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, videoWidth, <span class="number">0.0</span>f);</span><br><span class="line"></span><br><span class="line">[frontLayerInstruction setCropRectangleRampFromStartCropRectangle:startRect toEndCropRectangle:endRect timeRange:[transitionRanges[idx] <span class="built_in">CMTimeRangeValue</span>]];</span><br></pre></td></tr></table></figure>

<h2 id="组装媒体"><a href="#组装媒体" class="headerlink" title="组装媒体"></a>组装媒体</h2><p>获得了装有 AVMutableVideoCompositionInstruction 的 compositionInstructions 数组后，就可以组装 AVMutableVideoComposition 了</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoComposition</span> *videoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoComposition];</span><br><span class="line">videoComposition.instructions = [compositionInstructions <span class="keyword">copy</span>];</span><br><span class="line">videoComposition.renderSize = <span class="built_in">CGSizeMake</span>(<span class="number">1280.</span>f, <span class="number">720.</span>f);</span><br><span class="line">videoComposition.frameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">30</span>);</span><br><span class="line">videoComposition.renderScale = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure>

<p>这里定义了四个主要属性</p>
<ul>
<li>instructions 属性用于设置所有组合指令，也就是 AVMutableVideoCompositionInstruction</li>
<li>renderSize 定义渲染尺寸</li>
<li>frameDuration 定义有效帧率，30 FPS 的帧率对应 frameDuration 为 1/30</li>
<li>renderScale 定义视频组合的缩放值</li>
</ul>
<p>当然还可以用快捷方式来获取一个 AVMutableVideoComposition</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoComposition</span> *videoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoCompositionWithPropertiesOfAsset:composition];</span><br></pre></td></tr></table></figure>

<p>这个方法所配置的属性如下所示</p>
<ul>
<li>instructions 属性包含一组完整的基于组合视频轨道的组合和层指令</li>
<li>renderSize 被设置为 AVComposition 的 naturalSize，如果没有，则设置为能够满足最大视频维度的尺寸值</li>
<li>frameDuration 设置为组合视频轨道的最大 nominalFrameRate 的值，如果都为 0 则设置为 1/30</li>
<li>renderScale 设置为 1.0</li>
</ul>
<p>生成了 AVMutableVideoComposition 以后就可以直接用于播放或导出了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVPlayerItem</span> *item = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:[composition <span class="keyword">copy</span>]];</span><br><span class="line">item.videoComposition = videoComposition;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-媒体的组合和编辑</title>
    <url>/2018/04/26/AVFoundation/AVFoundation-%E5%AA%92%E4%BD%93%E7%9A%84%E7%BB%84%E5%90%88%E5%92%8C%E7%BC%96%E8%BE%91/</url>
    <content><![CDATA[<p>AVFoundation 能支持非线性、无损的编辑工具，并且可以在原始媒体资源不破坏的情况下无约束地编辑。</p>
<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p>AVFoundation 有关资源组合的功能均需要用到 AVComposition 类，这个类将其他几种媒体资源组合成一个临时的排列，这个临时排列可以像 AVAsset 一样使用。一个 AVComposition 中的轨道都是 AVCompositionTrack，而 AVCompositionTrack 又由多个 AVCompositionTrackSegment 组成，代表这个组合中的实际媒体区域。AVComposition 及其相关类没有遵循 NSCoding 协议，因此不能将其简单归档到存储磁盘里，需要自定义数据模型来保存。</p>
<h3 id="1-1-时间的处理"><a href="#1-1-时间的处理" class="headerlink" title="1.1 时间的处理"></a>1.1 时间的处理</h3><p>为了避免浮点数的不精确性导致的误差，AVFoundation 普遍使用 CMTime 数据类型来表达时间格式。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="built_in">CMTimeValue</span>	value;</span><br><span class="line">	<span class="built_in">CMTimeScale</span>	timescale;</span><br><span class="line">	<span class="built_in">CMTimeFlags</span>	flags;<span class="comment">// 表示时间状态，如是否有效、是否有舍入值</span></span><br><span class="line">	<span class="built_in">CMTimeEpoch</span>	epoch;</span><br><span class="line">&#125; <span class="built_in">CMTime</span>;</span><br></pre></td></tr></table></figure>

<p>另外使用 CMTimeRange 来表达时间范围</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="built_in">CMTime</span>			start;</span><br><span class="line">	<span class="built_in">CMTime</span>			duration;</span><br><span class="line">&#125; <span class="built_in">CMTimeRange</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一些常用方法</p>
<ul>
<li>CMTimeMake 创造一个 CMTime</li>
<li>CMTimeShow 打印 CMTime 值</li>
<li>CMTimeAdd 两个 CMTime 相加</li>
<li>CMTimeSubtract 两个 CMTime 相减</li>
<li>CMTimeRangeMake 创造一个 CMTimeRange</li>
<li>CMTimeRangeFromTimeToTime 以两个时间点创造 CMTimeRange</li>
<li>CMTimeRangeGetIntersection 获得两个 CMTimeRange 的交集</li>
<li>CMTimeRangeGetUnion 获得两个 CMTImeRange 的并集</li>
</ul>
<h2 id="2-组合媒体"><a href="#2-组合媒体" class="headerlink" title="2. 组合媒体"></a>2. 组合媒体</h2><p>组合媒体资源时要注意对一个 AVAsset 的 videoTrack 和 audioTrack 分别进行组合。首先需要初始化一个 AVMutableComposition，还需要初始化两个 AVMutableCompositionTrack，一个用于附加 video，一个用于附加 audio。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *composition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line">__block <span class="built_in">CMTime</span> cursor = kCMTimeZero;<span class="comment">// 标识当前附加资源的时间轴位置</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *videoCompositionTrack = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];<span class="comment">// kCMPersistentTrackID_Invalid 表示 AVFoundation 应该自动生成一个正确的轨道 ID</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioCompositionTrack = [composition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br></pre></td></tr></table></figure>

<p>对于每一个 AVAsset，需要取出其中的 videoTrack 和 audioTrack，分别加入到对应的 AVMutableCompositionTrack 中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVAssetTrack</span> *videoTrack = [[targetAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] firstObject];</span><br><span class="line">[videoCompositionTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, targetAsset.duration) ofTrack:videoTrack atTime:cursor error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *audioTracck = [[targetAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] firstObject];</span><br><span class="line">[audioCompositionTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, targetAsset.duration) ofTrack:audioTracck atTime:cursor error:<span class="literal">nil</span>];</span><br><span class="line">cursor = <span class="built_in">CMTimeAdd</span>(cursor, targetAsset.duration); <span class="comment">// 移动当前媒体资源附加位置</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了一个临时排列 AVMutableComposition，可以将其直接用于播放。</p>
<h2 id="3-导出媒体"><a href="#3-导出媒体" class="headerlink" title="3. 导出媒体"></a>3. 导出媒体</h2><p>AVMutableComposition 可以在内存中进行使用，但是如果想持久化到磁盘中，就需要进行导出，导出后的媒体资源是一个完整的独立资源。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSString</span> *preset = <span class="built_in">AVAssetExportPresetHighestQuality</span>;</span><br><span class="line">	<span class="built_in">AVAssetExportSession</span> *<span class="keyword">export</span> = [<span class="built_in">AVAssetExportSession</span> exportSessionWithAsset:[composition <span class="keyword">copy</span>] presetName:preset];</span><br><span class="line">	<span class="keyword">export</span>.outputURL = [<span class="keyword">self</span> outputUrl];</span><br><span class="line">	<span class="keyword">export</span>.outputFileType = <span class="built_in">AVFileTypeMPEG4</span>;</span><br><span class="line">	[<span class="keyword">export</span> exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">		<span class="built_in">AVAssetExportSessionStatus</span> status = <span class="keyword">export</span>.status;</span><br><span class="line">		<span class="keyword">if</span> (status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) &#123;</span><br><span class="line">			[<span class="keyword">self</span> saveVideo:<span class="keyword">export</span>.outputURL];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line">                            </span><br><span class="line">- (<span class="built_in">NSURL</span> *)outputUrl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        filePath = <span class="built_in">NSTemporaryDirectory</span>();</span><br><span class="line">        <span class="built_in">NSString</span> *numberString = count &gt; <span class="number">0</span> ?</span><br><span class="line">        [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"-%li"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) count] : <span class="string">@""</span>;</span><br><span class="line">        <span class="built_in">NSString</span> *fileNameString =</span><br><span class="line">        [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Masterpiece-%@.m4v"</span>, numberString];</span><br><span class="line">        filePath = [filePath stringByAppendingPathComponent:fileNameString];</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">while</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:filePath]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终在导出结束后，通过导出 URL 可以将目标视频保存到系统相册里。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *imageIdentifier;</span><br><span class="line">@weakify(<span class="keyword">self</span>)</span><br><span class="line">[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;</span><br><span class="line">    PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromVideoAtFileURL:videoURL];</span><br><span class="line">    imageIdentifier = changeRequest.placeholderForCreatedAsset.localIdentifier;</span><br><span class="line">&#125; completionHandler:^( <span class="built_in">BOOL</span> success, <span class="built_in">NSError</span> * _Nullable error ) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [MTBProgressHUD dismiss];</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-读取和写入媒体</title>
    <url>/2018/04/26/AVFoundation/AVFoundation-%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E5%AA%92%E4%BD%93/</url>
    <content><![CDATA[<h2 id="1-综述"><a href="#1-综述" class="headerlink" title="1. 综述"></a>1. 综述</h2><p>AVFoundation 提供了对底层数据的读写功能，需要用到 AVAssetReader 和 AVAssetWriter 两个核心类。</p>
<p>AVAssetReader 用于从 AVAsset 实例读取媒体样本，需要配置一个或多个 AVAssetReaderOutput 实例。</p>
<p>AVAssetReaderOutput 是一个抽象类，下分三个具体类，负责读取指定 AVAssetTrack 的AVAssetReaderTrackOutput，负责读取多音频轨道的 AVAssetReaderAudioMixOutput，负责读取多媒体轨道的 AVAssetReaderVideoCompositionOutput。其内部通道以多线程方式读取下一个可用样本，从而降低请求资源的延时。但仍然不推荐用 AVAssetReaderOutput 实现包括播放在内的实时操作。</p>
<p>AVAssetWriter 用于对媒体资源进行编码和写入，需要配置一个或多个 AVAssetWriterInput 实例，一个 AVAssetWriterInput 负责一种媒体类型，最终生成独立的 AVAssetTrack。同时还需要用到 AVAssetWriterInputPixelBufferAdaptor 为视频样本提供最优性能。</p>
<p>下面是一个简单的使用示例</p>
<ul>
<li>进行媒体资源读取准备</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVURLAsset</span> *asset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:videoURL options:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoTrack = [[asset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] firstObject]; <span class="comment">// 获取 video 类型的媒体轨道</span></span><br><span class="line"><span class="keyword">self</span>.assetReader = [[<span class="built_in">AVAssetReader</span> alloc] initWithAsset:asset error:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *readerOutputSettings = @&#123;(<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey:@(kCVPixelFormatType_32BGRA)&#125;; <span class="comment">// 将视频帧解压缩为 32 位 BGRA 格式</span></span><br><span class="line"><span class="built_in">AVAssetReaderTrackOutput</span> *trackout = [[<span class="built_in">AVAssetReaderTrackOutput</span> alloc] initWithTrack:videoTrack outputSettings:readerOutputSettings];</span><br><span class="line">[<span class="keyword">self</span>.assetReader addOutput:trackout];</span><br><span class="line">[<span class="keyword">self</span>.assetReader startReading];<span class="comment">// 做好从 AVAsset 读取样本的准备，如果返回 NO 则表明出错了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进行媒体资源写入准备</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.assetWriter &#x3D; [[AVAssetWriter alloc] initWithURL:[self outputURL] fileType:AVFileTypeQuickTimeMovie error:nil]; &#x2F;&#x2F; 指定待写入的 URL 和 媒体类型</span><br><span class="line">NSDictionary *writeOutputSettings &#x3D; @&#123;AVVideoCodecKey:AVVideoCodecH264, &#x2F;&#x2F; 视频格式</span><br><span class="line">                                      AVVideoWidthKey:@1280,</span><br><span class="line">                                      AVVideoHeightKey:@720,</span><br><span class="line">                                      AVVideoCompressionPropertiesKey:@&#123; &#x2F;&#x2F; 硬编码参数</span><br><span class="line">                                              AVVideoAverageBitRateKey:@10500000,</span><br><span class="line">                                              AVVideoProfileLevelKey:AVVideoProfileLevelH264Main31</span><br><span class="line">                                              &#125;</span><br><span class="line">                                      &#125;;</span><br><span class="line">AVAssetWriterInput *writerInput &#x3D; [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:writeOutputSettings];</span><br><span class="line">[self.assetWriter addInput:writerInput];</span><br><span class="line">[self.assetWriter startWriting]; &#x2F;&#x2F; 做好写入准备</span><br></pre></td></tr></table></figure>

<ul>
<li>以拉模式写入</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"writer"</span>, <span class="literal">NULL</span>); <span class="comment">// 在串行队列上写入</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero]; <span class="comment">// 从视频起始位置开始写入会话</span></span><br><span class="line">[writerInput requestMediaDataWhenReadyOnQueue:queue usingBlock:^&#123; <span class="comment">// 准备写入更多样本时调用 block</span></span><br><span class="line">    <span class="built_in">BOOL</span> complete = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span> ([writerInput isReadyForMoreMediaData] &amp;&amp; !complete) &#123;</span><br><span class="line">        <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [trackout copyNextSampleBuffer]; <span class="comment">// 从读取器读取更多样本</span></span><br><span class="line">        <span class="keyword">if</span> (sampleBuffer) &#123;</span><br><span class="line">            <span class="built_in">BOOL</span> result = [writerInput appendSampleBuffer:sampleBuffer]; <span class="comment">// 将样本附加到写入器通道</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">            complete = !result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [writerInput markAsFinished]; <span class="comment">// 标记写入完成</span></span><br><span class="line">            complete = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (complete) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.assetWriter finishWritingWithCompletionHandler:^&#123; <span class="comment">// 完成写入</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriter.status == <span class="built_in">AVAssetWriterStatusCompleted</span>) &#123; <span class="comment">// 判断是否写入成功</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"complete"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"fail"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="2-创建音频波形视图"><a href="#2-创建音频波形视图" class="headerlink" title="2. 创建音频波形视图"></a>2. 创建音频波形视图</h2><p>音频波形视图即提供图像化显示的音频波形，方便用户查看和编辑音频轨道。其主要步骤包括</p>
<ul>
<li>读取：解压读取音频数据</li>
<li>采样：实际读取到的样本数量巨大，需要进行采样，在每一个样本块上取 min、max 或者 average 值</li>
<li>渲染：在 UI 界面上渲染得到的采样值（与 AVFoundation 无关）</li>
</ul>
<h3 id="2-1-读取音频样本"><a href="#2-1-读取音频样本" class="headerlink" title="2.1 读取音频样本"></a>2.1 读取音频样本</h3><p>首先是对读取器和读取通道的初始化</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">AVAssetReader</span> *assetReader = [[<span class="built_in">AVAssetReader</span> alloc] initWithAsset:asset error:&amp;error]; <span class="comment">// 配置 AVAssetReader</span></span><br><span class="line">  <span class="keyword">if</span> (!assetReader) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"Error creating asset reader: %@"</span>, [error localizedDescription]);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">AVAssetTrack</span> *track = [[asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] firstObject]; <span class="comment">// 配置音频轨道</span></span><br><span class="line">  <span class="built_in">NSDictionary</span> *outputSettings = @&#123;</span><br><span class="line">      <span class="built_in">AVFormatIDKey</span>               : @(kAudioFormatLinearPCM), <span class="comment">// 读取格式为 PCM，一种未压缩的音频样本格式</span></span><br><span class="line">      <span class="built_in">AVLinearPCMIsBigEndianKey</span>   : @NO, <span class="comment">// 小端字节顺序</span></span><br><span class="line"><span class="built_in">AVLinearPCMIsFloatKey</span>		: @NO, <span class="comment">// 有符号整型</span></span><br><span class="line"><span class="built_in">AVLinearPCMBitDepthKey</span>		: @(<span class="number">16</span>) <span class="comment">// 位元深度 16 位</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">AVAssetReaderTrackOutput</span> *trackOutput = [[<span class="built_in">AVAssetReaderTrackOutput</span> alloc] initWithTrack:track outputSettings:outputSettings];</span><br><span class="line">  [assetReader addOutput:trackOutput];</span><br><span class="line">  [assetReader startReading];</span><br></pre></td></tr></table></figure>

<p>然后循环读取样本值并转移</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableData</span> *sampleData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line"><span class="keyword">while</span> (assetReader.status == <span class="built_in">AVAssetReaderStatusReading</span>) &#123; <span class="comment">// 持续读取样本</span></span><br><span class="line">    <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [trackOutput copyNextSampleBuffer]; <span class="comment">// 读取一个音频样本</span></span><br><span class="line">    <span class="keyword">if</span> (sampleBuffer) &#123;</span><br><span class="line">        <span class="built_in">CMBlockBufferRef</span> blockBufferRef = <span class="built_in">CMSampleBufferGetDataBuffer</span>(sampleBuffer); <span class="comment">// 获取其对应的不保留引用的 block buffer</span></span><br><span class="line">        size_t length = <span class="built_in">CMBlockBufferGetDataLength</span>(blockBufferRef); <span class="comment">// 获取样本长度</span></span><br><span class="line">        SInt16 sampleBytes[length];</span><br><span class="line">        <span class="built_in">CMBlockBufferCopyDataBytes</span>(blockBufferRef, <span class="number">0</span>, length, sampleBytes); <span class="comment">// 转移样本内的数据到一个空数组</span></span><br><span class="line">        [sampleData appendBytes:sampleBytes length:length]; <span class="comment">// 添加数组到 NSMutableData 中</span></span><br><span class="line">        <span class="built_in">CMSampleBufferInvalidate</span>(sampleBuffer);</span><br><span class="line">        <span class="built_in">CFRelease</span>(sampleBuffer);<span class="comment">// 回收样本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-采样音频样本"><a href="#2-2-采样音频样本" class="headerlink" title="2.2 采样音频样本"></a>2.2 采样音频样本</h3><p>屏幕空间有限，而读取的音频样本非常庞大，因此需要进行采样。基本思路是将样本按照一定距离进行分割，在分割出的一个独立”箱”中找到最大样本。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)filteredSamplesForSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *filteredSamples = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSUInteger</span> sampleCount = <span class="keyword">self</span>.sampleData.length / <span class="keyword">sizeof</span>(SInt16); <span class="comment">// 获取样本个数，样本格式是 SInt16，总长度除以单个数据长度</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> binSize = sampleCount / size.width; <span class="comment">// 获取一个样本箱的大小</span></span><br><span class="line"></span><br><span class="line">    SInt16 *bytes = (SInt16 *) <span class="keyword">self</span>.sampleData.bytes; <span class="comment">// 获取样本的基地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; sampleCount; i += binSize) &#123; <span class="comment">// 遍历样本箱</span></span><br><span class="line">        SInt16 sampleBin[binSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; binSize; j++) &#123; <span class="comment">// 遍历箱内样本</span></span><br><span class="line">			sampleBin[j] = <span class="built_in">CFSwapInt16LittleToHost</span>(bytes[i + j]); <span class="comment">// 由于是按照小端顺序读取，需要通过 CFSwapInt16LittleToHost 方法转换为主机的本地字节顺序</span></span><br><span class="line">        &#125;</span><br><span class="line">        SInt16 value = [<span class="keyword">self</span> maxValueInArray:sampleBin ofSize:binSize]; <span class="comment">// 取出样本箱中最大值</span></span><br><span class="line">        [filteredSamples addObject:@(value)]; <span class="comment">// 添加到采样数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filteredSamples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-捕捉录制的高级方法"><a href="#3-捕捉录制的高级方法" class="headerlink" title="3. 捕捉录制的高级方法"></a>3. 捕捉录制的高级方法</h2><p>AVCaptureVideoDataOutput 无法像 AVCaptureMovieFileOutput 一样便捷地记录输出，它需要用到 AVAssetWriter 方法，但是另一方面可以对每一帧数据进行实时处理，因此更为灵活和强大。使用 AVCaptureVideoDataOutput 记录媒体资源需要注意以下几个地方</p>
<ul>
<li>初始化过程</li>
<li>实时渲染预览页面</li>
<li>记录媒体输出</li>
</ul>
<h3 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h3><p>初始化 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.videoDataOutput = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line"><span class="built_in">NSDictionary</span> *outputSettings = @&#123;(<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;; <span class="comment">// 设置输出为 32 位 BGRA 格式</span></span><br><span class="line"><span class="keyword">self</span>.videoDataOutput.videoSettings = outputSettings;</span><br><span class="line"><span class="keyword">self</span>.videoDataOutput.alwaysDiscardsLateVideoFrames = <span class="literal">NO</span>; <span class="comment">// 默认为 YES，会立即丢弃在 captureOutput：didOutputSampleBuffer：fromConnection：delegate 方法中阻止处理当前捕获帧的帧，设置为 NO 可以给委托方法额外时间处理样本，但是会带来性能上的损耗</span></span><br><span class="line">[<span class="keyword">self</span>.videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:<span class="keyword">self</span>.dispatchQueue]; <span class="comment">// 将委托回调加入到串行队列中</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.videoDataOutput]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.videoDataOutput];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.audioDataOutput = [[<span class="built_in">AVCaptureAudioDataOutput</span> alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.audioDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:<span class="keyword">self</span>.dispatchQueue];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.audioDataOutput]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.audioDataOutput];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-实时渲染预览页面"><a href="#3-2-实时渲染预览页面" class="headerlink" title="3.2 实时渲染预览页面"></a>3.2 实时渲染预览页面</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer</span><br><span class="line">       fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line">    <span class="keyword">if</span> (captureOutput == <span class="keyword">self</span>.videoDataOutput) &#123; <span class="comment">// 判断是 video 通道</span></span><br><span class="line">        CVPixelBufferRef imageBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer); <span class="comment">// 取出像素帧</span></span><br><span class="line">        <span class="built_in">CIImage</span> *sourceImage = [<span class="built_in">CIImage</span> imageWithCVPixelBuffer:imageBuffer options:<span class="literal">nil</span>]; <span class="comment">// 生成预览的 UIImage</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然实际上很多时候我们需要对预览加上滤镜效果，此时可以用 CIFilter 实现，首先通过 name 获取一系列的 CIFilter</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)filterNames &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"CIPhotoEffectChrome"</span>,</span><br><span class="line">             <span class="string">@"CIPhotoEffectFade"</span>,</span><br><span class="line">             <span class="string">@"CIPhotoEffectInstant"</span>,</span><br><span class="line">             <span class="string">@"CIPhotoEffectMono"</span>,</span><br><span class="line">             <span class="string">@"CIPhotoEffectNoir"</span>,</span><br><span class="line">             <span class="string">@"CIPhotoEffectProcess"</span>,</span><br><span class="line">             <span class="string">@"CIPhotoEffectTonal"</span>,</span><br><span class="line">             <span class="string">@"CIPhotoEffectTransfer"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CIFilter</span> *)filterForDisplayName:(<span class="built_in">NSString</span> *)displayName &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *name <span class="keyword">in</span> [<span class="keyword">self</span> filterNames]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([name containsString:displayName]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">CIFilter</span> filterWithName:name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对 UIImage 对象使用 CIFilter</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.filter setValue:sourceImage forKey:kCIInputImageKey];</span><br><span class="line"><span class="built_in">CIImage</span> *filteredImage = <span class="keyword">self</span>.filter.outputImage;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-记录媒体输出"><a href="#3-3-记录媒体输出" class="headerlink" title="3.3 记录媒体输出"></a>3.3 记录媒体输出</h3><p>记录输出前首先要对 videoInput 和 audioInput 进行初始化</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">      <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">      <span class="built_in">NSString</span> *fileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line">      <span class="keyword">self</span>.assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:[<span class="keyword">self</span> outputURL] fileType:fileType error:&amp;error]; <span class="comment">// 初始化 writer</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">self</span>.assetWriter || error) &#123;</span><br><span class="line">          <span class="built_in">NSString</span> *formatString = <span class="string">@"Could not create AVAssetWriter: %@"</span>;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:formatString, error]);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">self</span>.assetWriterVideoInput = [[<span class="built_in">AVAssetWriterInput</span> alloc] initWithMediaType:<span class="built_in">AVMediaTypeVideo</span> outputSettings:<span class="keyword">self</span>.videoSettings];</span><br><span class="line">      <span class="keyword">self</span>.assetWriterVideoInput.expectsMediaDataInRealTime = <span class="literal">YES</span>; <span class="comment">// 指明输入应该针对实时性进行优化</span></span><br><span class="line">      </span><br><span class="line">      <span class="built_in">UIDeviceOrientation</span> orientation = [<span class="built_in">UIDevice</span> currentDevice].orientation;</span><br><span class="line"><span class="keyword">self</span>.assetWriterVideoInput.transform = THTransformForDeviceOrientation(orientation); <span class="comment">// 修复 orientation</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *attributes = @&#123;</span><br><span class="line">	(<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA), <span class="comment">// 与 AVCaptureVideoDataOutput 使用的像素格式一致能够保证最大效率</span></span><br><span class="line">	(<span class="keyword">id</span>)kCVPixelBufferWidthKey : <span class="keyword">self</span>.videoSettings[<span class="built_in">AVVideoWidthKey</span>],</span><br><span class="line">	(<span class="keyword">id</span>)kCVPixelBufferHeightKey : <span class="keyword">self</span>.videoSettings[<span class="built_in">AVVideoHeightKey</span>],</span><br><span class="line">	(<span class="keyword">id</span>)kCVPixelFormatOpenGLESCompatibility : (<span class="keyword">id</span>)kCFBooleanTrue</span><br><span class="line">&#125;;</span><br><span class="line">      <span class="keyword">self</span>.assetWriterInputPixelBufferAdaptor = [[<span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> alloc] initWithAssetWriterInput:<span class="keyword">self</span>.assetWriterVideoInput sourcePixelBufferAttributes:attributes]; <span class="comment">//AVAssetWriterInputPixelBufferAdaptor 提供一个优化的 pixelBufferPool</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.assetWriter canAddInput:<span class="keyword">self</span>.assetWriterVideoInput]) &#123;</span><br><span class="line">	[<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterVideoInput];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Unable to add video input."</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">self</span>.assetWriterAudioInput = [[<span class="built_in">AVAssetWriterInput</span> alloc] initWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:<span class="keyword">self</span>.audioSettings];</span><br><span class="line">      <span class="keyword">self</span>.assetWriterAudioInput.expectsMediaDataInRealTime = <span class="literal">YES</span>;</span><br><span class="line">      <span class="keyword">if</span> ([<span class="keyword">self</span>.assetWriter canAddInput:<span class="keyword">self</span>.assetWriterAudioInput]) &#123;</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterAudioInput];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"Unable to add audio input."</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意，对于初始化 AVAssetWriterInput 和 AVAssetWriterInput 时需要用到的 settings 值，iOS 7 提供了一些便捷方法来获取</p>
<ul>
<li>recommendedVideoSettingsForAssetWriterWithOutputFileType 获取指定类型的视频设置</li>
<li>recommendedAudioSettingsForAssetWriterWithOutputFileType 获取指定类型的音频设置</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.isWriting) &#123; <span class="comment">// 检测是否正在记录</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> formatDesc = <span class="built_in">CMSampleBufferGetFormatDescription</span>(sampleBuffer); <span class="comment">// 获取当前帧的描述信息</span></span><br><span class="line"><span class="built_in">CMMediaType</span> mediaType = <span class="built_in">CMFormatDescriptionGetMediaType</span>(formatDesc); <span class="comment">// 获取媒体类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mediaType == kCMMediaType_Video) &#123;</span><br><span class="line">    <span class="built_in">CMTime</span> timestamp = <span class="built_in">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer); <span class="comment">// 获取时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.firstSample) &#123; <span class="comment">// 如果是第一帧，则进行写入启动操作</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.assetWriter startWriting]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:timestamp]; <span class="comment">// 在当前时间戳启动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Failed to start writing."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.firstSample = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CVPixelBufferRef outputRenderBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    CVPixelBufferPoolRef pixelBufferPool = <span class="keyword">self</span>.assetWriterInputPixelBufferAdaptor.pixelBufferPool; <span class="comment">// 获取到 adaptor 的 pixelBufferPool</span></span><br><span class="line">    OSStatus err = CVPixelBufferPoolCreatePixelBuffer(<span class="literal">NULL</span>, pixelBufferPool, &amp;outputRenderBuffer); <span class="comment">// 创建一个空的 CVPixelBufferRef，使用该 buffer 渲染筛选好的视频帧</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Unable to obtain a pixel buffer from the pool."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CVPixelBufferRef imageBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer); <span class="comment">// 获取当前样本的像素帧</span></span><br><span class="line">    <span class="built_in">CIImage</span> *sourceImage = [<span class="built_in">CIImage</span> imageWithCVPixelBuffer:imageBuffer options:<span class="literal">nil</span>]; <span class="comment">// 生成 CIImage</span></span><br><span class="line">    [<span class="keyword">self</span>.activeFilter setValue:sourceImage forKey:kCIInputImageKey]; <span class="comment">// 滤镜配置</span></span><br><span class="line">    <span class="built_in">CIImage</span> *filteredImage = <span class="keyword">self</span>.activeFilter.outputImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filteredImage) &#123;</span><br><span class="line">        filteredImage = sourceImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.ciContext render:filteredImage toCVPixelBuffer:outputRenderBuffer bounds:filteredImage.extent colorSpace:<span class="keyword">self</span>.colorSpace]; <span class="comment">// 将 CIImage 渲染到空的 CVPixelBufferRef 中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput.readyForMoreMediaData) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.assetWriterInputPixelBufferAdaptor appendPixelBuffer:outputRenderBuffer withPresentationTime:timestamp]) &#123; <span class="comment">// 写入到 adaptor 中，完成对视频帧的处理</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Error appending pixel buffer."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CVPixelBufferRelease(outputRenderBuffer); <span class="comment">// 回收被渲染的帧</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">self</span>.firstSample &amp;&amp; mediaType == kCMMediaType_Audio) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput.isReadyForMoreMediaData) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.assetWriterAudioInput appendSampleBuffer:sampleBuffer]) &#123; <span class="comment">// 音频样本直接写入</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Error appending audio sample buffer."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的操作已经在注释中写明了，此处不再过多说明。最终结束写入操作时，仍然需要调用 finishWritingWithCompletionHandler 方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.assetWriter finishWritingWithCompletionHandler:^&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriter.status == <span class="built_in">AVAssetWriterStatusCompleted</span>) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *fileURL = [<span class="keyword">self</span>.assetWriter outputURL]; <span class="comment">// 拿到 url 后进行相册保存操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Failed to write movie: %@"</span>, <span class="keyword">self</span>.assetWriter.error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation资源和元数据</title>
    <url>/2018/04/26/AVFoundation/AVFoundation%E8%B5%84%E6%BA%90%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>AVAsset 是一个抽象类和不可变类，它定义了媒体资源混合呈现的方式，将媒体资源的静态属性模块化为一个整体，包括标题、时长和元数据。AVAsset 提供了基本媒体格式的层抽象，隐藏了资源的位置信息。</p>
<h2 id="1-创建资源"><a href="#1-创建资源" class="headerlink" title="1. 创建资源"></a>1. 创建资源</h2><p>通过 URL 创建一个 AVAsset</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *assetUrl = <span class="comment">// url</span></span><br><span class="line"><span class="built_in">AVAsset</span> *asset  =[<span class="built_in">AVAsset</span> assetWithURL:assetUrl];</span><br></pre></td></tr></table></figure>

<p>assetWithURL 方法生成的实际类是 AVAsset 的子类 AVURLAsset，它允许通过 options 字典来调整创建方式。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>常见的获取 AVAsset 的途径有</p>
<ul>
<li>iOS Asset 库，即相册资源 —— Photo Framework</li>
<li>iOS iPod 库 —— MediaPlayer</li>
<li>MAC iTunes 库 —— iTunesLibrary 框架</li>
</ul>
<p>这里只举 Photo Framework 的例子</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[PHImageManager defaultManager] requestAVAssetForVideo:asset options:options resultHandler:^(<span class="built_in">AVAsset</span> * _Nullable obj, <span class="built_in">AVAudioMix</span> * _Nullable audioMix, <span class="built_in">NSDictionary</span> * _Nullable info) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>)</span><br><span class="line">    <span class="built_in">AVURLAsset</span> *urlAsset = (<span class="built_in">AVURLAsset</span> *)obj;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = urlAsset.URL;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="2-异步加载"><a href="#2-异步加载" class="headerlink" title="2. 异步加载"></a>2. 异步加载</h2><p>AVAsset 对资源属性实现了延迟加载特性，仅在请求时才载入，这样如果是同步请求属性，就可能因为属性没有预先载入而阻塞主线程，因此应采用异步加载属性的方法。</p>
<p>AVAsset 和 AVAssetTrack 都遵循了 AVAsynchronousKeyValueLoading 协议，此协议有两个方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">AVKeyValueStatus</span>)statusOfValueForKey:(<span class="built_in">NSString</span> *)key error:(<span class="built_in">NSError</span> * _Nullable * _Nullable)outError;</span><br><span class="line">- (<span class="keyword">void</span>)loadValuesAsynchronouslyForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))handler;</span><br></pre></td></tr></table></figure>

<p>第一个方法用于确定当前属性是预先加载好了、尚未加载还是加载出错了，而第二个方法则是异步加载属性的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.targetAVAsset loadValuesAsynchronouslyForKeys:@[<span class="string">@"trackss"</span>] completionHandler:^&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVKeyValueStatus</span> status = [<span class="keyword">self</span>.targetAVAsset statusOfValueForKey:<span class="string">@"tracks"</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AVKeyValueStatusLoaded"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AVKeyValueStatusFailed"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusUnknown</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AVKeyValueStatusUnknown"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AVKeyValueStatusCancelled"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>这里请求的参数可以是多个，但是当请求多个参数时，异步请求的回调只会调用一次，此时需要分别对各个属性调用 statusOfValueForKey 方法来判断是否加载完成。</p>
<h2 id="3-媒体元数据"><a href="#3-媒体元数据" class="headerlink" title="3. 媒体元数据"></a>3. 媒体元数据</h2><h3 id="3-1-元数据格式"><a href="#3-1-元数据格式" class="headerlink" title="3.1 元数据格式"></a>3.1 元数据格式</h3><p>在 Apple 环境下，最常见四种媒体类型，分别是 QuickTime（mov）、MPEG-4 video（mp4 和 m4v）、MPEG-4 audio（m4a）和 MPEG-Layer III Audio（mp3）。</p>
<p>QuickTime 是苹果公司开发的一种跨平台媒体架构，由一种称为 atoms 的数据结构组成，一个 atom 可以包含元数据，也可以包含其他 atom，但不能两者都包含。</p>
<p>MPEG-4 Part 14 定义了 MP4 文件格式的规范，MP4 直接派生于 QuickTime 文件格式，结构类似。要注意，MP4 有多种文件拓展名。.mp4 是标准扩展名，.m4v 是带有苹果公司针对 FairPlay 加密及 AC3-audio 扩展的 MPEG-4 视频格式，而 .m4a 针对音频，m4p 针对较旧的 itunes 音频格式，m4b 针对有声读物。</p>
<p>MP3 不是容器格式，使用编码音频数据，使用 ID3v2 格式保存元数据。由于专利限制，AVFoundation 只支持读取 MP3，不支持编码 MP3。</p>
<h2 id="4-使用元数据"><a href="#4-使用元数据" class="headerlink" title="4. 使用元数据"></a>4. 使用元数据</h2><p>AVFoundation 使用键空间作为将相关键组合在一起的方法，可以实现对 AVMetaDataItem 实例集合的筛选。Common 键空间用于定义所有支持的媒体类型的键，包括曲名、歌手、插图信息等。开发者可以通过查询资源或曲目的 commonMetadata 属性从 common 键空间获取元数据，这个属性会返回一个包含所有可用元数据的数组。</p>
<p>访问指定格式的元数据，需要对 AVAsset 对象调用 metadataForFormat 方法，此方法包含一个用于定义元数据格式的 NSString 对象并返回一个包含所有相关元数据信息的 NSArray。一个 AVAsset 所支持的资源格式可以通过 availableMetadataFormats 属性来获取。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.targetAVAsset loadValuesAsynchronouslyForKeys:@[<span class="string">@"availableMetadataFormats"</span>] completionHandler:^&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVKeyValueStatus</span> status = [<span class="keyword">self</span>.targetAVAsset statusOfValueForKey:<span class="string">@"availableMetadataFormats"</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>: &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSString</span> *format <span class="keyword">in</span> <span class="keyword">self</span>.targetAVAsset.availableMetadataFormats) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, format);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span>.targetAVAsset metadataForFormat:format]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AVKeyValueStatusFailed"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusUnknown</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AVKeyValueStatusUnknown"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"AVKeyValueStatusCancelled"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>示例输出如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">com.apple.quicktime.mdta</span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">    <span class="string">"&lt;AVMetadataItem: 0x1c801f230, identifier=mdta/com.apple.quicktime.software, keySpace=mdta, key class = __NSCFString, key=com.apple.quicktime.software, commonKey=software, extendedLanguageTag=(null), dataType=com.apple.metadata.datatype.UTF-8, time=&#123;INVALID&#125;, duration=&#123;INVALID&#125;, startDate=(null), extras=&#123;\n    dataType = 1;\n    dataTypeNamespace = \"com.apple.quicktime.mdta\";\n&#125;, value class=__NSCFString, value=video.vue.ios.280&gt;"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"&lt;AVMetadataItem: 0x1c42004d0, identifier=mdta/com.apple.quicktime.description, keySpace=mdta, key class = __NSCFString, key=com.apple.quicktime.description, commonKey=description, extendedLanguageTag=(null), dataType=com.apple.metadata.datatype.UTF-8, time=&#123;INVALID&#125;, duration=&#123;INVALID&#125;, startDate=(null), extras=&#123;\n    dataType = 1;\n    dataTypeNamespace = \"com.apple.quicktime.mdta\";\n&#125;, value class=__NSCFString, value=ewogICJzc2Z3IiA6IFsKICAgICIiCiAgXSwKICAic2RldiIgOiBbCiAgICAiIgogIF0sCiAgInNjIiA6IDEsCiAgInNsb2MiIDogWwogICAgIiIKICBdLAogICJzdWIiIDogWwogICAgIiIKICBdLAogICJ0cnMiIDogWwogICAgMCwKICAgIDAKICBdLAogICJzZHVyIiA6IFsKICAgIDEwCiAgXSwKICAiY2FwIiA6ICIgIiwKICAiZiIgOiBbCiAgICAiMSIKICBdCn0=&gt;"</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="5-实践"><a href="#5-实践" class="headerlink" title="5. 实践"></a>5. 实践</h2><h3 id="5-1-对-AVAsset-进行封装"><a href="#5-1-对-AVAsset-进行封装" class="headerlink" title="5.1 对 AVAsset 进行封装"></a>5.1 对 AVAsset 进行封装</h3><p>通过 url 我们可以实例化一个 AVAsset，也可以获取到其中一些有效的元数据信息</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">_url = url;</span><br><span class="line">_asset = [<span class="built_in">AVAsset</span> assetWithURL:url];</span><br><span class="line">_filename = [url lastPathComponent];</span><br><span class="line">_filetype = [<span class="keyword">self</span> fileTypeForURL:url];                              </span><br><span class="line">_editable = ![_filetype isEqualToString:<span class="built_in">AVFileTypeMPEGLayer3</span>];</span><br></pre></td></tr></table></figure>

<p>lastPathComponent 从 URL （例如 “file:///Users/yasic/Library/Application%20Support/MetaManager/01%20Demo%20AAC.m4a”）的最后一个路径取出文件名，fileTypeForURL 具体实现如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fileTypeForURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *ext = [[<span class="keyword">self</span>.url lastPathComponent] pathExtension];</span><br><span class="line">    <span class="built_in">NSString</span> *type = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([ext isEqualToString:<span class="string">@"m4a"</span>]) &#123;</span><br><span class="line">        type = <span class="built_in">AVFileTypeAppleM4A</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([ext isEqualToString:<span class="string">@"m4v"</span>]) &#123;</span><br><span class="line">        type = <span class="built_in">AVFileTypeAppleM4V</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([ext isEqualToString:<span class="string">@"mov"</span>]) &#123;</span><br><span class="line">        type = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([ext isEqualToString:<span class="string">@"mp4"</span>]) &#123;</span><br><span class="line">        type = <span class="built_in">AVFileTypeMPEG4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = <span class="built_in">AVFileTypeMPEGLayer3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-获取元数据"><a href="#5-2-获取元数据" class="headerlink" title="5.2 获取元数据"></a>5.2 获取元数据</h3><p>对于通用键空间，可以通过 commonMetadata 属性获取到元数据对应的 AVMetadataItem 对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *keys = @[COMMON_META_KEY];</span><br><span class="line">[<span class="keyword">self</span>.asset loadValuesAsynchronouslyForKeys:keys completionHandler:^&#123;</span><br><span class="line">    <span class="built_in">AVKeyValueStatus</span> commonStatus =</span><br><span class="line">        [<span class="keyword">self</span>.asset statusOfValueForKey:COMMON_META_KEY error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.prepared = (commonStatus == <span class="built_in">AVKeyValueStatusLoaded</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.prepared) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">AVMetadataItem</span> *item <span class="keyword">in</span> <span class="keyword">self</span>.asset.commonMetadata) &#123;</span><br><span class="line">            <span class="comment">//NSLog(@"%@: %@", item.keyString, item.value);</span></span><br><span class="line">            [<span class="keyword">self</span>.metadata addMetadataItem:item withKey:item.commonKey];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>对于其他格式的元数据，先获取到可用格式的数组，然后分别进行元数据获取</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *keys = @[<span class="built_in">AVAILABLE_META_KEY</span>];</span><br><span class="line">[<span class="keyword">self</span>.asset loadValuesAsynchronouslyForKeys:keys completionHandler:^&#123;</span><br><span class="line">    <span class="built_in">AVKeyValueStatus</span> formatsStatus = [<span class="keyword">self</span>.asset statusOfValueForKey:<span class="built_in">AVAILABLE_META_KEY</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.prepared = (formatsStatus == <span class="built_in">AVKeyValueStatusLoaded</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.prepared) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> format <span class="keyword">in</span> <span class="keyword">self</span>.asset.availableMetadataFormats) &#123;        <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.acceptedFormats containsObject:format]) &#123;</span><br><span class="line">                <span class="built_in">NSArray</span> *items = [<span class="keyword">self</span>.asset metadataForFormat:format];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">AVMetadataItem</span> *item <span class="keyword">in</span> items) &#123;</span><br><span class="line">                    <span class="comment">//NSLog(@"%@: %@", item.keyString, item.value);</span></span><br><span class="line">                    [<span class="keyword">self</span>.metadata addMetadataItem:item</span><br><span class="line">                                           withKey:item.keyString];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>获取到的元数据有些是可以直接阅读的，有些则不够语义化，需要进行不同方式的转化，包括 Artwork、注释、音轨数据、唱片数据、风格数据等类型的数据，这里不再赘述。</p>
<h3 id="5-3-保存元数据"><a href="#5-3-保存元数据" class="headerlink" title="5.3 保存元数据"></a>5.3 保存元数据</h3><p>对于元数据的修改不能直接操作原 AVAsset，需要使用 AVAssetExportSession 导出一个新的资源副本来覆盖原本的资源对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *presetName = <span class="built_in">AVAssetExportPresetPassthrough</span>;</span><br><span class="line"><span class="built_in">AVAssetExportSession</span> *session =</span><br><span class="line">    [[<span class="built_in">AVAssetExportSession</span> alloc] initWithAsset:<span class="keyword">self</span>.asset</span><br><span class="line">                                     presetName:presetName];</span><br></pre></td></tr></table></figure>

<p>AVAssetExportSession 的初始化需要一个待修改的 AVAsset 对象，以及一个预设值，AVAssetExportPresetPassthrough 预设值能够在不重新编码媒体的前提下实现写入元数据功能，但不能添加新的元数据。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *outputURL = [<span class="keyword">self</span> tempURL];</span><br><span class="line">session.outputURL = outputURL;</span><br><span class="line">session.outputFileType = <span class="keyword">self</span>.filetype;</span><br><span class="line">session.metadata = [<span class="keyword">self</span>.metadata metadataItems];</span><br></pre></td></tr></table></figure>

<p>指定导出副本的存储位置，配置到 session 上。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[session exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">    <span class="built_in">AVAssetExportSessionStatus</span> status = session.status;</span><br><span class="line">    <span class="built_in">BOOL</span> success = (status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *sourceURL = <span class="keyword">self</span>.url;</span><br><span class="line">        <span class="built_in">NSFileManager</span> *manager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">        [manager removeItemAtURL:sourceURL error:<span class="literal">nil</span>];</span><br><span class="line">        [manager moveItemAtURL:outputURL toURL:sourceURL error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>导出需要用到 exportAsynchronouslyWithCompletionHandler 方法，完成后对状态进行判断，获知导出是否成功，然后通过 NSFileManager 的 moveItemAtURL 方法来覆盖原始的媒体资源</p>
]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-入门</title>
    <url>/2018/04/24/AVFoundation/AVFoundation-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>AV Foundation 是 OSX 系统和 iOS 系统中用于处理基于时间的媒体数据的高级 objectivec 框架，其设计过程高度依赖多线程机制，充分利用了多核硬件优势，大量使用 Block 和 GCD 机制。AVFoundation 能与高层级框架无缝衔接，也能提供低层级框架的功能和性能。</p>
<h2 id="1-AVFoundation-核心功能"><a href="#1-AVFoundation-核心功能" class="headerlink" title="1. AVFoundation 核心功能"></a>1. AVFoundation 核心功能</h2><p>AVFoundation 提供的核心功能如下所示</p>
<ul>
<li>音频播放和记录——AVAudioPlayer 和 AVAudioRecorder</li>
<li>媒体文件检查——AVMetadataItem</li>
<li>视频播放——AVPalyer 和 AVPlayerItem</li>
<li>媒体捕捉——AVCaptureSession</li>
<li>媒体编辑</li>
<li>媒体处理——AVAssetReader、AVAssetWriter</li>
</ul>
<h2 id="2-数字媒体"><a href="#2-数字媒体" class="headerlink" title="2. 数字媒体"></a>2. 数字媒体</h2><h3 id="2-1-数字媒体采样"><a href="#2-1-数字媒体采样" class="headerlink" title="2.1 数字媒体采样"></a>2.1 数字媒体采样</h3><p>将现实世界的模拟信号转换为能够被计算机存储和传输的数字信号，需要经过模拟-数字转换过程，也称为采样。数字化采样有两种方式，一种是时间采样，即捕捉一个信号周期内的变化，一种是空间采样，一般用于图片数字化和其他可视化媒体内容数字化上，它对一个图片在一定分辨率下捕捉其亮度和色度，进而创建出由该图片的像素点数据所构成的数字化结果。视频既有空间属性又有时间属性，所以数字化时都可以使用。</p>
<h3 id="2-2-音频采样"><a href="#2-2-音频采样" class="headerlink" title="2.2 音频采样"></a>2.2 音频采样</h3><p>对于一个音频，麦克风负责将物理振动转化为相同频率和振幅的电流信号，之后通过线性脉冲编码调制（LPCM）进行编码。LPCM 采样或测量一个固定的音频信号，其周期率被称为采样率。采样频率达到奈奎斯特频率（采样对象最高频率的 2 倍）时即可准确表现原始信号的信息。另一方面编码字节数（也称位元深度）表现了采样精度，如位元深度为 8 位的编码能够提供 256 个离散级别的数据，CD 音质位元深度为 16。</p>
<h2 id="3-数字媒体压缩"><a href="#3-数字媒体压缩" class="headerlink" title="3. 数字媒体压缩"></a>3. 数字媒体压缩</h2><p>原始、未压缩的数字化媒体数据需要大量的存储空间，因此需要进行压缩。</p>
<h3 id="3-1-色彩二次抽样"><a href="#3-1-色彩二次抽样" class="headerlink" title="3.1 色彩二次抽样"></a>3.1 色彩二次抽样</h3><p>由于人类的眼睛对亮度的敏感度高于颜色的敏感度，因此可以大幅降低存储在每个像素中的颜色信息，而不至于图片质量严重受损，这一过程称为色彩二次采样。</p>
<p>视频数据都使用 YCbCr 颜色模式，也称为 YUV 模式，与 RGB 视频信号传输相比，它最大的优点在于只需占用极少的频宽。其中 “Y” 表示明亮度（Luminance或Luma），也就是灰阶值；而 “U” 和 “V” 表示的则是色度。</p>
<p>色彩二次抽样通常用一个三分比值表示，J:a:b（例如4:2:2），形容一个以J个像素宽及两个像素高的概念上区域：</p>
<p>J：水平抽样参照（概念上区域的宽度）。通常为4<br>a：在J个像素第一行中的色度抽样数目（Cr, Cb）<br>b：在J个像素第二行中的额外色度抽样数目（Cr, Cb）</p>
<p>下面是抽样示意图</p>
<img src="http://lea.hamradio.si/~s51kq/subsample.gif" width=500>

<p>4:4:4 比例下全彩色信息都可被保存，在 4:2:2 比例下色彩信息为每两个水平像素的平均值，在 4:2:0 比例下色彩信息为水平和垂直 4 个像素的平均值。</p>
<h3 id="3-2-编解码器压缩"><a href="#3-2-编解码器压缩" class="headerlink" title="3.2 编解码器压缩"></a>3.2 编解码器压缩</h3><p>编解码器使用高级压缩算法对需要保存或发送的音频或视频数据进行压缩和编码，同时可以将压缩文件解码成适合播放和编辑的媒体资源文件。编解码器分无损压缩和有损压缩，zip 和 gzip 就是无损压缩。</p>
<h3 id="3-3-视频编解码器"><a href="#3-3-视频编解码器" class="headerlink" title="3.3 视频编解码器"></a>3.3 视频编解码器</h3><p>AVFoundation 只提供 H.264 和 Apple ProRes 两种媒体类型的支持，但 iOS 只支持 H.264。</p>
<h4 id="3-3-1-H-264"><a href="#3-3-1-H-264" class="headerlink" title="3.3.1 H.264"></a>3.3.1 H.264</h4><p>H.264 规范是 Motion Picture Experts Group（MPEG）定义的 PMEG-4 的一部分，与其他 MPEG 压缩一样，H.264 通过下面两个维度来压缩视频文件尺寸：</p>
<ul>
<li>空间：压缩独立视频帧，被称为帧内压缩</li>
<li>时间：以组为单位压缩视频帧冗余数据，称为帧间压缩</li>
</ul>
<p>帧内压缩通过消除包含在每个独立视频帧内的色彩及结构中的冗余信息来进行压缩，因此可以在不降低图片质量情况下尽可能缩小尺寸，这一过程创建的帧称为 I-frames。</p>
<p>帧间压缩将很多帧组合为一组图片（简称 GOP），对于 GOP 所存在的时间维度的冗余可以被消除。GOP 存储三种不同类型的帧：</p>
<ul>
<li>I-frames：关键帧，创建完整图片所需要的所有数据，尺寸大但解压快</li>
<li>P-frames：预测帧，基于最近的 I-frames 或 P-frames 的可预测图片进行编码得到</li>
<li>B-frames：双向帧，基于使用之前和之后的帧信息编码得到的帧，解压过程费时</li>
</ul>
<h3 id="3-4-音频解码器"><a href="#3-4-音频解码器" class="headerlink" title="3.4 音频解码器"></a>3.4 音频解码器</h3><p>AVFoundation 广泛使用 AAC（高级音频编码） 作为音频解码器，它是 H.264 标准相应的音频处理方式，优于 MP3 格式。</p>
]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-高级捕捉功能</title>
    <url>/2018/04/24/AVFoundation/AVFoundation-%E9%AB%98%E7%BA%A7%E6%8D%95%E6%8D%89%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="1-视频缩放"><a href="#1-视频缩放" class="headerlink" title="1. 视频缩放"></a>1. 视频缩放</h2><p>iOS 7.0 为 AVCaptureDevice 提供了一个 videoZoomFactor 属性用于对视频输出和捕捉提供缩放效果，这个属性的最小值为 1.0，最大值由下面的方法提供</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.cameraHelper.activeVideoDevice.activeFormat.videoMaxZoomFactor;</span><br></pre></td></tr></table></figure>

<p>因而判断一个设备能否进行缩放也可以通过判断这一属性来获知</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)cameraSupportsZoom</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.cameraHelper.activeVideoDevice.activeFormat.videoMaxZoomFactor &gt; <span class="number">1.0</span>f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设备执行缩放效果是通过居中裁剪由摄像头传感器捕捉到的图片实现的，也可以通过 videoZoomFactorUpscaleThreshold 来设置具体的放大中心。当 zoom factors 缩放因子比较小的时候，裁剪的图片刚好等于或者大于输出尺寸（考虑与抗边缘畸变有关），则无需放大就可以返回。但是当 zoom factors 比较大时，设备必须缩放裁剪图片以符合输出尺寸，从而导致图片质量上的丢失。具体的临界点由  videoZoomFactorUpscaleThreshold 值来确定。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 iphone6s 和 iphone8plus 上测试得到此值为 2.0左右</span></span><br><span class="line"><span class="keyword">self</span>.cameraHelper.activeVideoDevice.activeFormat.videoZoomFactorUpscaleThreshold;</span><br></pre></td></tr></table></figure>

<p>可以通过一个变化值从 0.0 到 1.0 的 UISlider 来实现对缩放值的控制。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.slider addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(sliderValueChange:) forControlEvents:<span class="built_in">UIControlEventValueChanged</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sliderValueChange:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UISlider</span> *slider = (<span class="built_in">UISlider</span> *)sender;</span><br><span class="line">    [<span class="keyword">self</span> setZoomValue:slider.value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)maxZoomFactor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> MIN(<span class="keyword">self</span>.cameraHelper.activeVideoDevice.activeFormat.videoMaxZoomFactor, <span class="number">4.0</span>f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setZoomValue:(<span class="built_in">CGFloat</span>)zoomValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.cameraHelper.activeVideoDevice.isRampingVideoZoom) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.cameraHelper.activeVideoDevice lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> zoomFactor = pow([<span class="keyword">self</span> maxZoomFactor], zoomValue);</span><br><span class="line">            <span class="keyword">self</span>.cameraHelper.activeVideoDevice.videoZoomFactor = zoomFactor;</span><br><span class="line">            [<span class="keyword">self</span>.cameraHelper.activeVideoDevice unlockForConfiguration];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先注意在进行配置属性前需要进行设备的锁定，否则会引发异常。其次，插值缩放是一个指数形式的增长，传入的 slider 值是线性的，需要进行一次 pow 运算得到需要缩放的值。另外，videoMaxZoomFactor 的值可能会非常大，在 iphone8p 上这一个值是 16，缩放到这么大的图像是没有太大意义的，因此需要人为设置一个最大缩放值，这里选择 4.0。</p>
<p>当然这里进行的缩放是立即生效的，下面的方法可以以一个速度平滑缩放到一个缩放因子上</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)rampZoomToValue:(<span class="built_in">CGFloat</span>)zoomValue &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> zoomFactor = pow([<span class="keyword">self</span> maxZoomFactor], zoomValue);</span><br><span class="line">	<span class="built_in">NSError</span> *error;</span><br><span class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.activeCamera lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">		[<span class="keyword">self</span>.activeCamera rampToVideoZoomFactor:zoomFactor</span><br><span class="line">                                        withRate:THZoomRate];</span><br><span class="line">		[<span class="keyword">self</span>.activeCamera unlockForConfiguration];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelZoom &#123;</span><br><span class="line">	<span class="built_in">NSError</span> *error;</span><br><span class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.activeCamera lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">		[<span class="keyword">self</span>.activeCamera cancelVideoZoomRamp];</span><br><span class="line">		[<span class="keyword">self</span>.activeCamera unlockForConfiguration];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听设备的 videoZoomFactor 可以获知当前的缩放值</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>, activeVideoDevice.videoZoomFactor) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"videoZoomFactor: %f"</span>, <span class="keyword">self</span>.activeVideoDevice.videoZoomFactor);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>监听设备的 rampingVideoZoom 可以获知设备是否正在平滑缩放</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>, activeVideoDevice.rampingVideoZoom) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"rampingVideoZoom : %@"</span>, (<span class="keyword">self</span>.activeVideoDevice.rampingVideoZoom)?<span class="string">@"true"</span>:<span class="string">@"false"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="2-人脸识别"><a href="#2-人脸识别" class="headerlink" title="2. 人脸识别"></a>2. 人脸识别</h2><p>人脸识别需要用到 AVCaptureMetadataOutput 作为输出，首先将其加入到捕捉会话中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.metaDataOutput = [[<span class="built_in">AVCaptureMetadataOutput</span> alloc] init];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.metaDataOutput]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.metaDataOutput];</span><br><span class="line">    <span class="built_in">NSArray</span> *metaDataObjectType = @[<span class="built_in">AVMetadataObjectTypeFace</span>];</span><br><span class="line">    <span class="keyword">self</span>.metaDataOutput.metadataObjectTypes = metaDataObjectType;</span><br><span class="line">    [<span class="keyword">self</span>.metaDataOutput setMetadataObjectsDelegate:<span class="keyword">self</span> queue:dispatch_get_main_queue()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里需要指定 AVCaptureMetadataOutput 的 metadataObjectTypes 属性，将其设置为 AVMetadataObjectTypeFace 的数组，它代表着人脸元数据对象。然后设置其遵循 AVCaptureMetadataOutputObjectsDelegate 协议的委托对象及回调线程，当检测到人脸时就会调用下面的方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didOutputMetadataObjects:(<span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVMetadataObject</span> *&gt; *)metadataObjects fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.detectFaces) &#123;</span><br><span class="line">        <span class="keyword">self</span>.detectFaces(metadataObjects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 metadataObjects 是一个包含了许多 AVMetadataObject 对象的数组，这里则可以认为都是 AVMetadataObject 的子类 AVMetadataFaceObject。对于 AVMetadataFaceObject 对象，有四个重要的属性</p>
<ul>
<li>faceID，用于标识检测到的每一个 face</li>
<li>rollAngle，用于标识人脸斜倾角，即人的头部向肩膀方便的侧倾角度</li>
<li>yawAngle，偏转角，即人脸绕 y 轴旋转的角度</li>
<li>bounds，标识检测到的人脸区域</li>
</ul>
<p>这里我们将其回调给 ViewController，用于进行 UI 展示。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">        @weakify(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">self</span>.cameraHelper.detectFaces = ^(<span class="built_in">NSArray</span> *faces) &#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>)</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *transformedFaces = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">AVMetadataFaceObject</span> *face <span class="keyword">in</span> faces) &#123;</span><br><span class="line">                <span class="built_in">AVMetadataObject</span> *transformedFace = [<span class="keyword">self</span>.previewLayer transformedMetadataObjectForMetadataObject:face];</span><br><span class="line">                [transformedFaces addObject:transformedFace];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *lostFaces = [<span class="keyword">self</span>.faceLayers.allKeys mutableCopy];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">AVMetadataFaceObject</span> *face <span class="keyword">in</span> transformedFaces) &#123;</span><br><span class="line">                <span class="built_in">NSNumber</span> *faceId = @(face.faceID);</span><br><span class="line">                [lostFaces removeObject:faceId];</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">CALayer</span> *layer = <span class="keyword">self</span>.faceLayers[faceId];</span><br><span class="line">                <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">                    layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">                    layer.borderWidth = <span class="number">5.0</span>f;</span><br><span class="line">                    layer.borderColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.188</span> green:<span class="number">0.517</span> blue:<span class="number">0.877</span> alpha:<span class="number">1.000</span>].CGColor;</span><br><span class="line">                    [<span class="keyword">self</span>.previewLayer addSublayer:layer];</span><br><span class="line">                    <span class="keyword">self</span>.faceLayers[faceId] = layer;</span><br><span class="line">                &#125;</span><br><span class="line">                layer.transform = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">                layer.frame = face.bounds;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (face.hasRollAngle) &#123;</span><br><span class="line">                    layer.transform = <span class="built_in">CATransform3DConcat</span>(layer.transform, [<span class="keyword">self</span> transformForRollAngle:face.rollAngle]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (face.hasYawAngle) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, face.yawAngle);</span><br><span class="line">                    layer.transform = <span class="built_in">CATransform3DConcat</span>(layer.transform, [<span class="keyword">self</span> transformForYawAngle:face.yawAngle]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *faceID <span class="keyword">in</span> lostFaces) &#123;</span><br><span class="line">                <span class="built_in">CALayer</span> *layer = <span class="keyword">self</span>.faceLayers[faceID];</span><br><span class="line">                [layer removeFromSuperlayer];</span><br><span class="line">                [<span class="keyword">self</span>.faceLayers removeObjectForKey:faceID];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// Rotate around Z-axis</span></span><br><span class="line">- (<span class="built_in">CATransform3D</span>)transformForRollAngle:(<span class="built_in">CGFloat</span>)rollAngleInDegrees &#123;        <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">CGFloat</span> rollAngleInRadians = THDegreesToRadians(rollAngleInDegrees);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DMakeRotation</span>(rollAngleInRadians, <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rotate around Y-axis</span></span><br><span class="line">- (<span class="built_in">CATransform3D</span>)transformForYawAngle:(<span class="built_in">CGFloat</span>)yawAngleInDegrees &#123;          <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">CGFloat</span> yawAngleInRadians = THDegreesToRadians(yawAngleInDegrees);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CATransform3D</span> yawTransform = <span class="built_in">CATransform3DMakeRotation</span>(yawAngleInRadians, <span class="number">0.0</span>f, <span class="number">-1.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DConcat</span>(yawTransform, [<span class="keyword">self</span> orientationTransform]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CATransform3D</span>)orientationTransform &#123;                                     <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">CGFloat</span> angle = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">switch</span> ([<span class="built_in">UIDevice</span> currentDevice].orientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>:</span><br><span class="line">            angle = M_PI;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationLandscapeRight</span>:</span><br><span class="line">            angle = -M_PI / <span class="number">2.0</span>f;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationLandscapeLeft</span>:</span><br><span class="line">            angle = M_PI / <span class="number">2.0</span>f;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// as UIDeviceOrientationPortrait</span></span><br><span class="line">            angle = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DMakeRotation</span>(angle, <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> THDegreesToRadians(<span class="built_in">CGFloat</span> degrees) &#123;</span><br><span class="line">    <span class="keyword">return</span> degrees * M_PI / <span class="number">180</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用一个字典来管理每一个展示一个 face 对象的 layer，它的 key 值即 faceID，回调时更新当前已存在的 faceLayer，移除不需要的 faceLayer。其次对每一个 face，根据其 rollAngle 和 yawAngle 要通过 transfor 来变换展示的矩阵。</p>
<p>还要注意一点，transformedMetadataObjectForMetadataObject 方法可以将设备坐标系上的数据转换到视图坐标系上，设备坐标系的范围是 (0, 0) 到 （1，1）。</p>
<h2 id="3-机器可读代码识别"><a href="#3-机器可读代码识别" class="headerlink" title="3. 机器可读代码识别"></a>3. 机器可读代码识别</h2><p>机器可读代码包括一维条码和二维码等，AVFoundation 支持多种一维码和三种二维码，其中最常见的是 QR 码，也即二维码。</p>
<p>扫码仍然需要用到 AVMetadataObject 对象，首先加入到捕捉会话中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.metaDataOutput = [[<span class="built_in">AVCaptureMetadataOutput</span> alloc] init];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.metaDataOutput]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.metaDataOutput];</span><br><span class="line">    [<span class="keyword">self</span>.metaDataOutput setMetadataObjectsDelegate:<span class="keyword">self</span> queue:dispatch_get_main_queue()];</span><br><span class="line">    <span class="built_in">NSArray</span> *types = @[<span class="built_in">AVMetadataObjectTypeQRCode</span>];</span><br><span class="line">    <span class="keyword">self</span>.metaDataOutput.metadataObjectTypes = types;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现委托方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didOutputMetadataObjects:(<span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVMetadataObject</span> *&gt; *)metadataObjects fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    [metadataObjects enumerateObjectsUsingBlock:^(__kindof <span class="built_in">AVMetadataObject</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">AVMetadataMachineReadableCodeObject</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, ((<span class="built_in">AVMetadataMachineReadableCodeObject</span>*)obj).stringValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个 AVMetadataMachineReadableCodeObject，有以下三个重要属性</p>
<ul>
<li>stringValue，用于表示二维码编码信息</li>
<li>bounds，用于表示二维码的矩形边界</li>
<li>corners，一个角点字典表示的数组，比 bounds 表示的二维码区域更精确</li>
</ul>
<p>所以可以通过以上属性，在 UI 界面上对二维码区域进行高亮展示</p>
<p>首先需要注意，一个从 captureSession 获得的 AVMetadataMachineReadableCodeObject，其坐标是设备坐标系下的坐标，需要进行坐标转换</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)transformedCodesFromCodes:(<span class="built_in">NSArray</span> *)codes &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *transformedCodes = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [codes enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="built_in">AVMetadataObject</span> *transformedCode = [<span class="keyword">self</span>.previewLayer transformedMetadataObjectForMetadataObject:obj];</span><br><span class="line">        [transformedCodes addObject:transformedCode];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> [transformedCodes <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，对于每一个 AVMetadataMachineReadableCodeObject 对象，其 bounds 属性由于是 CGRect，所以可以直接绘制出一个 UIBezierPath 对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIBezierPath</span> *)bezierPathForBounds:(<span class="built_in">CGRect</span>)bounds &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIBezierPath</span> bezierPathWithRect:bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 corners 属性是一个字典，需要手动生成 CGPoint，然后进行连线操作，生成 UIBezierPath 对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIBezierPath</span> *)bezierPathForCorners:(<span class="built_in">NSArray</span> *)corners &#123;</span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; corners.count; i++) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> point = [<span class="keyword">self</span> pointForCorner:corners[i]];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            [path moveToPoint:point];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [path addLineToPoint:point];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [path closePath];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGPoint</span>)pointForCorner:(<span class="built_in">NSDictionary</span> *)corner &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point;</span><br><span class="line">    <span class="built_in">CGPointMakeWithDictionaryRepresentation</span>((<span class="built_in">CFDictionaryRef</span>)corner, &amp;point);</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corners 字典的形式大致如下所示，可以调用 CGPointMakeWithDictionaryRepresentation 便捷函数将其转换为 CGPoint 形式。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    X = <span class="string">"336.9957633633747"</span>;</span><br><span class="line"></span><br><span class="line">    Y = <span class="string">"265.7881843381643"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说一个 corners 里会包含 4 个 corner 字典。</p>
<p>获取到每一个 code 对应的两个 UIBezierPath 对象后，就可以在视图上添加相应的 CALayer 来显示高亮区域了。</p>
<h2 id="4-使用高帧率捕捉"><a href="#4-使用高帧率捕捉" class="headerlink" title="4. 使用高帧率捕捉"></a>4. 使用高帧率捕捉</h2><p>高帧率捕获视频是在 iOS 7 以后加入的，具有更逼真的效果和更好的清晰度，对于细节的加强和动作流畅度的提升非常明显，尤其是录制快速移动的内容时更为明显，也可以实现高质量的慢动作视频效果。</p>
<p>实现高帧率捕捉的基本思路是，通过设备的 formats 属性获取所有支持的格式，也就是 AVCaptureDeviceFormat 对象；然后根据对象的 videoSupportedFrameRateRanges 属性，可以获知其所支持的最小帧率、最大帧率及时长信息；然后手动设置设备的格式和帧时长。</p>
<p>首先写一个 AVCaptureDevice 的 category，获取支持格式的最大帧率的方法如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVCaptureDeviceFormat</span> *maxFormat = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">AVFrameRateRange</span> *maxFrameRateRange = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureDeviceFormat</span> *format <span class="keyword">in</span> <span class="keyword">self</span>.formats) &#123;</span><br><span class="line">    FourCharCode codecType = <span class="built_in">CMVideoFormatDescriptionGetCodecType</span>(format.formatDescription);</span><br><span class="line">    <span class="keyword">if</span> (codecType == kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *frameRateRanges = format.videoSupportedFrameRateRanges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">AVFrameRateRange</span> *range <span class="keyword">in</span> frameRateRanges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (range.maxFrameRate &gt; maxFrameRateRange.maxFrameRate) &#123;</span><br><span class="line">                maxFormat = format;</span><br><span class="line">                maxFrameRateRange = range;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>codecType 是一个无符号32位的数据类型，但是是由四个字符对应的四个字节组成，一般可能值为 “420v” 或 “420f”，这里选取 420v 格式来配置。</p>
<p>可以通过判断最大帧率是否大于 30，来判断设备是否支持高帧率</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isHighFrameRate &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.frameRateRange.maxFrameRate &gt; <span class="number">30.0</span>f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以进行配置了</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> hasMediaType:<span class="built_in">AVMediaTypeVideo</span>] &amp;&amp; [<span class="keyword">self</span> lockForConfiguration:error] &amp;&amp; [<span class="keyword">self</span>.activeCamera supportsHighFrameRateCapture]) &#123;</span><br><span class="line">    <span class="built_in">CMTime</span> minFrameDuration = <span class="keyword">self</span>.frameRateRange.minFrameDuration;</span><br><span class="line">    <span class="keyword">self</span>.activeFormat = <span class="keyword">self</span>.format;</span><br><span class="line">    <span class="keyword">self</span>.activeVideoMinFrameDuration = minFrameDuration;</span><br><span class="line">    <span class="keyword">self</span>.activeVideoMaxFrameDuration = minFrameDuration;</span><br><span class="line">    [<span class="keyword">self</span> unlockForConfiguration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先锁定了设备，然后将最小帧时长和最大帧时长都设置成 minFrameDuration，帧时长与帧率是倒数关系，所以最大帧率对应最小帧时长。</p>
<p>播放时可以针对 AVPlayer 设置不同的 rate 实现变速播放，在 iphone8plus 上实测，如果 rate 在 0 到 0.5 之间， 则实际播放速率仍为 0.5。</p>
<p>另外要注意设置 AVPlayerItem 的 audioTimePitchAlgorithm 属性，这个属性允许你指定当视频正在各种帧率下播放的时候如何播放音频</p>
<ul>
<li>AVAudioTimePitchAlgorithmLowQualityZeroLatency 质量低,适合快进,快退或低质量语音</li>
<li>AVAudioTimePitchAlgoruthmTimeDomain 质量适中，计算成本较低，适合语音</li>
<li>AVAudioTimePitchAlgorithmSpectral 最高质量，最昂贵的计算，保留了原来的项目间距</li>
<li>AVAudioTimePitchAlgorithmVarispeed 高品质的播放没有音高校正</li>
</ul>
<p>通常选择 AVAudioTimePitchAlgorithmSpectral 或 AVAudioTimePitchAlgoruthmTimeDomain 即可。</p>
<h2 id="5-视频处理"><a href="#5-视频处理" class="headerlink" title="5. 视频处理"></a>5. 视频处理</h2><p>AVCaptureMovieFileOutput 可以简单地捕捉视频，但是不能进行视频数据交互，因此需要使用 AVCaptureVideoDataOutput 类。AVCaptureVideoDataOutput 是一个 AVCaptureOutput 的子类，可以直接访问摄像头传感器捕捉到的视频帧。与之对应的是处理音频输入的 AVCaptureAudioDataOutput 类。</p>
<p>AVCaptureVideoDataOutput 有一个遵循 AVCaptureVideoDataOutputSampleBufferDelegate 协议的委托对象，它有下面两个主要方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection; <span class="comment">// 有新的视频帧写入时调用，数据会基于 output 的 videoSetting 进行解码或重新编码</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didDropSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection; <span class="comment">// 有迟到的视频帧被丢弃时调用，通常是因为在上面一个方法里进行了比较耗时的操作</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-CMSampleBufferRef"><a href="#5-1-CMSampleBufferRef" class="headerlink" title="5.1 CMSampleBufferRef"></a>5.1 CMSampleBufferRef</h3><p>CMSampleBufferRef 是一个由 Core Media 框架提供的 Core Foundation 风格的对象，用于在媒体管道中传输数字样本。</p>
<h4 id="5-1-1-样本数据"><a href="#5-1-1-样本数据" class="headerlink" title="5.1.1 样本数据"></a>5.1.1 样本数据</h4><p>可以对 CMSampleBufferRef 的每一个 Core Video 视频帧进行处理</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> BYTES_PER_PIXEL = <span class="number">4</span>;</span><br><span class="line">CVPixelBufferRef pixelBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer); <span class="comment">//CVPixelBufferRef 在主内存中保存像素数据</span></span><br><span class="line">CVPixelBufferLockBaseAddress(pixelBuffer, <span class="number">0</span>); <span class="comment">// 获取相应内存块的锁</span></span><br><span class="line">size_t bufferWidth = CVPixelBufferGetWidth(pixelBuffer);</span><br><span class="line">size_t bufferHeight = CVPixelBufferGetHeight(pixelBuffer);<span class="comment">// 获取像素宽高</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *pixel = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)CVPixelBufferGetBaseAddress(pixelBuffer); <span class="comment">// 获取像素 buffer 的起始位置</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> grayPixel;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; bufferHeight; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; bufferWidth; column ++) &#123; <span class="comment">// 遍历每一个像素点</span></span><br><span class="line">        grayPixel = (pixel[<span class="number">0</span>] + pixel[<span class="number">1</span>] + pixel[<span class="number">2</span>])/<span class="number">3.0</span>;</span><br><span class="line">        pixel[<span class="number">0</span>] = pixel[<span class="number">1</span>] = pixel[<span class="number">2</span>] = grayPixel;</span><br><span class="line">        pixel += BYTES_PER_PIXEL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CIImage</span> *ciImage = [<span class="built_in">CIImage</span> imageWithCVPixelBuffer:pixelBuffer]; <span class="comment">// 通过 buffer 生成对应的 CIImage</span></span><br><span class="line">CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="number">0</span>); <span class="comment">// 解除锁</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-格式描述"><a href="#5-1-2-格式描述" class="headerlink" title="5.1.2 格式描述"></a>5.1.2 格式描述</h4><p>CMSampleBufferRef 还提供了每一帧数据的格式信息，CMFormatDescription.h 头文件定义了大量函数来获取各种信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMFormatDescriptionRef formatDescription &#x3D; CMSampleBufferGetFormatDescription(sampleBuffer);</span><br><span class="line">CMMediaType mediaType &#x3D; CMFormatDescriptionGetMediaType(formatDescription);</span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-时间信息"><a href="#5-1-3-时间信息" class="headerlink" title="5.1.3 时间信息"></a>5.1.3 时间信息</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> presentation = <span class="built_in">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer); <span class="comment">// 获取帧样本的原始时间戳</span></span><br><span class="line"><span class="built_in">CMTime</span> decode = <span class="built_in">CMSampleBufferGetDecodeTimeStamp</span>(sampleBuffer); <span class="comment">// 获取帧样本的解码时间戳</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-附加元数据"><a href="#5-1-4-附加元数据" class="headerlink" title="5.1.4 附加元数据"></a>5.1.4 附加元数据</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFDictionaryRef</span> exif = (<span class="built_in">CFDictionaryRef</span>)<span class="built_in">CMGetAttachment</span>(sampleBuffer, kCGImagePropertyExifDictionary, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>CMAttachment.h 定义了 CMAttachment 形式的元数据协议，可以获取每一帧的底层元数据，如上述获取到图片 Exif 格式的元数据如下</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">ApertureValue</span> = <span class="string">"1.6959938131099"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">BrightnessValue</span> = <span class="string">"-8.636618904801434"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">ColorSpace</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">DateTimeDigitized</span> = <span class="string">"2018:04:24 14:17:33"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">DateTimeOriginal</span> = <span class="string">"2018:04:24 14:17:33"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">ExposureBiasValue</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">ExposureTime</span> = <span class="string">"0.05882352941176471"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">FNumber</span> = <span class="string">"1.8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">Flash</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">FocalLenIn35mmFilm</span> = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">FocalLength</span> = <span class="string">"3.99"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">ISOSpeedRatings</span> =     (</span><br><span class="line"></span><br><span class="line">        <span class="number">2000</span></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="attr">LensMake</span> = Apple;</span><br><span class="line"></span><br><span class="line">    <span class="attr">LensModel</span> = <span class="string">"iPhone 8 Plus back camera 3.99mm f/1.8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">LensSpecification</span> =     (</span><br><span class="line"></span><br><span class="line">        <span class="string">"3.99"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">"3.99"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">"1.8"</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">"1.8"</span></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="attr">MeteringMode</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">PixelXDimension</span> = <span class="number">1440</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">PixelYDimension</span> = <span class="number">1080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">SceneType</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">SensingMethod</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">ShutterSpeedValue</span> = <span class="string">"4.0608667208218"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">SubsecTimeDigitized</span> = <span class="number">067</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">SubsecTimeOriginal</span> = <span class="number">067</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">WhiteBalance</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-AVCaptureVideoDataOutput"><a href="#5-2-AVCaptureVideoDataOutput" class="headerlink" title="5.2 AVCaptureVideoDataOutput"></a>5.2 AVCaptureVideoDataOutput</h3><p>AVCaptureVideoDataOutput 的配置与 AVCaptureMovieFileOutput 大致相同，但要指明它的委托对象和回调队列。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.videoDataOutput = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line"><span class="keyword">self</span>.videoDataOutput.videoSettings = @&#123;(<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)&#125;; <span class="comment">// 摄像头的初始格式为双平面 420v，这是一个 YUV 格式，而 OpenGL ES 常用 BGRA 格式</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.videoDataOutput]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.videoDataOutput];</span><br><span class="line">    [<span class="keyword">self</span>.videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:dispatch_get_main_queue()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保视频帧按顺序传递，所以这里的队列要求必须是串行队列。</p>
]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation捕捉媒体</title>
    <url>/2018/04/18/AVFoundation/AVFoundation%E6%8D%95%E6%8D%89%E5%AA%92%E4%BD%93/</url>
    <content><![CDATA[<h2 id="1-捕捉功能综述"><a href="#1-捕捉功能综述" class="headerlink" title="1. 捕捉功能综述"></a>1. 捕捉功能综述</h2><ul>
<li>捕捉会话</li>
</ul>
<p>AVCaptureSession 用于连接输入和输出的资源，从物理设备如摄像头和麦克风等获取数据流，输出到一个或多个目的地。AVCaptureSession 可以额外配置一个会话预设值（session preset），用于控制捕捉数据的格式和质量，预设值默认值为 AVCaptureSessionPresetHigh。</p>
<ul>
<li>捕捉设备</li>
</ul>
<p>AVCaptureDevice 为物理设备定义统一接口，以及大量控制方法，获取指定类型的默认设备方法如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.activeVideoDevice = [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>捕捉设备的输入</li>
</ul>
<p>不能直接将 AVCaptureDevice 加入到 AVCaptureSession 中，需要封装为 AVCaptureDeviceInput。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.captureVideoInput = [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:<span class="keyword">self</span>.activeVideoDevice error:&amp;videoError];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.captureVideoInput) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddInput:<span class="keyword">self</span>.captureVideoInput])&#123;</span><br><span class="line">        [<span class="keyword">self</span>.captureSession addInput:<span class="keyword">self</span>.captureVideoInput];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (videoError) &#123;</span><br><span class="line">    [MTBProgressHUD showErrorWithStatus:<span class="string">@"视频输入接口配置失败，请检查摄像头功能是否正常"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>捕捉输出</li>
</ul>
<p>AVCaptureOutput 作为抽象基类提供了捕捉会话数据流的输出目的地，同时定义了此抽象类的高级扩展类。</p>
<ul>
<li><p>AVCaptureStillImageOutput - 静态照片</p>
</li>
<li><p>AVCaptureMovieFileOutput - 视频</p>
</li>
<li><p>AVCaptureAudioFileOutput - 音频</p>
</li>
<li><p>AVCaptureAudioDataOutput - 音频底层数字样本</p>
</li>
<li><p>AVCaptureVideoDataOutput - 视频底层数字样本</p>
</li>
<li><p>捕捉连接</p>
</li>
</ul>
<p>AVCaptureConnection 用于确定哪些输入产生视频，哪些输入产生音频，能够禁用特定连接或访问单独的音频轨道。</p>
<ul>
<li>捕捉预览</li>
</ul>
<p>AVCaptureVideoPreviewLayer 是一个 CALayer 的子类，可以对捕捉视频数据进行实时预览。</p>
<h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><h3 id="2-1-创建预览视图"><a href="#2-1-创建预览视图" class="headerlink" title="2.1 创建预览视图"></a>2.1 创建预览视图</h3><p>可以直接向一个 view 的 layer 中加入一个 AVCaptureVideoPreviewLayer 对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.previewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.previewLayer setVideoGravity:<span class="built_in">AVLayerVideoGravityResizeAspectFill</span>];</span><br><span class="line">[<span class="keyword">self</span>.previewLayer setSession:<span class="keyword">self</span>.cameraHelper.captureSession];</span><br><span class="line"><span class="keyword">self</span>.previewLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, SCREEN_WIDTH, SCREEN_HEIGHT - <span class="number">50</span>);</span><br><span class="line">[<span class="keyword">self</span>.previewImageView.layer addSublayer:<span class="keyword">self</span>.previewLayer];</span><br></pre></td></tr></table></figure>

<p>也可以通过 view 的类方法直接换掉 view 的 clayer 实例</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="built_in">AVCaptureVideoPreviewLayer</span> <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">AVCaptureSession</span>*)session &#123;</span><br><span class="line">	<span class="keyword">return</span> [(<span class="built_in">AVCaptureVideoPreviewLayer</span>*)<span class="keyword">self</span>.layer session];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSession:(<span class="built_in">AVCaptureSession</span> *)session &#123;</span><br><span class="line">	[(<span class="built_in">AVCaptureVideoPreviewLayer</span>*)<span class="keyword">self</span>.layer setSession:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-坐标转换"><a href="#2-1-1-坐标转换" class="headerlink" title="2.1.1 坐标转换"></a>2.1.1 坐标转换</h4><p>AVCaptureVideoPreviewLayer 定义了两个方法用于在屏幕坐标系和设备坐标系之间转换，设备坐标系规定左上角为 （0，0），右下角为（1，1）。</p>
<ul>
<li>(CGPoint)captureDevicePointOfInterestForPoint:(CGPoint)pointInLayer 从屏幕坐标系的点转换为设备坐标系</li>
<li>(CGPoint)pointForCaptureDevicePointOfInterest:(CGPoint)captureDevicePointOfInterest 从设备坐标系的点转换为屏幕坐标系</li>
</ul>
<h3 id="2-2-设置捕捉会话"><a href="#2-2-设置捕捉会话" class="headerlink" title="2.2 设置捕捉会话"></a>2.2 设置捕捉会话</h3><p>首先是初始化捕捉会话</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.captureSession = [[<span class="built_in">AVCaptureSession</span> alloc]init];</span><br><span class="line">[<span class="keyword">self</span>.captureSession setSessionPreset:(<span class="keyword">self</span>.isVideoMode)?<span class="built_in">AVCaptureSessionPreset1280x720</span>:<span class="built_in">AVCaptureSessionPresetPhoto</span>];</span><br></pre></td></tr></table></figure>

<p>根据拍摄视频还是拍摄照片选择不同的预设值，然后设置会话输入。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configSessionInput</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 摄像头输入</span></span><br><span class="line">    <span class="built_in">NSError</span> *videoError = [[<span class="built_in">NSError</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.activeVideoDevice = [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">    <span class="keyword">self</span>.flashMode = <span class="keyword">self</span>.activeVideoDevice.flashMode;</span><br><span class="line">    <span class="keyword">self</span>.captureVideoInput = [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:<span class="keyword">self</span>.activeVideoDevice error:&amp;videoError];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.captureVideoInput) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddInput:<span class="keyword">self</span>.captureVideoInput])&#123;</span><br><span class="line">            [<span class="keyword">self</span>.captureSession addInput:<span class="keyword">self</span>.captureVideoInput];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (videoError) &#123;</span><br><span class="line">        [MTBProgressHUD showErrorWithStatus:<span class="string">@"视频输入接口配置失败，请检查摄像头功能是否正常"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isVideoMode) &#123;</span><br><span class="line">        <span class="comment">// 麦克风输入</span></span><br><span class="line">        <span class="built_in">NSError</span> *audioError = [[<span class="built_in">NSError</span> alloc] init];</span><br><span class="line">        <span class="built_in">AVCaptureDeviceInput</span> *audioInput = [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:[<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] error:&amp;audioError];</span><br><span class="line">        <span class="keyword">if</span> (audioInput) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddInput:audioInput]) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.captureSession addInput:audioInput];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioError) &#123;</span><br><span class="line">            [MTBProgressHUD showErrorWithStatus:<span class="string">@"音频输入接口配置失败，请检查麦克风功能是否正常"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对摄像头和麦克风设备均封装为 AVCaptureDeviceInput 后加入到会话中。</p>
<p>然后配置会话输出。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configSessionOutput</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isVideoMode) &#123;</span><br><span class="line">        <span class="comment">// 视频输出</span></span><br><span class="line">        <span class="keyword">self</span>.movieFileOutput = [[<span class="built_in">AVCaptureMovieFileOutput</span> alloc] init];</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.movieFileOutput]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.movieFileOutput];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 图片输出</span></span><br><span class="line">        <span class="keyword">self</span>.imageOutput = [[<span class="built_in">AVCaptureStillImageOutput</span> alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.imageOutput.outputSettings = @&#123;<span class="built_in">AVVideoCodecKey</span>:<span class="built_in">AVVideoCodecJPEG</span>&#125;;<span class="comment">// 配置 outputSetting 属性，表示希望捕捉 JPEG 格式的图片</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.imageOutput]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.imageOutput];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-启动和停止会话"><a href="#2-3-启动和停止会话" class="headerlink" title="2.3 启动和停止会话"></a>2.3 启动和停止会话</h3><p>可以在一个 VC 的生命周期内启动和停止会话</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startSession &#123;</span><br><span class="line">	<span class="keyword">if</span> (![<span class="keyword">self</span>.captureSession isRunning]) &#123;                                 <span class="comment">// 1</span></span><br><span class="line">		<span class="built_in">dispatch_async</span>([<span class="keyword">self</span> globalQueue], ^&#123;</span><br><span class="line">			[<span class="keyword">self</span>.captureSession startRunning];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopSession &#123;</span><br><span class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession isRunning]) &#123;                                  <span class="comment">// 2</span></span><br><span class="line">		<span class="built_in">dispatch_async</span>([<span class="keyword">self</span> globalQueue], ^&#123;</span><br><span class="line">			[<span class="keyword">self</span>.captureSession stopRunning];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这个操作是比较耗时的同步操作，因此建议在异步线程里执行此方法。</p>
<h3 id="2-4-权限请求"><a href="#2-4-权限请求" class="headerlink" title="2.4 权限请求"></a>2.4 权限请求</h3><p>如果没有获取到相机和麦克风权限，在设置 captureVideoInput 时就会出错。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 检测 AVAuthorization 权限</span></span><br><span class="line"><span class="comment">/// 传入待检查的 AVMediaType，AVMediaTypeVideo or AVMediaTypeAudio</span></span><br><span class="line"><span class="comment">/// 返回是否权限可用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)ifAVAuthorizationValid:(<span class="built_in">NSString</span> *)targetAVMediaType grantedCallback:(<span class="keyword">void</span> (^)())grantedCallback</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *mediaType = targetAVMediaType;</span><br><span class="line">    <span class="built_in">BOOL</span> result = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">AVCaptureDevice</span> respondsToSelector:<span class="keyword">@selector</span>(authorizationStatusForMediaType:)]) &#123;</span><br><span class="line">        <span class="built_in">AVAuthorizationStatus</span> authStatus = [<span class="built_in">AVCaptureDevice</span> authorizationStatusForMediaType:mediaType];</span><br><span class="line">        <span class="keyword">switch</span> (authStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">AVAuthorizationStatusNotDetermined</span>: &#123; <span class="comment">// 尚未请求授权</span></span><br><span class="line">                [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:targetAVMediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        <span class="keyword">if</span> (granted) &#123;</span><br><span class="line">                            grantedCallback();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">AVAuthorizationStatusDenied</span>: &#123; <span class="comment">// 明确拒绝</span></span><br><span class="line">                <span class="keyword">if</span> ([mediaType isEqualToString:<span class="built_in">AVMediaTypeVideo</span>]) &#123;</span><br><span class="line">                    [METSettingPermissionAlertView showAlertViewWithPermissionType:METSettingPermissionTypeCamera];<span class="comment">// 申请相机权限</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([mediaType isEqualToString:<span class="built_in">AVMediaTypeAudio</span>]) &#123;</span><br><span class="line">                    [METSettingPermissionAlertView showAlertViewWithPermissionType:METSettingPermissionTypeMicrophone];<span class="comment">// 申请麦克风权限</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">AVAuthorizationStatusRestricted</span>: &#123; <span class="comment">// 限制权限更改</span></span><br><span class="line">                [MTBToastMarker makeToast:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"无法获取%@权限，请检查\"设置-&gt;通用-&gt;访问限制\"是否禁止了%@的权限更改，并重启应用程序"</span>, [mediaType isEqualToString:<span class="built_in">AVMediaTypeVideo</span>] ? <span class="string">@"相机"</span>:<span class="string">@"麦克风"</span>, [mediaType isEqualToString:<span class="built_in">AVMediaTypeVideo</span>] ? <span class="string">@"相机"</span>:<span class="string">@"麦克风"</span>]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">AVAuthorizationStatusAuthorized</span>: &#123; <span class="comment">// 已授权</span></span><br><span class="line">                result = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">// 兜底</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用这个方法对各种情况进行相应逻辑处理，避免没有权限导致的应用异常，同时由于用户随时可以在后台更改权限设置，应该每次启动相机前进行权限判断。</p>
<h3 id="2-5-切换摄像头"><a href="#2-5-切换摄像头" class="headerlink" title="2.5 切换摄像头"></a>2.5 切换摄像头</h3><p>大多数 ios 设备都有前后两个摄像头，标识前后摄像头需要用到 AVCaptureDevicePosition 枚举类</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">AVCaptureDevicePosition</span>) &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevicePositionUnspecified</span> = <span class="number">0</span>, <span class="comment">// 未知</span></span><br><span class="line">    <span class="built_in">AVCaptureDevicePositionBack</span>        = <span class="number">1</span>, <span class="comment">// 后置摄像头</span></span><br><span class="line">    <span class="built_in">AVCaptureDevicePositionFront</span>       = <span class="number">2</span>, <span class="comment">// 前置摄像头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切换摄像头前首先要判断能否切换</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canSwitchCameras &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count] &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来获取当前活跃的设备</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">AVCaptureDevice</span> *)activeCamera &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.activeVideoInput.device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 AVCaptureDeviceInput 就可以获取到当前活跃的 device，然后找到与其相对的设备</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">AVCaptureDevice</span> *)cameraWithPosition:(<span class="built_in">AVCaptureDevicePosition</span>)position &#123; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;                              <span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">if</span> (device.position == position) &#123;</span><br><span class="line">			<span class="keyword">return</span> device;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到对应的 device 后就可以封装为 AVCaptureInput 对象，然后进行配置</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.captureSession beginConfiguration];<span class="comment">// 开始配置新的视频输入</span></span><br><span class="line">[<span class="keyword">self</span>.captureSession removeInput:<span class="keyword">self</span>.captureVideoInput]; <span class="comment">// 首先移除旧的 input，才能加入新的 input</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddInput:newInput]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addInput:newInput];</span><br><span class="line">    <span class="keyword">self</span>.activeVideoDevice = newActiveDevice;</span><br><span class="line">    <span class="keyword">self</span>.captureVideoInput = newInput;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addInput:<span class="keyword">self</span>.captureVideoInput];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.captureSession commitConfiguration];</span><br></pre></td></tr></table></figure>

<p>这里 beginConfiguration 和 commitConfiguration 可以使修改操作成为原子性操作，保证设备运行安全。</p>
<h3 id="2-6-调整焦距和曝光"><a href="#2-6-调整焦距和曝光" class="headerlink" title="2.6 调整焦距和曝光"></a>2.6 调整焦距和曝光</h3><p>这里主要关注对于设置操作的测试以及对设置过程的加锁解锁。</p>
<ul>
<li>对焦</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)cameraSupportsTapToFocus &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.activeVideoInput.device isFocusPointOfInterestSupported];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)focusAtPoint:(<span class="built_in">CGPoint</span>)point &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="keyword">self</span>.activeVideoInput.device;</span><br><span class="line">    <span class="keyword">if</span> (device.isFocusPointOfInterestSupported &amp;&amp;</span><br><span class="line">        [device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeAutoFocus</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">            device.focusPointOfInterest = point;</span><br><span class="line">            device.focusMode = <span class="built_in">AVCaptureFocusModeAutoFocus</span>;</span><br><span class="line">            [device unlockForConfiguration];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isFocusPointOfInterestSupported 用于判断设备是否支持兴趣点对焦，isFocusModeSupported 判断是否支持某种对焦模式，AVCaptureFocusModeAutoFocus 即自动对焦，然后进行对焦设置。</p>
<ul>
<li>曝光</li>
</ul>
<p>曝光与对焦非常类似，核心方法如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.activeVideoDevice setExposurePointOfInterest:focusPoint];</span><br><span class="line">[<span class="keyword">self</span>.activeVideoDevice setExposureMode:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>];</span><br></pre></td></tr></table></figure>

<h3 id="2-7-调整闪光灯和手电筒模式"><a href="#2-7-调整闪光灯和手电筒模式" class="headerlink" title="2.7 调整闪光灯和手电筒模式"></a>2.7 调整闪光灯和手电筒模式</h3><p>闪光灯（flash）和手电筒（torch）是两个不同的模式，分别定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, AVCaptureFlashMode) &#123;</span><br><span class="line">    AVCaptureFlashModeOff  &#x3D; 0,</span><br><span class="line">    AVCaptureFlashModeOn   &#x3D; 1,</span><br><span class="line">    AVCaptureFlashModeAuto &#x3D; 2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, AVCaptureTorchMode) &#123;</span><br><span class="line">    AVCaptureTorchModeOff  &#x3D; 0,</span><br><span class="line">    AVCaptureTorchModeOn   &#x3D; 1,</span><br><span class="line">    AVCaptureTorchModeAuto &#x3D; 2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在拍照时需要设置闪光灯，而拍视频时需要设置手电筒。具体配置模式代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)cameraHasFlash &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> activeCamera] hasFlash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">AVCaptureFlashMode</span>)flashMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> activeCamera] flashMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFlashMode:(<span class="built_in">AVCaptureFlashMode</span>)flashMode &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = [<span class="keyword">self</span> activeCamera];</span><br><span class="line">    <span class="keyword">if</span> (device.flashMode != flashMode &amp;&amp;</span><br><span class="line">        [device isFlashModeSupported:flashMode]) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">            device.flashMode = flashMode;</span><br><span class="line">            [device unlockForConfiguration];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)cameraHasTorch &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> activeCamera] hasTorch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">AVCaptureTorchMode</span>)torchMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> activeCamera] torchMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTorchMode:(<span class="built_in">AVCaptureTorchMode</span>)torchMode &#123;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = [<span class="keyword">self</span> activeCamera];</span><br><span class="line">    <span class="keyword">if</span> (device.torchMode != torchMode &amp;&amp;</span><br><span class="line">        [device isTorchModeSupported:torchMode]) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">            device.torchMode = torchMode;</span><br><span class="line">            [device unlockForConfiguration];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-拍摄静态图片"><a href="#2-8-拍摄静态图片" class="headerlink" title="2.8 拍摄静态图片"></a>2.8 拍摄静态图片</h3><p>设置捕捉会话时我们将 AVCaptureStillImageOutput 实例加入到会话中，这个会话可以用来拍摄静态图片。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *connection = [<span class="keyword">self</span>.cameraHelper.imageOutput connectionWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="keyword">if</span> ([connection isVideoOrientationSupported]) &#123;</span><br><span class="line">    [connection setVideoOrientation:<span class="keyword">self</span>.cameraHelper.videoOrientation];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!connection.enabled || !connection.isActive) &#123; <span class="comment">// connection 不可用</span></span><br><span class="line">    <span class="comment">// 处理非法情况</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里从 AVCaptureStillImageOutput 实例类中获取到一个 AVCaptureConnection 对象后，需要设置此 connection 的 orientation 值，有两种方法可以获取。</p>
<ul>
<li>通过监听重力感应器修改 orientation</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监测重力感应器并调整 orientation</span></span><br><span class="line"><span class="built_in">CMMotionManager</span> *motionManager = [[<span class="built_in">CMMotionManager</span> alloc] init];</span><br><span class="line">motionManager.deviceMotionUpdateInterval = <span class="number">1</span>/<span class="number">15.0</span>;</span><br><span class="line"><span class="keyword">if</span> (motionManager.deviceMotionAvailable) &#123;</span><br><span class="line">    [motionManager startDeviceMotionUpdatesToQueue:[<span class="built_in">NSOperationQueue</span> currentQueue]</span><br><span class="line">                                       withHandler: ^(<span class="built_in">CMDeviceMotion</span> *motion, <span class="built_in">NSError</span> *error)&#123;</span><br><span class="line">                                           <span class="keyword">double</span> x = motion.gravity.x;</span><br><span class="line">                                           <span class="keyword">double</span> y = motion.gravity.y;</span><br><span class="line">                                           <span class="keyword">if</span> (fabs(y) &gt;= fabs(x)) &#123; <span class="comment">// y 轴分量大于 x 轴</span></span><br><span class="line">                                               <span class="keyword">if</span> (y &gt;= <span class="number">0</span>) &#123; <span class="comment">// 顶部向下</span></span><br><span class="line">                                                   <span class="keyword">self</span>.videoOrientation = <span class="built_in">AVCaptureVideoOrientationPortraitUpsideDown</span>; <span class="comment">// UIDeviceOrientationPortraitUpsideDown;</span></span><br><span class="line">                                               &#125; <span class="keyword">else</span> &#123; <span class="comment">// 顶部向上</span></span><br><span class="line">                                                   <span class="keyword">self</span>.videoOrientation = <span class="built_in">AVCaptureVideoOrientationPortrait</span>; <span class="comment">// UIDeviceOrientationPortrait;</span></span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                               <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123; <span class="comment">// 顶部向右</span></span><br><span class="line">                                                   <span class="keyword">self</span>.videoOrientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>; <span class="comment">// UIDeviceOrientationLandscapeRight;</span></span><br><span class="line">                                               &#125; <span class="keyword">else</span> &#123; <span class="comment">// 顶部向左</span></span><br><span class="line">                                                   <span class="keyword">self</span>.videoOrientation = <span class="built_in">AVCaptureVideoOrientationLandscapeRight</span>; <span class="comment">// UIDeviceOrientationLandscapeLeft;</span></span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;];</span><br><span class="line">    <span class="keyword">self</span>.motionManager = motionManager;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.videoOrientation = <span class="built_in">AVCaptureVideoOrientationPortrait</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意这里一些枚举量的名称，AVCaptureVideoOrientationLandscapeLeft 表示 home 键在左，AVCaptureVideoOrientationLandscapeRight 表示 home 键在右。</p>
<ul>
<li>通过 UIDevice 获取</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoOrientation</span> orientation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ([<span class="built_in">UIDevice</span> currentDevice].orientation) &#123;                         <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationPortrait</span>:</span><br><span class="line">        orientation = <span class="built_in">AVCaptureVideoOrientationPortrait</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationLandscapeRight</span>:</span><br><span class="line">        orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>:</span><br><span class="line">        orientation = <span class="built_in">AVCaptureVideoOrientationPortraitUpsideDown</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeRight</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> orientation;</span><br></pre></td></tr></table></figure>

<p>这里也要注意，UIDeviceOrientationLandscapeRight 表示 home 键在左，UIDeviceOrientationLandscapeLeft 表示 home 键在右。</p>
<p>最终调用方法来获取 CMSampleBufferRef,CMSampleBufferRef 是一个 Core Media 定义的 Core Foundation 对象，可以通过 AVCaptureStillImageOutput 的 jpegStillImageNSDataRepresentation 类方法将其转化为 NSData 类型。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>)</span><br><span class="line">[<span class="keyword">self</span>.cameraHelper.imageOutput captureStillImageAsynchronouslyFromConnection:connection completionHandler:^(<span class="built_in">CMSampleBufferRef</span> imageDataSampleBuffer, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; imageDataSampleBuffer) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *imageData = [<span class="built_in">AVCaptureStillImageOutput</span> jpegStillImageNSDataRepresentation:imageDataSampleBuffer];</span><br><span class="line">        <span class="keyword">if</span> (!imageData) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">        <span class="keyword">if</span> (!image) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="2-9-保存图片"><a href="#2-9-保存图片" class="headerlink" title="2.9 保存图片"></a>2.9 保存图片</h3><p>《AVFoundation 开发秘籍》介绍的 Assets Library 在 ios 8 以后已经被 Photo Library 替代，这里用 Photo Library 实现保存图片的功能。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;</span><br><span class="line">    PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:targetImage];</span><br><span class="line">    <span class="built_in">NSString</span> *imageIdentifier = changeRequest.placeholderForCreatedAsset.localIdentifier;</span><br><span class="line">&#125; completionHandler:^( <span class="built_in">BOOL</span> success, <span class="built_in">NSError</span> * _Nullable error ) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>可以通过保存时返回的 imageIdentifier 从相册里找到这个图片。</p>
<h3 id="2-10-视频捕捉"><a href="#2-10-视频捕捉" class="headerlink" title="2.10 视频捕捉"></a>2.10 视频捕捉</h3><p>QuickTime 格式的影片，元数据处于影片文件的开头位置，这样可以帮助视频播放器快速读取头文件来确定文件内容、结构和样本位置，但是录制时需要等所有样本捕捉完成才能创建头数据并将其附在文件结尾处。这样一来，如果录制时发生崩溃或中断就会导致无法创建影片头，从而在磁盘生成一个不可读的文件。</p>
<p>因此 AVFoundation 的 AVCaptureMovieFileOutput 类就提供了分段捕捉能力，录制开始时生成最小化的头信息，录制进行中，片段间隔一定周期再次创建头信息，从而逐步完成创建。默认状态下每 10s 写入一个片段，可以通过 movieFragmentInterval 属性来修改。</p>
<p>首先是开启视频拍摄</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *videoConnection = [<span class="keyword">self</span>.cameraHelper.movieFileOutput connectionWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="keyword">if</span> ([videoConnection isVideoOrientationSupported]) &#123;</span><br><span class="line">    [videoConnection setVideoOrientation:<span class="keyword">self</span>.cameraHelper.videoOrientation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([videoConnection isVideoStabilizationSupported]) &#123;</span><br><span class="line">    [videoConnection setPreferredVideoStabilizationMode:<span class="built_in">AVCaptureVideoStabilizationModeAuto</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[videoConnection setVideoScaleAndCropFactor:<span class="number">1.0</span>];</span><br><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span>.cameraHelper.movieFileOutput isRecording] &amp;&amp; videoConnection.isActive &amp;&amp; videoConnection.isEnabled) &#123;</span><br><span class="line">    <span class="comment">// 判断视频连接是否可用</span></span><br><span class="line">    <span class="keyword">self</span>.countTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(refreshTimeLabel) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *urlString = [<span class="built_in">NSTemporaryDirectory</span>() stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.0f.mov"</span>, [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000</span>]];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:urlString];</span><br><span class="line">    [<span class="keyword">self</span>.cameraHelper.movieFileOutput startRecordingToOutputFileURL:url recordingDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span>.captureButton setTitle:<span class="string">@"结束"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [MTBProgressHUD showErrorWithStatus:<span class="string">@"视频连接不可用"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置 PreferredVideoStabilizationMode 可以支持视频拍摄时的稳定性和拍摄质量，但是这一稳定效果只会在拍摄的视频中感受到，预览视频时无法感知。</p>
<p>我们将视频文件临时写入到临时文件中，等待拍摄结束时会调用 AVCaptureFileOutputRecordingDelegate 的 <code>(void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error</code> 方法。此时可以进行保存视频和生成视频缩略图的操作。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)saveVideo:(<span class="built_in">NSURL</span> *)videoURL</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *imageIdentifier;</span><br><span class="line">    @weakify(<span class="keyword">self</span>)</span><br><span class="line">    [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^&#123;</span><br><span class="line">        <span class="comment">// 保存视频</span></span><br><span class="line">        PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromVideoAtFileURL:videoURL];</span><br><span class="line">        imageIdentifier = changeRequest.placeholderForCreatedAsset.localIdentifier;</span><br><span class="line">    &#125; completionHandler:^( <span class="built_in">BOOL</span> success, <span class="built_in">NSError</span> * _Nullable error ) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>)</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>)</span><br><span class="line">            [MTBProgressHUD dismiss];</span><br><span class="line">            [<span class="keyword">self</span> resetTimeCounter];</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// 错误处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PHAsset *asset = [PHAsset fetchAssetsWithLocalIdentifiers:@[imageIdentifier] options:<span class="literal">nil</span>].firstObject;</span><br><span class="line">                <span class="keyword">if</span> (asset &amp;&amp; asset.mediaType == PHAssetMediaTypeVideo) &#123;</span><br><span class="line">                    PHVideoRequestOptions *options = [[PHVideoRequestOptions alloc] init];</span><br><span class="line">                    options.version = PHImageRequestOptionsVersionCurrent;</span><br><span class="line">                    options.deliveryMode = PHVideoRequestOptionsDeliveryModeAutomatic;</span><br><span class="line">                    [[PHImageManager defaultManager] requestAVAssetForVideo:asset options:options resultHandler:^(<span class="built_in">AVAsset</span> * _Nullable obj, <span class="built_in">AVAudioMix</span> * _Nullable audioMix, <span class="built_in">NSDictionary</span> * _Nullable info) &#123;</span><br><span class="line">                        @strongify(<span class="keyword">self</span>)</span><br><span class="line">                        [<span class="keyword">self</span> resolveAVAsset:obj identifier:asset.localIdentifier];</span><br><span class="line">                    &#125;];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)resolveAVAsset:(<span class="built_in">AVAsset</span> *)asset identifier:(<span class="built_in">NSString</span> *)identifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!asset) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![asset isKindOfClass:[<span class="built_in">AVURLAsset</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AVURLAsset</span> *urlAsset = (<span class="built_in">AVURLAsset</span> *)asset;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = urlAsset.URL;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AVAssetImageGenerator</span> *generator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:asset];</span><br><span class="line">    generator.appliesPreferredTrackTransform = <span class="literal">YES</span>; <span class="comment">//捕捉缩略图时考虑视频 orientation 变化，避免错误的缩略图方向</span></span><br><span class="line">    <span class="built_in">CMTime</span> snaptime = kCMTimeZero;</span><br><span class="line">    <span class="built_in">CGImageRef</span> cgImageRef = [generator copyCGImageAtTime:snaptime actualTime:<span class="literal">NULL</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">UIImage</span> *assetImage = [<span class="built_in">UIImage</span> imageWithCGImage:cgImageRef];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgImageRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS传感器与CMMotionManager</title>
    <url>/2018/04/18/iOS%E5%BC%80%E5%8F%91/iOS%E4%BC%A0%E6%84%9F%E5%99%A8%E4%B8%8ECMMotionManager/</url>
    <content><![CDATA[<p>iOS 中常见传感器如下所示</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>环境光传感器</td>
<td>感应光照强度</td>
</tr>
<tr>
<td>距离传感器</td>
<td>感应靠近设备屏幕的物体</td>
</tr>
<tr>
<td>磁力计传感器</td>
<td>感应周边磁场</td>
</tr>
<tr>
<td>内部温度传感器</td>
<td>感应设备内部温度（非公开）</td>
</tr>
<tr>
<td>湿度传感器</td>
<td>感应设备是否进水（非微电子传感器）</td>
</tr>
<tr>
<td>陀螺仪</td>
<td>感应持握方式</td>
</tr>
<tr>
<td>加速计</td>
<td>感应设备运动</td>
</tr>
</tbody></table>
<p>其中陀螺仪、加速计和磁力计的数据获取均依赖于 CMMotionManager。</p>
<h2 id="CMMotionManager"><a href="#CMMotionManager" class="headerlink" title="CMMotionManager"></a>CMMotionManager</h2><p>CMMotionManager 是 Core Motion 库的核心类，负责获取和处理手机的运动信息，它可以获取的数据有</p>
<ul>
<li>加速度，标识设备在三维空间中的瞬时加速度</li>
<li>陀螺仪，标识设备在三个主轴上的瞬时旋转</li>
<li>磁场信息，标识设备相对于地球磁场的方位</li>
<li>设备运动数据，标识关键的运动相关属性，包括设备用户引起的加速度、姿态、旋转速率、相对于校准磁场的方位以及相对于重力的方位等，这些数据均来自于 Core Motion 的传感器融合算法，从这一个数据接口即可获取以上三种数据，因此使用较为广泛</li>
</ul>
<p>CMMotionManager 有 “push” 和 “pull” 两种方式获取数据，push 方式实时获取数据，采样频率高，pull 方式仅在需要数据时采集数据，Apple 更加推荐这种方式获取数据。</p>
<h3 id="push-方式"><a href="#push-方式" class="headerlink" title="push 方式"></a>push 方式</h3><p>将 CMMotionManager 采集频率 interval 设置好以后，CMMotionManager 会在一个操作队列里从特定的 block 返回实时数据更新，这里以设备运动数据 DeviceMotion 为例，代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CMMotionManager</span> *motionManager = [[<span class="built_in">CMMotionManager</span> alloc] init];</span><br><span class="line">motionManager.deviceMotionUpdateInterval = <span class="number">1</span>/<span class="number">15.0</span>;</span><br><span class="line"><span class="keyword">if</span> (motionManager.deviceMotionAvailable) &#123;</span><br><span class="line">    [motionManager startDeviceMotionUpdatesToQueue:[<span class="built_in">NSOperationQueue</span> currentQueue]</span><br><span class="line">                                       withHandler: ^(<span class="built_in">CMDeviceMotion</span> *motion, <span class="built_in">NSError</span> *error)&#123;</span><br><span class="line">                                           <span class="keyword">double</span> x = motion.gravity.x;</span><br><span class="line">                                           <span class="keyword">double</span> y = motion.gravity.y;</span><br><span class="line">                                           <span class="keyword">double</span> z = motion.gravity.z;</span><br><span class="line">                                           <span class="comment">//NSLog(@"roll:%f, pitch:%f, yew:%f", motion.attitude.roll, motion.attitude.pitch, motion.attitude.yaw);</span></span><br><span class="line">                                           <span class="built_in">NSLog</span>(<span class="string">@"x:%f, y:%f, z:%f"</span>, x, y, z);</span><br><span class="line">                                       &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要注意尽可能在 app 中只创建一个 CMMotionManager 对象，多个 CMMotionManager 对象会影响从加速计和陀螺仪接受数据的速率。其次，在启动接收设备传感器信息前要检查传感器是否硬件可达，可以用<br>deviceMotionAvailable 检测硬件是否正常，用 deviceMotionActive 检测当前 CMMotionManager 是否正在提供数据更新。</p>
<p>暂停更新也很容易，直接调用 stopXXXUpdates 即可。</p>
<h3 id="pull-方式"><a href="#pull-方式" class="headerlink" title="pull 方式"></a>pull 方式</h3><p>仍以 DevideMotion 为例，pull 方式代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CMMotionManager</span> *motionManager = [[<span class="built_in">CMMotionManager</span> alloc] init];</span><br><span class="line">motionManager.deviceMotionUpdateInterval = <span class="number">1</span>/<span class="number">15.0</span>;</span><br><span class="line"><span class="keyword">if</span> (motionManager.deviceMotionAvailable) &#123;</span><br><span class="line">    [motionManager startDeviceMotionUpdates];</span><br><span class="line">    <span class="keyword">double</span> x = motionManager.deviceMotion.gravity.x;</span><br><span class="line">    <span class="keyword">double</span> y = motionManager.deviceMotion.gravity.y;</span><br><span class="line">    <span class="keyword">double</span> z = motionManager.deviceMotion.gravity.z;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"x:%f, y:%f, z:%f"</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的方式获取的数据实时性不高，第一次获取可能没有数据，同时要注意不能过于频繁的获取，否则可能引起崩溃。</p>
<p>下面是 CMMotionManager 监听的各类运动信息的简单描述。首先需要明确，iOS 设备的运动传感器使用了如下的坐标系</p>
<img src="http://blog.denivip.ru/wp-content/uploads/2013/07/CoreMotionAxes.png" width=500>

<p>而 DeviceMotion 信息具体对应 iOS 中的 CMDeviceMotion 类，它包含的数据有</p>
<h4 id="1-attitude"><a href="#1-attitude" class="headerlink" title="1. attitude"></a>1. attitude</h4><p>attitude 用于标识空间位置的欧拉角（roll、yaw、pitch）和四元数（quaternion）</p>
<img src="http://blog.denivip.ru/wp-content/uploads/2013/07/CoreMotionRotationAxes.png" width=500>

<p>其中绕 x 轴运动称作 pitch（俯仰），绕 y 轴运动称作 roll（滚转），绕 z 轴运动称作 yaw（偏航）。</p>
<p>当设备正面向上、顶部指向正北、水平放置时，pitch、yaw 和 roll 值均为 0，其他变化如下</p>
<ul>
<li>设备顶部上扬，pitch 由 0 递增 pi/2，顶部下沉，由 0 递减 pi/2</li>
<li>设备顶部左偏 180 度范围内，yaw 由 0 递增 pi，右偏递减</li>
<li>设备左部上旋，roll 由 0 递增 pi，左部下旋，roll 由 0 递减</li>
</ul>
<h4 id="2-rotationRate"><a href="#2-rotationRate" class="headerlink" title="2. rotationRate"></a>2. rotationRate</h4><p>rotationRate 标识设备旋转速率，具体变化如下</p>
<ul>
<li>pitch 增加，x &gt; 0，pictch 减少，x &lt; 0</li>
<li>roll 增加，y &gt; 0，row 减少，y &lt; 0</li>
<li>yaw 增加，z &gt; 0，yaw 减少，z &lt; 0</li>
</ul>
<h4 id="3-gravity"><a href="#3-gravity" class="headerlink" title="3. gravity"></a>3. gravity</h4><p>gravity 用于标识重力在设备各个方向的分量，具体值的变化遵循如下规律：重力方向始终指向地球，而在设备的三个方向上有不同分量，最大可达 1.0，最小是 0.0。</p>
<p>其中设备顶部向上时 y 轴分量为负数，向下为正数。设备顶部向右时 x 轴分量为正数，向左时 x 轴分量为负数。</p>
<h4 id="4-userAcceleration"><a href="#4-userAcceleration" class="headerlink" title="4. userAcceleration"></a>4. userAcceleration</h4><p>userAcceleration 用于标识设备各个方向上的加速度，注意是加速度值，可以标识当前设备正在当前方向上减速 or 加速。</p>
<h4 id="5-magneticField-amp-heading"><a href="#5-magneticField-amp-heading" class="headerlink" title="5. magneticField &amp; heading"></a>5. magneticField &amp; heading</h4><p>magneticField 用于标识设备周围的磁场范围和精度，heading 用于标识北极方向。但是要注意，这两个值的检测需要指定 ReferenceFrame，它是一个 CMAttitudeReferenceFrame 的枚举，有四个值</p>
<ul>
<li>CMAttitudeReferenceFrameXArbitraryZVertical</li>
<li>CMAttitudeReferenceFrameXArbitraryCorrectedZVertical</li>
<li>CMAttitudeReferenceFrameXMagneticNorthZVertical</li>
<li>CMAttitudeReferenceFrameXTrueNorthZVertical</li>
</ul>
<p>其中前两个 frame 下磁性返回非法负值，只有选择了 CMAttitudeReferenceFrameXMagneticNorthZVertical 或 CMAttitudeReferenceFrameXTrueNorthZVertical 才有有效值，这两个枚举分别指代磁性北极和地理北极。</p>
<h2 id="距离传感器"><a href="#距离传感器" class="headerlink" title="距离传感器"></a>距离传感器</h2><p>距离传感器可以检测有物理在靠近或者远离屏幕，使用如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">    [<span class="built_in">UIDevice</span> currentDevice].proximityMonitoringEnabled = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(proximityStateDidChange:) name:<span class="built_in">UIDeviceProximityStateDidChangeNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)proximityStateDidChange:(<span class="built_in">NSNotification</span> *)note</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].proximityState) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Coming"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Leaving"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环境光传感器"><a href="#环境光传感器" class="headerlink" title="环境光传感器"></a>环境光传感器</h2><p>目前没有找到相应的 API，可以采取的思路是通过摄像头获取每一帧，进行光线强度检测</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">AVCaptureStillImageOutput</span> jpegStillImageNSDataRepresentation:imageDataSampleBuffer];</span><br><span class="line"><span class="built_in">CFDictionaryRef</span> metadataDict = <span class="built_in">CMCopyDictionaryOfAttachments</span>(<span class="literal">NULL</span>, imageDataSampleBuffer, kCMAttachmentMode_ShouldPropagate);</span><br><span class="line"><span class="built_in">NSDictionary</span> *metadata = [[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:(__bridge <span class="built_in">NSDictionary</span>*)metadataDict];</span><br><span class="line"><span class="built_in">CFRelease</span>(metadataDict);</span><br><span class="line"><span class="built_in">NSDictionary</span> *exifMetadata = [[metadata objectForKey:(<span class="built_in">NSString</span> *) kCGImagePropertyExifDictionary] mutableCopy];</span><br><span class="line"><span class="keyword">float</span> brightnessValue = [[exifMetadata  objectForKey:(<span class="built_in">NSString</span> *) kCGImagePropertyExifBrightnessValue] floatValue];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,brightnessValue);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title>AVFoundation视频播放</title>
    <url>/2018/04/17/AVFoundation/AVFoundation%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<h2 id="1-播放视频综述"><a href="#1-播放视频综述" class="headerlink" title="1. 播放视频综述"></a>1. 播放视频综述</h2><p>AVFoundation 对于播放封装了主要的三个类 AVPlay、AVPlayerLayer 和 AVPlayerItem。</p>
<ul>
<li>AVPlayer</li>
</ul>
<p>AVPlayer 是一个用于播放基于时间的试听媒体的控制器对象，可以播放本地、分布下载以及 HTTP Live Streaming 协议得到的流媒体。</p>
<blockquote>
<p>HTTP Live Streaming（缩写是HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8)playlist文件，用于寻找可用的媒体流。</p>
<p>HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p>
<p>苹果公司把HLS协议作为一个互联网草案（逐步提交），在第一阶段中已作为一个非正式的标准提交到IETF。但是，即使苹果偶尔地提交一些小的更新，IETF却没有关于制定此标准的有关进一步的动作。</p>
</blockquote>
<p>AVPlayer 只管理一个单独资源的播放，其子类 AVQueuePlayer 可以管理资源队列。</p>
<ul>
<li>AVPlayerLayer</li>
</ul>
<p>AVPlayerLayer 构建于 Core Animation 之上，扩展了 Core Animation 的 CALayer 类，不提供除内容渲染面以外的任何可视化控件，支持的自定义属性只有 video gravity，可以选择 AVLayerVideoGravityResizeAspect、AVLayerVideoGravityResizeAspectFill、AVLayerVideoGravityResize 三个值，分别是等比例完全展示，等比例完全铺满，和不等比例完全铺满。</p>
<ul>
<li>AVPlayerItem</li>
</ul>
<p>AVAsset 只包含媒体资源的静态信息，AVPlayerItem 可以建立媒体资源动态视角的数据模型，并保存 AVPlayer 播放状态。</p>
<h2 id="2-播放视频"><a href="#2-播放视频" class="headerlink" title="2. 播放视频"></a>2. 播放视频</h2><p>从一个待播放的 AVAsset 开始，需要做以下初始化操作</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.avPlayerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:<span class="keyword">self</span>.targetAVAsset];</span><br><span class="line"><span class="keyword">self</span>.avPlayer = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.avPlayerItem];</span><br><span class="line"><span class="keyword">self</span>.avPlayerLayer = [<span class="built_in">AVPlayerLayer</span> playerLayerWithPlayer:<span class="keyword">self</span>.avPlayer];</span><br><span class="line">[<span class="keyword">self</span>.layer addSublayer:<span class="keyword">self</span>.avPlayerLayer];</span><br></pre></td></tr></table></figure>

<p>依次创建 AVPlayerItem、AVPlayer 和 AVPlayerLayer 三个对象，最终将 AVPlaterLayer 加入到待展示内容的 view 上。但是此时不能立即播放，AVPlayerItem 有一个 status 状态，用于标识当前视频是否准备好被播放，需要监听这一个属性。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>.avPlayerItem, status) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.avPlayerItem.status == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>) &#123;</span><br><span class="line">        <span class="comment">// 视频准备就绪</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.autoPlayMode) &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerButton.hidden = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> beginPlay];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.playerButton.enabled = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">self</span>.playerButton.hidden = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.avPlayerItem.status == <span class="built_in">AVPlayerItemStatusFailed</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="3-处理时间"><a href="#3-处理时间" class="headerlink" title="3. 处理时间"></a>3. 处理时间</h2><p>使用浮点型数据类型来表示时间在视频播放时会由于数据不精确、多时间计算累加导致时间明显偏移，是的数据流无法同步，且不能做到自我描述，在不同的时间轴进行比较和运算时比较困难。所以 AVFoundation 使用 CMTime 数据结构来表示时间。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">CMTimeValue</span>	value;</span><br><span class="line">	<span class="built_in">CMTimeScale</span>	timescale;</span><br><span class="line">	<span class="built_in">CMTimeFlags</span>	flags;</span><br><span class="line">	<span class="built_in">CMTimeEpoch</span>	epoch;		<span class="comment">/* CMTime 结构体的纪元数量通常设置为 0，但是你可以用它来区分不相关的时间轴。例如，纪元可以通过使用演示循环每个周期递增，区分循环0中的时间 N与循环1中的时间 N。*/</span></span><br><span class="line">&#125; <span class="built_in">CMTime</span>;</span><br></pre></td></tr></table></figure>

<p>CMTime 对时间的描述就是 time = value/timescale。</p>
<h2 id="4-实践"><a href="#4-实践" class="headerlink" title="4. 实践"></a>4. 实践</h2><h3 id="4-1-创建视频视图"><a href="#4-1-创建视频视图" class="headerlink" title="4.1 创建视频视图"></a>4.1 创建视频视图</h3><p>UIView 寄宿在 CALayer 实例之上，可以继承 UIView 覆写其类方法 <code>+ (Class)layerClass</code> 返回特定类型的 CALayer，这样 UIView 在初始化时就会选择此类型来创建宿主 Layer。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AVPlayerLayer</span> <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在自定义初始化方法里直接传入一个 AVPlayer 对象就可以对 UIView 的根 layer 设置 AVPlayer 属性了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithPlayer:(<span class="built_in">AVPlayer</span> *)player &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:<span class="built_in">CGRectZero</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">        [(<span class="built_in">AVPlayerLayer</span> *) [<span class="keyword">self</span> layer] setPlayer:player];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在加载 AVPlayerItem 时选择一些元数据 key 值进行加载，形式如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *keys = @[</span><br><span class="line">    <span class="string">@"tracks"</span>,</span><br><span class="line">    <span class="string">@"duration"</span>,</span><br><span class="line">    <span class="string">@"commonMetadata"</span>,</span><br><span class="line">    <span class="string">@"availableMediaCharacteristicsWithMediaSelectionOptions"</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:<span class="keyword">self</span>.asset</span><br><span class="line">                       automaticallyLoadedAssetKeys:keys];</span><br><span class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem];</span><br><span class="line"><span class="keyword">self</span>.playerView = [[THPlayerView alloc] initWithPlayer:<span class="keyword">self</span>.player];</span><br></pre></td></tr></table></figure>

<p>这样可以在加载 AVPlayerItem 时同时加载音轨、时长、common 元数据和备用。</p>
<h3 id="4-2-监听状态"><a href="#4-2-监听状态" class="headerlink" title="4.2 监听状态"></a>4.2 监听状态</h3><p>初始化 AVPlayerItem 之后需要等待其状态变为 AVPlayerItemStatusReadyToPlay，因此需要进行监听</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>.avPlayerItem, status) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.avPlayerItem.status == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>) &#123;</span><br><span class="line">        <span class="comment">// 视频准备就绪</span></span><br><span class="line">        <span class="built_in">CMTime</span> duration = <span class="keyword">self</span>.playerItem.duration;</span><br><span class="line">        [<span class="keyword">self</span>.player play];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.avPlayerItem.status == <span class="built_in">AVPlayerItemStatusFailed</span>)&#123;</span><br><span class="line">        <span class="comment">// 视频无法播放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="4-3-监听时间"><a href="#4-3-监听时间" class="headerlink" title="4.3 监听时间"></a>4.3 监听时间</h3><p>对于播放时间的监听，AVPlayer 提供了两个方法</p>
<ul>
<li>定期监听</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.intervalObserver =  [<span class="keyword">self</span>.avPlayer addPeriodicTimeObserverForInterval:<span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">2</span>) queue:dispatch_get_main_queue() usingBlock:^(<span class="built_in">CMTime</span> time) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, <span class="built_in">CMTimeGetSeconds</span>(time));</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>这个方法以一定时间间隔，发送消息到指定队列，这里要求队列必须是串行队列，回调 block 的参数是一个用 CMTime 表示的播放器的当前时间。</p>
<ul>
<li>边界时间监听</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.intervalObserver = [<span class="keyword">self</span>.avPlayer addBoundaryTimeObserverForTimes:@[[<span class="built_in">NSValue</span> valueWithCMTime:<span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">2</span>)], [<span class="built_in">NSValue</span> valueWithCMTime:<span class="built_in">CMTimeMake</span>(<span class="number">2</span>, <span class="number">2</span>)]] queue:dispatch_get_main_queue() usingBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@".."</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>这个方法接受一个 CMTime 组成的数组，当到达数组包含的边界点时触发回调 block，但 block 不提供当前的 CMTime 值。</p>
<p>同时要注意对监听的释放</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.intervalObserver)&#123;</span><br><span class="line">    [<span class="keyword">self</span>.avPlayer removeTimeObserver:<span class="keyword">self</span>.intervalObserver];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-监听播放结束"><a href="#4-4-监听播放结束" class="headerlink" title="4.4 监听播放结束"></a>4.4 监听播放结束</h3><p>视频播放结束时会发出 AVPlayerItemDidPlayToEndTimeNotification 通知，可以注册此通知来获知视频已经播放结束</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span> object:<span class="keyword">self</span>.avPlayerItem queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"did play to end"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>还有一种办法是监听 AVPlayer 的速度 rate，当速度降为 0 时，判断当前时间与总时长的关系</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[RACObserve(<span class="keyword">self</span>.avPlayer, rate) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">float</span> currentTime = <span class="built_in">CMTimeGetSeconds</span>(<span class="keyword">self</span>.avPlayerItem.currentTime);</span><br><span class="line">    <span class="keyword">float</span> durationTime = <span class="built_in">CMTimeGetSeconds</span>(<span class="keyword">self</span>.avPlayerItem.duration);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.avPlayer.rate == <span class="number">0</span> &amp;&amp; currentTime &gt;= durationTime) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> endPlayer];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="4-5-控制播放进度"><a href="#4-5-控制播放进度" class="headerlink" title="4.5 控制播放进度"></a>4.5 控制播放进度</h3><p>我们用一个 UISlider 来控制视频播放,UISlider 有三个事件可以加入 selector，分别是</p>
<ul>
<li>点按开始 UIControlEventTouchDown</li>
<li>滑动中 UIControlEventValueChanged</li>
<li>点按结束 UIControlEventTouchUpInside</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">_scrubberSlider = [[<span class="built_in">UISlider</span> alloc] init];</span><br><span class="line">[_scrubberSlider addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(sliderValueChange) forControlEvents:<span class="built_in">UIControlEventValueChanged</span>];</span><br><span class="line">[_scrubberSlider addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(sliderStop) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">[_scrubberSlider addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(sliderBegin) forControlEvents:<span class="built_in">UIControlEventTouchDown</span>];</span><br></pre></td></tr></table></figure>

<p>同时获取到视频大小后可以设置 slider 的 value 属性</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.scrubberSlider.minimumValue = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">self</span>.scrubberSlider.maximumValue = <span class="built_in">CMTimeGetSeconds</span>(<span class="keyword">self</span>.avPlayerItem.duration);</span><br></pre></td></tr></table></figure>

<p>接下来是三个 selector 的实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sliderBegin</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> pausePlayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sliderValueChange</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.avPlayerItem cancelPendingSeeks];</span><br><span class="line">    [<span class="keyword">self</span>.avPlayerItem seekToTime:<span class="built_in">CMTimeMakeWithSeconds</span>(<span class="keyword">self</span>.scrubberSlider.value, <span class="built_in">NSEC_PER_SEC</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sliderStop</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> beginPlay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中当滑动开始时要暂时停止视频播放，滑动过程中出于性能考虑，调用 cancelPendingSeeks 方法，它能取消之前所有的 seekTime 操作，然后再根据 slider 的 value 值去进行 seekToTime 操作，最后滑动结束后恢复播放。</p>
<h3 id="4-6-获取图片序列"><a href="#4-6-获取图片序列" class="headerlink" title="4.6 获取图片序列"></a>4.6 获取图片序列</h3><p>AVAssetImageGenerator 可以用来生成一个视频的固定时间点的图片序列集合，其具体使用如下。</p>
<p>首先初始化一个 AVAssetImageGenerator 对象</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:targetAVAsset];</span><br><span class="line"><span class="keyword">self</span>.imageGenerator.maximumSize = <span class="built_in">CGSizeMake</span>(<span class="number">400.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line">[<span class="keyword">self</span>.imageGenerator setRequestedTimeToleranceBefore:kCMTimeZero];</span><br><span class="line">[<span class="keyword">self</span>.imageGenerator setRequestedTimeToleranceAfter:kCMTimeZero];</span><br></pre></td></tr></table></figure>

<p>setRequestedTimeToleranceBefore 和 setRequestedTimeToleranceAfter 方法可以设置获取的帧时值偏移程度，越精确对性能要求越高。</p>
<p>然后生成一串时值数组</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> duration = <span class="keyword">self</span>.targetAVAsset.duration;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *times = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">CMTimeValue</span> increment = duration.value / <span class="number">20</span>;</span><br><span class="line"><span class="built_in">CMTimeValue</span> currentValue = <span class="number">2.0</span> * duration.timescale;</span><br><span class="line"><span class="keyword">while</span> (currentValue &lt;= duration.value) &#123;</span><br><span class="line">    <span class="built_in">CMTime</span> time = <span class="built_in">CMTimeMake</span>(currentValue, duration.timescale);</span><br><span class="line">    [times addObject:[<span class="built_in">NSValue</span> valueWithCMTime:time]];</span><br><span class="line">    currentValue += increment;</span><br><span class="line">&#125;</span><br><span class="line">__block <span class="built_in">NSUInteger</span> imageCount = times.count;</span><br><span class="line">__block <span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</span><br></pre></td></tr></table></figure>

<p>最后调用方法生成图片</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.imageGenerator generateCGImagesAsynchronouslyForTimes:times completionHandler:^(<span class="built_in">CMTime</span> requestedTime, <span class="built_in">CGImageRef</span>  _Nullable imageref, <span class="built_in">CMTime</span> actualTime, <span class="built_in">AVAssetImageGeneratorResult</span> result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageref];</span><br><span class="line">        [images addObject:image];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (--imageCount == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="4-7-显示字幕"><a href="#4-7-显示字幕" class="headerlink" title="4.7 显示字幕"></a>4.7 显示字幕</h3><p>AVMediaSelectionOption 用于标识 AVAsset 的备用媒体呈现方式，包含备用音频、视频或文本轨道，这些轨道可能是特定语言的音频轨道、备用相机角度或字幕。</p>
<p>首先通过 AVAsset 的 availableMediaCharacteristicsWithMediaSelectionOptions 属性来获取当前视频的所有备用轨道，返回的字符串可能是 AVMediaCharacteristicVisual（备用视频轨道）、AVMediaCharacteristicAudible（备用音频轨道）、AVMediaCharacteristicLegible（字幕）等。</p>
<p>获取到此数组后，通过 mediaSelectionGroupForMediaCharacteristic 获取到对应类型轨道包含的所有轨道的组合 AVMediaSelectionGroup，然后遍历 AVMediaSelectionGroup 的 options 属性可以获取到所有的 AVMediaSelectionOption 对象。得到 AVMediaSelectionOption 对象后就可以进行 AVPlayerItem 的属性设置了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;</span><br><span class="line"><span class="built_in">AVMediaSelectionGroup</span> *group = [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];</span><br><span class="line"><span class="keyword">if</span> (group) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *subtitles = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</span><br><span class="line">        [subtitles addObject:option.displayName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取到所有支持的字幕名称</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;</span><br><span class="line"><span class="built_in">AVMediaSelectionGroup</span> *group = [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc]; </span><br><span class="line"><span class="built_in">BOOL</span> selected = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([option.displayName isEqualToString:subtitle]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.playerItem selectMediaOption:option inMediaSelectionGroup:group];</span><br><span class="line">        <span class="comment">// 匹配后设置字幕属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.playerItem selectMediaOption:<span class="literal">nil</span> inMediaSelectionGroup:group];<span class="comment">// 设置为 nil 可以取消字幕</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-播放和录制音频</title>
    <url>/2018/04/12/AVFoundation/AVFoundation-%E6%92%AD%E6%94%BE%E5%92%8C%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<h2 id="1-音频会话"><a href="#1-音频会话" class="headerlink" title="1 音频会话"></a>1 音频会话</h2><h3 id="1-1-分类-category"><a href="#1-1-分类-category" class="headerlink" title="1.1 分类 category"></a>1.1 分类 category</h3><p>iOS 利用音频会话（audio session）实现可管理的音频环境，音频会话提供简单实用的方法使 OS 得知应用程序应该如何与 iOS 音频环境进行交互。AVFoundation 定义了 7 种分类来描述音频行为</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>作用</th>
<th>是否允许混音</th>
<th>音频输入输出模式</th>
<th>是否支持后台</th>
<th>是否遵循静音切换</th>
</tr>
</thead>
<tbody><tr>
<td>Ambient</td>
<td>游戏、效率应用程序</td>
<td>支持</td>
<td>O</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Solo Ambient（default）</td>
<td>游戏、效率应用程序</td>
<td>不支持</td>
<td>O</td>
<td>不支持</td>
<td>遵循</td>
</tr>
<tr>
<td>Playback</td>
<td>音频和视频播放器</td>
<td>可选</td>
<td>O</td>
<td>支持</td>
<td>不遵循</td>
</tr>
<tr>
<td>Record</td>
<td>录音机、音频捕捉</td>
<td>不支持</td>
<td>I</td>
<td>支持</td>
<td>不遵循</td>
</tr>
<tr>
<td>Play and Record</td>
<td>VoIP、语音聊天</td>
<td>可选</td>
<td>I/O</td>
<td>支持</td>
<td>不遵循</td>
</tr>
<tr>
<td>Audio Processing</td>
<td>离线会话和处理</td>
<td>F</td>
<td>不能播放和录制</td>
<td></td>
<td>不遵循</td>
</tr>
<tr>
<td>Multi-Route</td>
<td>使用外部硬件的高级 A/V 应用程序</td>
<td>F</td>
<td>I/O</td>
<td></td>
<td>不遵循</td>
</tr>
</tbody></table>
<p>同时可以用 options 和 modes 进一步自定义开发。</p>
<h4 id="1-1-1-options"><a href="#1-1-1-options" class="headerlink" title="1.1.1 options"></a>1.1.1 options</h4><p>options 有以下选项</p>
<ul>
<li>AVAudioSessionCategoryOptionMixWithOthers</li>
</ul>
<p>支持 AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, 和 AVAudioSessionCategoryMultiRoute，AVAudioSessionCategoryAmbient 自动设置了此选项，AVAudioSessionCategoryOptionDuckOthers 和AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers 也自动设置了此选项。如果使用这个选项激活会话，应用程序的音频不会中断从其他应用程序（如音乐应用程序）的音频，否则激活会话会打断其他音频会话。</p>
<ul>
<li>AVAudioSessionCategoryOptionDuckOthers</li>
</ul>
<p>支持 AVAudioSessionCategoryAmbient，AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, 和 AVAudioSessionCategoryMultiRoute。设置此选项能够在播放音频时低音量听到后台播放的其他音频。整个选项周期与会话激活周期一致。</p>
<ul>
<li>AVAudioSessionCategoryOptionAllowBluetooth</li>
</ul>
<p>支持 AVAudioSessionCategoryRecord，AVAudioSessionCategoryPlayAndRecord；允许蓝牙免提设备启用。当应用使用 setPreferredInput:error: 方法选择了蓝牙无线设备作为输入时，也会自动选择相应的蓝牙设备作为输出，使用 MPVolumeView 对象将蓝牙设备作为输出时，输入也会相应改变。</p>
<ul>
<li>AVAudioSessionCategoryOptionDefaultToSpeaker</li>
</ul>
<p>支持 AVAudioSessionCategoryPlayAndRecord；在没有其他的音频路径（如耳机）可以使用的情况下设置这个选项，会议音频将通过设备的内置扬声器播放。当不设置此选项，并且没有其他的音频输出可用或选择时，音频将通过接收器播放。只有 iPhone 设备都配备有一个接收器; iPad 和 iPod touch 设备，此选项没有任何效果</p>
<p>当你的 iPhone 接有多个外接音频设备时（耳塞，蓝牙耳机等），AudioSession 将遵循 last-in wins 的原则来选择外接设备，即声音将被导向最后接入的设备。</p>
<p>当没有接入任何音频设备时，一般情况下声音会默认从扬声器出来，但有一个例外的情况：在 PlayAndRecord 这个 category 下，听筒会成为默认的输出设备。如果你想要改变这个行为，可以提供 MPVolumeView 来让用户切换到扬声器，也可通过 overrideOutputAudioPort 方法来 programmingly 切换到扬声器，也可以修改 category option 为AVAudioSessionCategoryOptionDefaultToSpeaker。</p>
<ul>
<li>AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers</li>
</ul>
<p>支持 AVAudioSessionCategoryPlayAndRecord, AVAudioSessionCategoryPlayback, and AVAudioSessionCategoryMultiRoute，设置此选项能使应用程序的音频会话与其他会话混合，但是会中断使用了 AVAudioSessionModeSpokenAudio 模式的会话。其他应用的音频会在此会话启动后暂停，并在此会话关闭后重新恢复。</p>
<p>在用到 AVAudioSessionCategoryOptionInterruptSpokenAudioAndMixWithOthers 选项时，中断了其他应用的音频后，自己的应用音频结束播放时，若想恢复其他应用的音频，需要在关闭音频会话的时候设置AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation 选项</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[session setActive:<span class="literal">NO</span></span><br><span class="line">       withOptions:<span class="built_in">AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation</span></span><br><span class="line">             error:&lt;#Your error object, or <span class="literal">nil</span> <span class="keyword">for</span> testing#&gt;];</span><br></pre></td></tr></table></figure>

<ul>
<li>AVAudioSessionCategoryOptionAllowAirPlay</li>
</ul>
<p>支持 AVAudioSessionCategoryPlayAndRecord，允许会话在 AirPlay 设备上执行。</p>
<h4 id="1-1-2-mode"><a href="#1-1-2-mode" class="headerlink" title="1.1.2 mode"></a>1.1.2 mode</h4><p>mode 用于定制化 audio sessions，如果将分类的 mode 设置不合理会执行默认的模式行为，如将 AVAudioSessionCategoryMultiRoute 类别设置 AVAudioSessionModeGameChat 模式。</p>
<ul>
<li><p>AVAudioSessionModeDefault 默认音频会话模式</p>
</li>
<li><p>AVAudioSessionModeVoiceChat 如果应用需要执行例如 VoIP 类型的双向语音通信则选择此模式</p>
</li>
<li><p>AVAudioSessionModeVideoChat 如果应用正在进行在线视频会议，请指定此模式</p>
</li>
<li><p>AVAudioSessionModeGameChat 该模式由Game Kit 提供给使用 Game Kit 的语音聊天服务的应用程序设置</p>
</li>
<li><p>AVAudioSessionModeVideoRecording 如果应用正在录制电影，则选此模式</p>
</li>
<li><p>AVAudioSessionModeMeasurement 如果您的应用正在执行音频输入或输出的测量，请指定此模式</p>
</li>
<li><p>AVAudioSessionModeMoviePlayback 如果您的应用正在播放电影内容，请指定此模式</p>
</li>
<li><p>AVAudioSessionModeSpokenAudio 当需要持续播放语音，同时希望在其他程序播放短语音时暂停播放此应用语音，选取此模式</p>
</li>
</ul>
<h3 id="1-2-配置音频会话"><a href="#1-2-配置音频会话" class="headerlink" title="1.2 配置音频会话"></a>1.2 配置音频会话</h3><p>首先获得指向 AVAudioSession 的单例指针，设置合适的分类，最后激活会话。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVAudioSession</span> *session = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">if</span> (![session setCategory:<span class="built_in">AVAudioSessionCategoryPlayAndRecord</span> error:&amp;error]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Category Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (![session setActive:<span class="literal">YES</span> error:&amp;error]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Activation Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-播放音频"><a href="#2-播放音频" class="headerlink" title="2. 播放音频"></a>2. 播放音频</h2><p>AVAudioPlayer 构建于 Core Audio 的 C-based Audio Queue Services 最顶层，局限性在于无法从网络流播放音频，不能访问原始音频样本，不能满足非常低的时延。</p>
<h3 id="2-1-创建-AVAudioPlayer"><a href="#2-1-创建-AVAudioPlayer" class="headerlink" title="2.1 创建 AVAudioPlayer"></a>2.1 创建 AVAudioPlayer</h3><p>可以通过 NSData 或本地音频文件的 NSURL 两种方式创建 AVAudioPlayer。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *fileUrl = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"rock"</span> withExtension:<span class="string">@"mp3"</span>];</span><br><span class="line"><span class="keyword">self</span>.player = [[<span class="built_in">AVAudioPlayer</span> alloc] initWithContentsOfURL:fileUrl error:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.player) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.player prepareToPlay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建出 AVAudioPlayer 后建议调用 prepareToPlay 方法，这个方法会取得需要的音频硬件并预加载 Audio Queue 的缓冲区，当然如果不主动调用，执行 play 方法时也会默认调用，但是会造成轻微播放的延时。</p>
<h3 id="2-2-对播放进行控制"><a href="#2-2-对播放进行控制" class="headerlink" title="2.2 对播放进行控制"></a>2.2 对播放进行控制</h3><p>AVAudioPlayer 的 play 可以播放音频，stop 和 pause 都可以暂停播放，但是 stop 会撤销调用 prepareToPlay 所做的设置。</p>
<ul>
<li>修改播放器的音量：播放器音量独立于系统音量，音量或播放增益定义为 0.0（静音）到 1.0（最大音量）之间的浮点值</li>
<li>修改播放器的 pan 值：允许使用立体声播放声音，pan 值从 -1.0（极左）到 1.0（极右），默认值 0.0（居中）</li>
<li>调整播放率：0.5（半速）到 2.0（2 倍速）</li>
<li>设置 numberOfLoops 实现无缝循环：-1 表示无限循环（音频循环可以是未压缩的线性 PCM 音频，也可以是 AAC 之类的压缩格式音频，MP3 格式不推荐循环）</li>
<li>音频计量：当播放发生时从播放器读取音量力度的平均值和峰值</li>
</ul>
<h3 id="2-3-实践"><a href="#2-3-实践" class="headerlink" title="2.3 实践"></a>2.3 实践</h3><h4 id="2-3-1-播放音频"><a href="#2-3-1-播放音频" class="headerlink" title="2.3.1 播放音频"></a>2.3.1 播放音频</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimeInterval</span> delayTime = [<span class="keyword">self</span>.players[<span class="number">0</span>] deviceCurrentTime] + <span class="number">0.01</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVAudioPlayer</span> *player <span class="keyword">in</span> <span class="keyword">self</span>.players) &#123;</span><br><span class="line">    [player playAtTime:delayTime];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.playing = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>

<p>对于多个需要播放的音频，如果希望同步播放效果，则需要捕捉当前设备时间并添加一个小延时，从而具有一个从开始播放时间计算的参照时间。deviveCurrentTime 是一个独立于系统事件的音频设备的时间值，当有多于 audioPlayer 处于 play 或者 pause 状态时 deviveCurrentTime 会单调增加，没有时置位为 0。playAtTime 的参数 time 要求必须是基于 deviveCurrentTime 且大于等于 deviveCurrentTime 的时间。</p>
<h4 id="2-3-2-暂停播放"><a href="#2-3-2-暂停播放" class="headerlink" title="2.3.2 暂停播放"></a>2.3.2 暂停播放</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">AVAudioPlayer</span> *player <span class="keyword">in</span> <span class="keyword">self</span>.players) &#123;</span><br><span class="line">    [player stop];</span><br><span class="line">    player.currentTime = <span class="number">0.0</span>f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂停时需要将 audioPlayer 的 currentTime 值设置为 0.0，当音频正在播放时，这个值用于标识当前播放位置的偏移，不播放音频时标识重新播放音频的起始偏移。</p>
<h4 id="2-3-4-修改音量、pan值、播放速率和循环"><a href="#2-3-4-修改音量、pan值、播放速率和循环" class="headerlink" title="2.3.4 修改音量、pan值、播放速率和循环"></a>2.3.4 修改音量、pan值、播放速率和循环</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">player.enableRate = <span class="literal">YES</span>;</span><br><span class="line">player.rate = rate;</span><br><span class="line">player.volume = volume;</span><br><span class="line">player.pan = pan;</span><br><span class="line">player.numberOfLoops = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-配置音频会话"><a href="#2-4-配置音频会话" class="headerlink" title="2.4 配置音频会话"></a>2.4 配置音频会话</h3><p>如果希望应用程序播放音频时屏蔽静音切换动作，需要设置会话分类为 AVAudioSessionCategoryPlayback，但是如果希望按下锁屏后还可以播放，就需要在 plist 里加入一个 Required background modes 类型的数组，在其中添加 App plays audio or streams audio/video using AirPlay。</p>
<h3 id="2-5-处理中断事件"><a href="#2-5-处理中断事件" class="headerlink" title="2.5 处理中断事件"></a>2.5 处理中断事件</h3><p>中断事件是指电话呼入、闹钟响起、弹出 FaceTime 等，中断事件发生时系统会调用 AVAudioPlayer 的 AVAudioPlayerDelegate 类型的 delegate 的下列方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)audioPlayerBeginInterruption:(<span class="built_in">AVAudioPlayer</span> *)player <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_2, <span class="number">8</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)audioPlayerEndInterruption:(<span class="built_in">AVAudioPlayer</span> *)player withOptions:(<span class="built_in">NSUInteger</span>)flags <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">6</span>_0, <span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>

<p>中断结束调用的方法会带入一个 options 参数，如果是 AVAudioSessionInterruptionOptionShouldResume 则表明可以恢复播放音频了。</p>
<h3 id="2-6-处理线路改变"><a href="#2-6-处理线路改变" class="headerlink" title="2.6 处理线路改变"></a>2.6 处理线路改变</h3><p>在 iOS 设备上添加或移除音频输入、输出线路时会引发线路改变，最佳实践是，插入耳机时播放动作不改动，拔出耳机时应当暂停播放。</p>
<p>首先需要监听通知</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNotificationCenter</span> *nsnc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">[nsnc addObserver:<span class="keyword">self</span></span><br><span class="line">         selector:<span class="keyword">@selector</span>(handleRouteChange:)</span><br><span class="line">             name:<span class="built_in">AVAudioSessionRouteChangeNotification</span></span><br><span class="line">           object:[<span class="built_in">AVAudioSession</span> sharedInstance]];</span><br></pre></td></tr></table></figure>

<p>然后判断是旧设备不可达事件，进一步取出旧设备的描述，判断旧设备是否是耳机，再做暂停播放处理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleRouteChange:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *info = notification.userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVAudioSessionRouteChangeReason</span> reason =</span><br><span class="line">        [info[<span class="built_in">AVAudioSessionRouteChangeReasonKey</span>] unsignedIntValue];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reason == <span class="built_in">AVAudioSessionRouteChangeReasonOldDeviceUnavailable</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVAudioSessionRouteDescription</span> *previousRoute =</span><br><span class="line">            info[<span class="built_in">AVAudioSessionRouteChangePreviousRouteKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVAudioSessionPortDescription</span> *previousOutput = previousRoute.outputs[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *portType = previousOutput.portType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([portType isEqualToString:<span class="built_in">AVAudioSessionPortHeadphones</span>]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> stop];</span><br><span class="line">            [<span class="keyword">self</span>.delegate playbackStopped];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 AVAudioSessionPortHeadphones 只包含了有线耳机，无线蓝牙耳机需要判断 AVAudioSessionPortBluetoothA2DP 值。</p>
<h2 id="3-录制音频"><a href="#3-录制音频" class="headerlink" title="3. 录制音频"></a>3. 录制音频</h2><p>AVAudioRecorder 用于负责录制音频。</p>
<h3 id="3-1-创建-AVAudioRecorder"><a href="#3-1-创建-AVAudioRecorder" class="headerlink" title="3.1 创建 AVAudioRecorder"></a>3.1 创建 AVAudioRecorder</h3><p>创建 AVAudioRecorder 需要以下信息</p>
<ul>
<li>用于写入音频的本地文件 URL</li>
<li>用于配置录音会话键值信息的字典</li>
<li>用于捕捉错误的 NSError</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *tmpDir = <span class="built_in">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="built_in">NSString</span> *filePath = [tmpDir stringByAppendingPathComponent:<span class="string">@"memo.caf"</span>];</span><br><span class="line"><span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *settings = @&#123;</span><br><span class="line">                           <span class="built_in">AVFormatIDKey</span> : @(kAudioFormatAppleIMA4),</span><br><span class="line">                           <span class="built_in">AVSampleRateKey</span> : @<span class="number">44100.0</span>f,</span><br><span class="line">                           <span class="built_in">AVNumberOfChannelsKey</span> : @<span class="number">1</span>,</span><br><span class="line">                           <span class="built_in">AVEncoderBitDepthHintKey</span> : @<span class="number">16</span>,</span><br><span class="line">                           <span class="built_in">AVEncoderAudioQualityKey</span> : @(<span class="built_in">AVAudioQualityMedium</span>)</span><br><span class="line">                           &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">self</span>.recorder = [[<span class="built_in">AVAudioRecorder</span> alloc] initWithURL:fileURL settings:settings error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.recorder) &#123;</span><br><span class="line">    <span class="keyword">self</span>.recorder.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.recorder.meteringEnabled = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span>.recorder prepareToRecord];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prepareToRecord 方法执行底层 Audio Queue 初始化必要过程，并在指定位置创建文件。</p>
<h3 id="3-2-通用设置参数"><a href="#3-2-通用设置参数" class="headerlink" title="3.2 通用设置参数"></a>3.2 通用设置参数</h3><ul>
<li>音频格式</li>
</ul>
<p>AVFormatIDKey 键对应写入内容的音频格式，它有以下可选值</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">kAudioFormatLinearPCM</span><br><span class="line">kAudioFormatMPEG4AAC</span><br><span class="line">kAudioFormatAppleLossless</span><br><span class="line">kAudioFormatAppleIMA4</span><br><span class="line">kAudioFormatiLBC</span><br><span class="line">kAudioFormatULaw</span><br></pre></td></tr></table></figure>

<p>kAudioFormatLinearPCM 会将未压缩的音频流写入文件，文件体积大。kAudioFormatMPEG4AAC 和 kAudioFormatAppleIMA4 的压缩格式会显著缩小文件，并保证高质量音频内容。但是要注意，制定的音频格式与文件类型应该兼容，例如 wav 格式对应 kAudioFormatLinearPCM 值。</p>
<ul>
<li>采样率</li>
</ul>
<p>AVSampleRateKey 指示采样率，即对输入的模拟音频信号每一秒内的采样数。常用值 8000，16000，22050，44100。</p>
<ul>
<li>通道数</li>
</ul>
<p>AVNumberOfChannelsKey 指示定义记录音频内容的通道数，除非使用外部硬件录制，否则通常选择单声道。</p>
<ul>
<li>编码位元深度</li>
</ul>
<p>AVEncoderBitDepthHintKey 指示编码位元深度，从 8 到 32。</p>
<ul>
<li>音频质量</li>
</ul>
<p>AVEncoderAudioQualityKey 指示音频质量，可选值有 AVAudioQualityMin, AVAudioQualityLow, AVAudioQualityMedium, AVAudioQualityHigh, AVAudioQualityMax。</p>
<h3 id="3-3-实践"><a href="#3-3-实践" class="headerlink" title="3.3 实践"></a>3.3 实践</h3><h4 id="3-3-1-配置音频会话"><a href="#3-3-1-配置音频会话" class="headerlink" title="3.3.1 配置音频会话"></a>3.3.1 配置音频会话</h4><p>录音和播放应用应当使用 AVAudioSessionCategoryPlayAndRecord 分类来配置会话。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVAudioSession</span> *session = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">if</span> (![session setCategory:<span class="built_in">AVAudioSessionCategoryPlayAndRecord</span> error:&amp;error]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Category Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (![session setActive:<span class="literal">YES</span> error:&amp;error]) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Activation Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意录音前需要申请麦克风权限。</p>
<h4 id="3-3-2-录音控制"><a href="#3-3-2-录音控制" class="headerlink" title="3.3.2 录音控制"></a>3.3.2 录音控制</h4><p>对录音过程的控制如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.recorder record];</span><br><span class="line">[<span class="keyword">self</span>.recorder pause];</span><br><span class="line">[<span class="keyword">self</span>.recorder stop];</span><br></pre></td></tr></table></figure>

<p>其中选择了 stop 录音即停止，此时 AVAudioRecorder 会调用其遵循 AVAudioRecorderDelegate 协议的代理的 <code>- (void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag</code> 方法。</p>
<h4 id="3-3-3-录音保存"><a href="#3-3-3-录音保存" class="headerlink" title="3.3.3 录音保存"></a>3.3.3 录音保存</h4><p>在初始化 AVAudioRecorder 时指定了临时文件目录作为存储音频的位置，音频录制结束时需要保存到 Document 目录下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSTimeInterval</span> timestamp = [<span class="built_in">NSDate</span> timeIntervalSinceReferenceDate];</span><br><span class="line"><span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@-%f.m4a"</span>, name, timestamp];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *docsDir = [<span class="keyword">self</span> documentsDirectory];</span><br><span class="line"><span class="built_in">NSString</span> *destPath = [docsDir stringByAppendingPathComponent:filename];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *srcURL = <span class="keyword">self</span>.recorder.url;</span><br><span class="line"><span class="built_in">NSURL</span> *destURL = [<span class="built_in">NSURL</span> fileURLWithPath:destPath];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">BOOL</span> success = [[<span class="built_in">NSFileManager</span> defaultManager] copyItemAtURL:srcURL toURL:destURL error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (success) &#123;</span><br><span class="line">    handler(<span class="literal">YES</span>, [THMemo memoWithTitle:name url:destURL]);</span><br><span class="line">    [<span class="keyword">self</span>.recorder prepareToRecord];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler(<span class="literal">NO</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了 NSFileManager 的 copyItemAtURL 方法将文件内容拷贝到 Document 目录下。</p>
<h4 id="3-3-4-展示时间"><a href="#3-3-4-展示时间" class="headerlink" title="3.3.4 展示时间"></a>3.3.4 展示时间</h4><p>记录音频时需要展示时间提示用户当前录制时间，AVAudioRecorder 的 currentTime 属性可以获知当前时间，将其格式化后即可进行展示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)formattedCurrentTime &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> time = (<span class="built_in">NSUInteger</span>)<span class="keyword">self</span>.recorder.currentTime;</span><br><span class="line">    <span class="built_in">NSInteger</span> hours = (time / <span class="number">3600</span>);</span><br><span class="line">    <span class="built_in">NSInteger</span> minutes = (time / <span class="number">60</span>) % <span class="number">60</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> seconds = time % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *format = <span class="string">@"%02i:%02i:%02i"</span>;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:format, hours, minutes, seconds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要实时展示时间的话，不能通过 KVO 来解决，只能加入到 NSTimer 中，每 0.5s 执行一次。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.timer invalidate];</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">0.5</span></span><br><span class="line">                                     target:<span class="keyword">self</span></span><br><span class="line">                                   selector:<span class="keyword">@selector</span>(updateTimeDisplay)</span><br><span class="line">                                   userInfo:<span class="literal">nil</span></span><br><span class="line">                                    repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-可视化音频信号"><a href="#3-3-5-可视化音频信号" class="headerlink" title="3.3.5 可视化音频信号"></a>3.3.5 可视化音频信号</h4><p>AVAudioRecorder 和 AVAudioPlayer 都有两个方法获取当前音频的平均分贝和峰值分贝数据。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">float</span>)averagePowerForChannel:(<span class="built_in">NSUInteger</span>)channelNumber; <span class="comment">/* returns average power in decibels for a given channel */</span></span><br><span class="line">- (<span class="keyword">float</span>)peakPowerForChannel:(<span class="built_in">NSUInteger</span>)channelNumber; <span class="comment">/* returns peak power in decibels for a given channel */</span></span><br></pre></td></tr></table></figure>

<p>返回值从 -160dB（静音） 到 0dB（最大分贝）。</p>
<p>获取值之前要在初始化播放器或记录器时设置 meteringEnabled 为 YES。</p>
<p>首先需要将 -160 到 0 的分贝值转为 0 到 1 范围内，需要用到下面这个类</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">THMeterTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> _scaleFactor;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_meterTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> dbResolution = MIN_DB / (TABLE_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        _meterTable = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:TABLE_SIZE];</span><br><span class="line">        _scaleFactor = <span class="number">1.0</span>f / dbResolution;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> minAmp = dbToAmp(MIN_DB);</span><br><span class="line">        <span class="keyword">float</span> ampRange = <span class="number">1.0</span> - minAmp;</span><br><span class="line">        <span class="keyword">float</span> invAmpRange = <span class="number">1.0</span> / ampRange;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">float</span> decibels = i * dbResolution;</span><br><span class="line">            <span class="keyword">float</span> amp = dbToAmp(decibels);</span><br><span class="line">            <span class="keyword">float</span> adjAmp = (amp - minAmp) * invAmpRange;</span><br><span class="line">            _meterTable[i] = @(adjAmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> dbToAmp(<span class="keyword">float</span> dB) &#123;</span><br><span class="line">    <span class="keyword">return</span> powf(<span class="number">10.0</span>f, <span class="number">0.05</span>f * dB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">float</span>)valueForPower:(<span class="keyword">float</span>)power &#123;</span><br><span class="line">    <span class="keyword">if</span> (power &lt; MIN_DB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>f;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (power &gt;= <span class="number">0.0</span>f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (<span class="keyword">int</span>) (power * _scaleFactor);</span><br><span class="line">        <span class="keyword">return</span> [_meterTable[index] floatValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>接下来可以实时获取到分贝平均值和峰值</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (THLevelPair *)levels &#123;</span><br><span class="line">    [<span class="keyword">self</span>.recorder updateMeters];</span><br><span class="line">    <span class="keyword">float</span> avgPower = [<span class="keyword">self</span>.recorder averagePowerForChannel:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">float</span> peakPower = [<span class="keyword">self</span>.recorder peakPowerForChannel:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">float</span> linearLevel = [<span class="keyword">self</span>.meterTable valueForPower:avgPower];</span><br><span class="line">    <span class="keyword">float</span> linearPeak = [<span class="keyword">self</span>.meterTable valueForPower:peakPower];</span><br><span class="line">    <span class="keyword">return</span> [THLevelPair levelsWithLevel:linearLevel peakLevel:linearPeak];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到获取峰值和均值前必须调用 updateMeters 方法。</p>
]]></content>
      <categories>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>二维码生成与检测</title>
    <url>/2018/03/19/iOS%E5%BC%80%E5%8F%91/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h2><p>生成二维码主要用到 CIFilter，主要的函数如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIQRCodeGenerator"</span>];</span><br><span class="line">[filter setDefaults];</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="string">@"微信 Yasic"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">[filter setValue:data forKey:<span class="string">@"inputMessage"</span>];</span><br><span class="line">[filter setValue:<span class="string">@"H"</span> forKey:<span class="string">@"inputCorrectionLevel"</span>];</span><br><span class="line"><span class="built_in">CIImage</span> *outPutImage = [filter outputImage];</span><br></pre></td></tr></table></figure>

<p>但是要注意的是，接下来如果直接用 CIImage 来生成 UIImage，得到的效果可能如下图所示</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *result1 = [<span class="built_in">UIImage</span> imageWithCIImage:outPutImage];</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Yasic/FixImageOrientation/master/SampleImage/UncorrectQRImage.png" width=350>

<p>可以看到图片很模糊，此时网上大部分博客给出的解决方案如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 将 CGRect 取整到最近的完整点是非常重要的。小数值会让边框画在像素边界处。因为像素已经是最小单元（不能再细分），小数值会使绘制时取周围几个像素的平均值，这样看起来就模糊了。CGRectIntegral 将表示原点的值向下取整，表示大小的值向上取整，这样就保证了你的绘制代码平整地对齐到像素边界。作为一个经验性的原则，如果你在执行任何一个可能产生小数值的操作（例如除法，CGGetMid[X|Y]，或是 CGRectDivide），在把一矩形作为视图的边框之前应该用CGRectIntegral正则化它。</span></span><br><span class="line"><span class="built_in">CGRect</span> extent = <span class="built_in">CGRectIntegral</span>(image.extent);</span><br><span class="line"><span class="built_in">CGFloat</span> size = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> scale = MIN(size/<span class="built_in">CGRectGetWidth</span>(extent), size/<span class="built_in">CGRectGetHeight</span>(extent)); <span class="comment">// 计算需要缩放的比例</span></span><br><span class="line"></span><br><span class="line">size_t width = <span class="built_in">CGRectGetWidth</span>(extent) * scale; <span class="comment">// 计算缩放后的尺寸</span></span><br><span class="line">size_t height = <span class="built_in">CGRectGetHeight</span>(extent) * scale;</span><br><span class="line"><span class="built_in">CGColorSpaceRef</span> cs = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line"><span class="comment">/// CIContext 属于Core Image框架(文档中提到主要的功能就是，用内置或自定义的过滤器处理图片和视频 以及在视频图片中检测面部和眼睛子类的特征和跟踪面部。和 Core Graphics 的主要区别 就是更注重于视频图片的加工处理)的，是一个 OC 对象</span></span><br><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CGImageRef</span> bitmapImage = [context createCGImage:image fromRect:extent]; <span class="comment">// 转化为位图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// CGContextRef 属于Core Graphics 框架(使用 Quartz 进行 2D 渲染，处理基于路径的绘图、抗锯齿渲染、渐变、图像、颜色管理、pdf文档等 2D 绘图渲染功能)</span></span><br><span class="line"><span class="comment">/// data 是一个指针，指向存储绘制的bitmap context的实际数据的地址，最少大小为bytesPerRow* height.可以传入null,让quartz自动分配计算</span></span><br><span class="line"><span class="comment">/// width/height bitmap的宽度，高度，以像素为单位</span></span><br><span class="line"><span class="comment">/// bitsPerComponent 一个component占据多少字节。对于32bit的RGBA空间，则是8（8＊4＝32）。</span></span><br><span class="line"><span class="comment">/// bytesPerRow 每一行的byte数目。如果data传入null，这里传入0，则会自动计算</span></span><br><span class="line"><span class="comment">/// space 颜色空间，一般就是DeviceRGB</span></span><br><span class="line"><span class="comment">/// bitmapInfo,一个常量，指定了是否具有alpha通道，alpha通道的位置，像素点存储的数据类型是float还是Integer等信息</span></span><br><span class="line"><span class="built_in">CGContextRef</span> bitmapContextRef = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, cs, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line"><span class="built_in">CGContextSetInterpolationQuality</span>(bitmapContextRef, kCGInterpolationNone);<span class="comment">//不允许上下文在各个保真度等级插入像素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 该方法控制坐标系统水平方向上缩放 sx，垂直方向上缩放 sy。在缩放后的坐标系统上绘制图形时，所有点的 X 坐标都相当于乘以 sx 因子，所有点的 Y 坐标都相当于乘以 sy 因子</span></span><br><span class="line"><span class="built_in">CGContextScaleCTM</span>(bitmapContextRef, scale, scale); <span class="comment">//对位图上下文进行缩放</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CGContextDrawImage</span>(bitmapContextRef, extent, bitmapImage);<span class="comment">//绘制位图到位图上下文</span></span><br><span class="line"><span class="built_in">CGImageRef</span> scaledImage = <span class="built_in">CGBitmapContextCreateImage</span>(bitmapContextRef);<span class="comment">//生成缩放后的位图</span></span><br><span class="line"><span class="built_in">UIImage</span> *outputImage = [<span class="built_in">UIImage</span> imageWithCGImage:scaledImage];</span><br><span class="line"><span class="built_in">CGContextRelease</span>(bitmapContextRef);</span><br><span class="line"><span class="built_in">CGImageRelease</span>(bitmapImage);</span><br></pre></td></tr></table></figure>

<p>它的原理是，将 CIImage 绘制到一个灰度图上下文中（CGColorSpaceCreateDeviceGray），根据给定的 size，对画布和图像进行缩放。</p>
<p>这样生成的图片如下所示</p>
<img src="https://raw.githubusercontent.com/Yasic/FixImageOrientation/master/SampleImage/CorrectQRImage.png" width=350>

<p>可以看出二维码的确清晰了很多，但是没有博客具体说明了真正影响清晰度的原因，实际上影响清晰度的原因是这一句代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGContextSetInterpolationQuality</span>(bitmapRef, kCGInterpolationNone);<span class="comment">//允许上下文在各个保真度等级插入像素</span></span><br></pre></td></tr></table></figure>

<p>这里对图像插值质量做了设置，图像插值的概念如下</p>
<blockquote>
<p>插值是对原图像的像素重新分布，从而来改变像素数量的一种方法。在图像放大过程中，像素也相应地增加，增加的过程就是“插值”发生作用的过程，“插值”程序自动选择信息较好的像素作为增加、弥补空白像素的空间，而并非只使用临近的像素，所以在放大图像时，图像看上去会比较平滑、干净。不过需要说明的是插值并不能增加图像信息，尽管图像尺寸变大，但效果也相对要模糊些，过程可以理解为白酒掺水。</p>
</blockquote>
<p>而 CGContextSetInterpolationQuality 可能默认采用了高品质的插值函数，导致生成的图片由于进行了冗余的像素插值而变得模糊，因此将插值品质设置为 NONE，禁止进行插值操作，就可以保证像素按照原本的分布来缩放了。</p>
<p><a href="https://stackoverflow.com/questions/5685884/imagequality-with-cgcontextsetinterpolationquality" target="_blank" rel="noopener">猜测三种插值品质枚举值对应的插值算法：</a></p>
<ul>
<li><p>Low: Nearest neighbor interpolation</p>
</li>
<li><p>Medium: Linear or bilinear interpolation</p>
</li>
<li><p>High: Quadratic or bicubic interpolation</p>
</li>
<li><p>给二维码加水印</p>
</li>
</ul>
<p>主要原理就是在生成的二维码图片上 drawImage 自己的水印图片</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(outputImage.size, <span class="literal">NO</span>, [[<span class="built_in">UIScreen</span> mainScreen] scale]);</span><br><span class="line">[outputImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span> , size, size)];</span><br><span class="line"><span class="built_in">UIImage</span> *waterimage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"DogLogo"</span>];</span><br><span class="line">[waterimage drawInRect:<span class="built_in">CGRectMake</span>((size - waterImagesize)/<span class="number">2.0</span>, (size - waterImagesize)/<span class="number">2.0</span>, waterImagesize, waterImagesize)];</span><br><span class="line"><span class="built_in">UIImage</span> *newPic = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Yasic/FixImageOrientation/master/SampleImage/WaterQRImage.png" width=350>

<ul>
<li>生成彩色二维码</li>
</ul>
<p>彩色二维码原理是遍历图片的每一个像素点，进行 rgb 值的改变。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> ProviderReleaseData (<span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data, size_t size)&#123;</span><br><span class="line">    free((<span class="keyword">void</span>*)data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIColor</span> *targetColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.3</span> green:<span class="number">0.7</span> blue:<span class="number">0.7</span> alpha:<span class="number">1.0</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CGFloat</span> *components = <span class="built_in">CGColorGetComponents</span>(targetColor.CGColor);</span><br><span class="line">    <span class="built_in">CGFloat</span> red = components[<span class="number">0</span>] * <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = components[<span class="number">1</span>] * <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = components[<span class="number">2</span>] * <span class="number">255</span>;<span class="comment">//分别获取 RGB 值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> imageWidth = outputImage.size.width;</span><br><span class="line">    <span class="keyword">int</span> imageHeight = outputImage.size.height;</span><br><span class="line">    </span><br><span class="line">    size_t bytesPerRow = imageWidth * <span class="number">4</span>;</span><br><span class="line">    uint32_t *rgbImageBuf = (uint32_t*)malloc(bytesPerRow * imageHeight);</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGContextRef</span> rgbContext = <span class="built_in">CGBitmapContextCreate</span>(rgbImageBuf, imageWidth, imageHeight, <span class="number">8</span>, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(rgbContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight), outputImage.CGImage); <span class="comment">//绘制图像到rgb上下文中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pixelNum = imageWidth * imageHeight; <span class="comment">//像素总数，每一个像素包含rgba四个通道</span></span><br><span class="line">    uint32_t *pCurPtr = rgbImageBuf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pixelNum; i++, pCurPtr++)&#123; <span class="comment">//遍历像素</span></span><br><span class="line">        <span class="keyword">if</span> ((*pCurPtr &amp; <span class="number">0xFFFFFF00</span>) &lt; <span class="number">0x99999900</span>)&#123; <span class="comment">// 按rgb区分</span></span><br><span class="line">            uint8_t *ptr = (uint8_t*)pCurPtr;</span><br><span class="line">            ptr[<span class="number">3</span>] = red;</span><br><span class="line">            ptr[<span class="number">2</span>] = green;</span><br><span class="line">            ptr[<span class="number">1</span>] = blue;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            uint8_t* ptr = (uint8_t*)pCurPtr;</span><br><span class="line">            ptr[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rgbImageBuf 里包含了 image 的像素信息</span></span><br><span class="line">    <span class="built_in">CGDataProviderRef</span> dataProvider = <span class="built_in">CGDataProviderCreateWithData</span>(<span class="literal">NULL</span>, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageCreate</span>(imageWidth, <span class="comment">// 图片的宽度</span></span><br><span class="line">                                        imageHeight, <span class="comment">// 图片的高度</span></span><br><span class="line">                                        <span class="number">8</span>, <span class="comment">// 一个component占据多少字节</span></span><br><span class="line">                                        <span class="number">32</span>, <span class="comment">// 每一个像素占用的bits</span></span><br><span class="line">                                        bytesPerRow, <span class="comment">// 每一行占用多少bytes，宽度乘以 4</span></span><br><span class="line">                                        colorSpace,</span><br><span class="line">                                        kCGImageAlphaLast | kCGBitmapByteOrder32Little,</span><br><span class="line">                                        dataProvider, <span class="comment">// 数据源提供者</span></span><br><span class="line">                                        <span class="literal">NULL</span>, <span class="comment">// 一个解码数组</span></span><br><span class="line">                                        <span class="literal">true</span>, <span class="comment">// 抗锯齿参数</span></span><br><span class="line">                                        kCGRenderingIntentDefault); <span class="comment">//图片渲染相关参数</span></span><br><span class="line">    outputImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">    <span class="built_in">CGDataProviderRelease</span>(dataProvider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Yasic/FixImageOrientation/master/SampleImage/ColorfulQRImage.png" width=350>

<h2 id="相机识别二维码"><a href="#相机识别二维码" class="headerlink" title="相机识别二维码"></a>相机识别二维码</h2><p>这里不赘述关于 iOS 相机的配置过程，只关注与二维码相关的步骤。</p>
<p>iOS 有识别二维码的 API，只需要将 AVCaptureMetadataOutput 配置到 session 的输出中，然后设置其 AVCaptureMetadataOutputObjectsDelegate 代理对象，系统检测到二维码后会调用相应的委托方法。</p>
<ul>
<li>配置 AVCaptureMetadataOutput</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">AVCaptureMetadataOutput</span> *)metaDataOutput</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_metaDataOutput) &#123;</span><br><span class="line">        _metaDataOutput = [[<span class="built_in">AVCaptureMetadataOutput</span> alloc] init];</span><br><span class="line">        [_metaDataOutput setMetadataObjectsDelegate:<span class="keyword">self</span> queue:dispatch_get_main_queue()];</span><br><span class="line">        _metaDataOutput.rectOfInterest = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _metaDataOutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 配置QROutput</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.metaDataOutput])&#123;</span><br><span class="line">        <span class="comment">// 顺序相反会崩溃，因为未配置到 session 时 availableMetadataObjectTypes 为空</span></span><br><span class="line">        [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.metaDataOutput];</span><br><span class="line">        <span class="keyword">self</span>.metaDataOutput.metadataObjectTypes = @[<span class="built_in">AVMetadataObjectTypeQRCode</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回调方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput didOutputMetadataObjects:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataMachineReadableCodeObject</span> *&gt; *)metadataObjects fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection&#123;</span><br><span class="line">    <span class="keyword">if</span> (metadataObjects.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *result = [metadataObjects.firstObject stringValue];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意一点，在设置 metaDatOutput 时设置了一个 rectOfInterest 属性，它能限制扫描二维码的区域，它定义了对相机采集的每一帧图像里代码真正感兴趣的检测区域，它有两个特点</p>
<ul>
<li>rectOfInterest 结构体的四个值取值范围在 0~1，即指明对于每一帧，其关心的范围的相对比例</li>
<li>rectOfInterest 默认是横屏模式，其 x y 值与通常坐标系相反，也就是说它的真正含义是 CGRectMake(y坐标, x坐标, 高度, 宽度)</li>
</ul>
<p>当然默认情况下 rectOfInterest 的值是 CGRectMake(0, 0, 1, 1)，即整个帧范围。</p>
<h2 id="识别内存中二维码图片"><a href="#识别内存中二维码图片" class="headerlink" title="识别内存中二维码图片"></a>识别内存中二维码图片</h2><p>对于网络或者相册选取后读到内存中的图片，以及项目中自带的图片，要检测二维码信息就比较简单，直接使用 CIDetector 就可以检测。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CIDetector</span> *detector = [<span class="built_in">CIDetector</span> detectorOfType:<span class="built_in">CIDetectorTypeQRCode</span> context:context options:@&#123;<span class="built_in">CIDetectorAccuracy</span>:<span class="built_in">CIDetectorAccuracyHigh</span>&#125;];</span><br><span class="line"><span class="built_in">CIImage</span> *targetImage = [<span class="built_in">CIImage</span> imageWithCGImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"CorrectQRImage.png"</span>].CGImage];</span><br><span class="line"><span class="built_in">NSArray</span> *features = [detector featuresInImage:targetImage];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (features.count == <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CIQRCodeFeature</span> *feature = features.firstObject;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, feature.messageString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，CIDetector 会返回一个数组，其中包含多个 CIQRCodeFeature，对应此图片包含的多个二维码对象，CIQRCodeFeature 对象则包含了具体的编码信息。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>视频列表异步获取视频大小的优化方案</title>
    <url>/2018/03/16/iOS%E5%BC%80%E5%8F%91/%E8%A7%86%E9%A2%91%E5%88%97%E8%A1%A8%E5%BC%82%E6%AD%A5%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E5%A4%A7%E5%B0%8F%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>iOS 的 Photo Framework 框架对系统相册中的所有照片、视频以及相册资源均采用抽象对象予以封装，用 PHAsset 统一表示一个多媒体资源实体，其中包含有该资源实体的多种属性，如下所示</p>
<ul>
<li>mediaType：多媒体类型，照片、视频还是音频</li>
<li>mediaSubtypes：子类型，live、连拍等等</li>
<li>pixelWidth、pixelHeight：资源实体的宽高</li>
<li>creationDate：创建时间</li>
<li>duration：视频时长，对于照片始终返回 0</li>
</ul>
<p>但是对于视频实体而言，不能直接从其 PHAsset 对象中获取到视频大小信息，需要采用下面的异步接口来获取</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[PHImageManager defaultManager] requestAVAssetForVideo:targetAsset options:options resultHandler:^(<span class="built_in">AVAsset</span> * _Nullable asset, <span class="built_in">AVAudioMix</span> * _Nullable audioMix, <span class="built_in">NSDictionary</span> * _Nullable info) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>)</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>)</span><br><span class="line">            <span class="built_in">AVURLAsset</span> *urlAsset = (<span class="built_in">AVURLAsset</span> *)asset;</span><br><span class="line">            <span class="built_in">NSURL</span> *url = urlAsset.URL;</span><br><span class="line">            <span class="built_in">NSNumber</span> *fileSizeValue = <span class="literal">nil</span>;</span><br><span class="line">            [url getResourceValue:&amp;fileSizeValue forKey:<span class="built_in">NSURLFileSizeKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>当前需要实现一个效果：能够在一个展示手机相册所有视频的 UICollectionView 列表中，标识每一个视频的大小。</p>
<p>但是上述的异步方法涉及到异步线程与主线程之间的切换，其性能并不可靠，在滑动列表过程中，列表元素 cell 会触发多次异步请求，通过实验统计得知，针对 2000 条视频发起上述请求需要耗时大约 7s，而获取 2000 条视频的 duration 值时，由于是直接从 PHAsset 对象获取，因此只需要 0.1s，二者差别显著。</p>
<p>因此，如果不加处理直接在列表每一个 cell 中发起请求，由于 PHAsset 内部对请求做了排队处理，快速滑动过程中会发生延时现象，滑动速度越快，视频资源越多，请求队列延迟现象越严重。因为无法及时获取到当前展示的视频，势必会影响到用户选取视频的流程。</p>
<p>所以针对这一问题，采取以下方式进行优化</p>
<h3 id="优化1：进行视频大小缓存"><a href="#优化1：进行视频大小缓存" class="headerlink" title="优化1：进行视频大小缓存"></a>优化1：进行视频大小缓存</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存缓存</span></span><br><span class="line">[[PHImageManager defaultManager] requestAVAssetForVideo:targetAsset options:options resultHandler:^(<span class="built_in">AVAsset</span> * _Nullable asset, <span class="built_in">AVAudioMix</span> * _Nullable audioMix, <span class="built_in">NSDictionary</span> * _Nullable info) &#123;</span><br><span class="line">        @strongify(<span class="keyword">self</span>)</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>)</span><br><span class="line">            <span class="built_in">AVURLAsset</span> *urlAsset = (<span class="built_in">AVURLAsset</span> *)asset;</span><br><span class="line">            <span class="built_in">NSURL</span> *url = urlAsset.URL;</span><br><span class="line">            <span class="built_in">NSNumber</span> *fileSizeValue = <span class="literal">nil</span>;</span><br><span class="line">            [url getResourceValue:&amp;fileSizeValue forKey:<span class="built_in">NSURLFileSizeKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">if</span> (targetAsset &amp;&amp; <span class="keyword">self</span>.mutipleImageVC) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.mutipleImageVC.fileSizeDict setObject:fileSizeValue forKey:targetAsset.localIdentifier];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 取缓存    </span></span><br><span class="line"><span class="keyword">if</span> (fileSizeDict[targetAsset.localIdentifier]) &#123;</span><br><span class="line">    <span class="keyword">return</span> fileSizeDict[targetAsset.localIdentifier];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以在滑动中仅获取一遍视频大小，之后获取视频大小时先进行缓存命中，减少发起多余的异步请求。但是第一次滑动列表时仍然存在延时情况。</p>
<h3 id="优化2：快速滑动时不进行异步请求"><a href="#优化2：快速滑动时不进行异步请求" class="headerlink" title="优化2：快速滑动时不进行异步请求"></a>优化2：快速滑动时不进行异步请求</h3><p>考虑到用户快速滑动列表时才会产生明显的延时效果，同时快速滑动时用户并不会关注每一个 cell 上的视频大小文案，因此当 collectionview 滑动速度较快时可以禁止 cell 进行视频大小的异步请求。</p>
<h4 id="1-获取滑动速度"><a href="#1-获取滑动速度" class="headerlink" title="1. 获取滑动速度"></a>1. 获取滑动速度</h4><p>首要问题是获取到 collectionview 的滑动速度，实现很简单，在 scrollViewDidScroll 方法中获取当前的 contentOffset，与前一次检测到的 contentOffset 对比，同时除去两次检测之间的时间间隔，得到滑动速度</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.startDate) &#123;</span><br><span class="line">        <span class="keyword">self</span>.started = scrollView.contentOffset.y;</span><br><span class="line">        <span class="keyword">self</span>.startDate = [<span class="built_in">NSDate</span> new];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> end = scrollView.contentOffset.y;</span><br><span class="line">        <span class="built_in">NSDate</span> *endDate = [<span class="built_in">NSDate</span> new];</span><br><span class="line">        <span class="keyword">self</span>.velocity = sqrt((end - <span class="keyword">self</span>.started) * (end - <span class="keyword">self</span>.started))/([endDate timeIntervalSinceDate:<span class="keyword">self</span>.startDate] * <span class="number">1000.0</span>);</span><br><span class="line">        <span class="keyword">self</span>.started = end;</span><br><span class="line">        <span class="keyword">self</span>.startDate = endDate;</span><br><span class="line">        <span class="keyword">self</span>.needRequest = (<span class="keyword">self</span>.velocity &lt; <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过试验发现 velocity 大于 0.5 即可认为进入到高速滑动状态，不需要进行异步请求。</p>
<h4 id="2-通知-cell-进行异步操作"><a href="#2-通知-cell-进行异步操作" class="headerlink" title="2. 通知 cell 进行异步操作"></a>2. 通知 cell 进行异步操作</h4><p>在上一步，我们用 needRequest 属性来标识当前是否可以进行异步请求，接下来在 cell 中对此属性进行监听，当 needRequest 从 NO 变为 YES 时表示滑动速度已经变慢，可以进行请求了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[RACObserve(_mutipleImageVC, needRequest) distinctUntilChanged] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                @strongify(<span class="keyword">self</span>)</span><br><span class="line">                PHAsset *targetAsset = <span class="keyword">self</span>.targetAsset;</span><br><span class="line">                <span class="comment">// 取缓存</span></span><br><span class="line">                <span class="keyword">if</span> (targetAsset &amp;&amp; x) &#123;</span><br><span class="line">                    <span class="comment">// 缓存未命中，发起请求</span></span><br><span class="line">                    [<span class="keyword">self</span> requestVideoSize:targetAsset fromDelegateFunction:<span class="literal">NO</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br></pre></td></tr></table></figure>

<p>要注意由于 needRequest 会在滑动中触发多次，通过 distinctUntilChanged 可以保证只在 needRequest 发生变化时才发起请求，避免冗余请求。</p>
<h4 id="3-首屏发起异步请求"><a href="#3-首屏发起异步请求" class="headerlink" title="3. 首屏发起异步请求"></a>3. 首屏发起异步请求</h4><p>此时有一个问题，cell 在初始化过程中会建立对 needRequest 的监听，但是此时 cell 还未被赋值相应的 PHAsset，所以必须等到赋值 PHAsset 后再进行异步请求，但是这样就又会在 cell 复用中发起多次请求。因此需要对请求进行控制，对 cell 加入一个标志位 requested，在复用时对其进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#x2F;&#x2F;复用赋值</span><br><span class="line">            if (self.requested) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            self.requested &#x3D; YES;</span><br><span class="line">            [self requestVideoSize:targetAsset fromDelegateFunction:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> cell 只在未发生滑动之前才在复用时发起请求，滑动后就通过监听 needRequest 来发起请求。</p>
<p>这样会引入新的问题，即当 collectionview 执行 reloadData 时，cell 会被复用，在复用赋值中不会发起请求，但同时由于没有滑动，needRequest 不会发出信号，cell 就不能根据监听来发起请求，导致除非用户滑动列表否则永远不会展示视频大小的 bug。</p>
<p>解决方案是在 collectionview 执行 reloadData 时更新一个 beginReload 标志位为 YES，cell 监听到 beginReload 为 YES 时，将其 requested 标志位复位为 NO，这样 cell 复用时就可以发起请求了。同时当用户开始滑动时，再将 beginReload 置为 NO，重新变为监听 needRequest 发起请求。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.imageCollectionView reloadData];</span><br><span class="line">    <span class="keyword">self</span>.beginReload = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.beginReload = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">            [RACObserve(_mutipleImageVC, beginReload) subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                @strongify(<span class="keyword">self</span>)</span><br><span class="line">                <span class="keyword">self</span>.requested = !(<span class="keyword">self</span>.mutipleImageVC.beginReload);</span><br><span class="line">            &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体流程如下</p>
<h4 id="4-手势问题"><a href="#4-手势问题" class="headerlink" title="4. 手势问题"></a>4. 手势问题</h4><p>这样处理后基本可以将一段时间内的异步请求造成的延时控制在用户无法察觉的范围内，但是实际测试发现，当高速滑动中用手指急停列表时，needRequest 可能仍然为 NO，但是不会再调用 scrollViewDidScroll，因而不能恢复为 YES，所以采取下面方式进行防护</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[RACObserve(<span class="keyword">self</span>, velocity) throttle:<span class="number">0.3</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">self</span>.velocity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span>.needRequest = (<span class="keyword">self</span>.velocity &lt; <span class="number">0.5</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>0.3 秒内如果 velocity 的值不发生变化，则将其置为 YES，保证急停后可以感知到速度降低。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>列表中大量 cell 需要尽量避免耗时的异步请求，否则容易影响性能</li>
<li>对于异步请求返回的数据尽可能缓存到内存</li>
<li>高速滑动时可以不进行异步请求，防止过多无用的请求产生</li>
</ul>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift实现二叉搜索树与字典树</title>
    <url>/2018/03/08/iOS%E5%BC%80%E5%8F%91/Swift%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树的性质如下：</p>
<ul>
<li>若任意节点的左子树不空，则左子树所有节点的值小于根节点的值</li>
<li>若任意节点的右子树不空，则左子树所有节点的值大于根节点的值</li>
<li>任意节点的左右子树也为二叉搜索树</li>
<li>没有键值相等的节点</li>
</ul>
<p>其基本操作有如下四个</p>
<ul>
<li>empty——返回一个空的二叉搜索树</li>
<li>isEmpty——检查二叉搜索树是否为空</li>
<li>contains——检查二叉搜索树是否包含某元素</li>
<li>insert——向二叉搜索树插入元素</li>
</ul>
<h4 id="具体实现过程"><a href="#具体实现过程" class="headerlink" title="具体实现过程"></a>具体实现过程</h4><ul>
<li>用一个递归枚举定义二叉搜索树的数据结构</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span>:<span class="title">Comparable</span>&gt;</span>&#123; <span class="comment">// indirect 表明是递归枚举</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Leaf</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">BinarySearchTree</span>&lt;<span class="type">E</span>&gt;, <span class="type">E</span>, <span class="type">BinarySearchTree</span>&lt;<span class="type">E</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过关联值指定一个节点的左右子树及其自身。</p>
<ul>
<li>初始化方法，可以初始化一个空树或者一个根节点有值的树</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>()&#123;</span><br><span class="line">    <span class="keyword">self</span> = .<span class="type">Leaf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(value:<span class="type">E</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span> = .<span class="type">Node</span>(.<span class="type">Leaf</span>, value, .<span class="type">Leaf</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印所有元素的方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements:[<span class="type">E</span>] &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Leaf</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="keyword">left</span>, x, <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.elements + [x] + <span class="keyword">right</span>.elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法可以按照中序排列方式打印出所有元素</p>
<ul>
<li>判断是否为空以及是否为二叉搜索树的方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isEmpty:<span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Leaf</span> = <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isBST:<span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Leaf</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="keyword">left</span>, x, <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.elements.<span class="built_in">reduce</span>(<span class="literal">true</span>, &#123; (result, y) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            result &amp;&amp; (y &lt; x)</span><br><span class="line">        &#125;) &amp;&amp; <span class="keyword">right</span>.elements.<span class="built_in">reduce</span>(<span class="literal">true</span>, &#123; (result, y) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">            result &amp;&amp; (y &gt; x)</span><br><span class="line">        &#125;) &amp;&amp; <span class="keyword">left</span>.isBST &amp;&amp; <span class="keyword">right</span>.isBST</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 isBST 方法会根据二叉搜索树的前三个特性来检测一个树。</p>
<ul>
<li>检测是否包含某元素的方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(x:E)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Leaf</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="number">_</span>, y, <span class="number">_</span>) <span class="keyword">where</span> x == y:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="keyword">left</span>, y, <span class="number">_</span>) <span class="keyword">where</span> x &lt; y:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.<span class="built_in">contains</span>(x: x)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Node</span>(<span class="number">_</span>, y, <span class="keyword">right</span>) <span class="keyword">where</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span>.<span class="built_in">contains</span>(x: x)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fatalError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果树是空的，则 x 不在树中，返回 false。</p>
<p>如果树不为空，且储存在根节点的值与 x 相等，返回 true。</p>
<p>如果树不为空，且储存在根节点的值大于 x，那么如果 x 在树中的话，它一定是在左子树中，所以，我们在左子树中递归搜索 x。</p>
<p>类似地，如果根节点的值小于 x，我们就在右子树中继续搜索。</p>
<ul>
<li>插入一个元素</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(x:E)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Leaf</span>:</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">BinarySearchTree</span>.<span class="keyword">init</span>(value: x)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Node</span>(<span class="keyword">var</span> <span class="keyword">left</span>, <span class="keyword">let</span> y, <span class="keyword">var</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">if</span> x &lt; y &#123;<span class="keyword">left</span>.insert(x: x)&#125;</span><br><span class="line">        <span class="keyword">if</span> x &gt; y &#123;<span class="keyword">right</span>.insert(x: x)&#125;</span><br><span class="line">        <span class="keyword">self</span> = .<span class="type">Node</span>(<span class="keyword">left</span>, y, <span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于需要对二叉搜索树进行修改，所以该方法用到了 mutating 来修饰。方法递归遍历二叉搜索树，直到找到一个空叶子节点就加入。</p>
<p>使用如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> binaryTree = <span class="type">BinarySearchTree</span>.<span class="keyword">init</span>(value: <span class="number">5</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">1</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">2</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">3</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">4</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">5</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">6</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">7</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">8</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">9</span>)</span><br><span class="line">binaryTree.insert(x: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(binaryTree.elements)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>字典树 Trie 是一种有序树，用于保存关联数组，通常是字符串，字典树的键不是直接保存在节点里，而是由一串节点的值组合而成。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/500px-Trie_example.svg.png" width=350>

<h4 id="具体实现过程-1"><a href="#具体实现过程-1" class="headerlink" title="具体实现过程"></a>具体实现过程</h4><ul>
<li>用结构体定义一个字典树的数据结构</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&lt;<span class="title">Element</span>:<span class="title">Hashable</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> children:[<span class="type">Element</span>:<span class="type">Trie</span>]</span><br><span class="line">    <span class="keyword">var</span> isElement: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 children 就是一个字典，值是一个子字典树，键是子树的前缀值，而 isElement 定义了当前节点为止的组合是否是一个元素</p>
<img src="https://github.com/julycoding/The-Art-Of-Programming-By-July/raw/master/ebook/images/8/8.4/2.gif" width=350>

<p>例如上图中，“at” 节点的 isElement 就是 true，而 ag 由于不是一个有意义的单词所以 isElement 为 false。</p>
<ul>
<li>初始化方法</li>
</ul>
<p>首先是两个基础的初始化方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">    isElement = <span class="literal">false</span></span><br><span class="line">    children = [:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(isElement:<span class="type">Bool</span>, children:[<span class="type">Element</span>:<span class="type">Trie</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isElement = isElement;</span><br><span class="line">    <span class="keyword">self</span>.children = children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是正常使用过程中，我们更需要一个能接受一个数组作为入参的初始化方法，然后形成一个单元素的字典树。</p>
<p>此时我们首先需要实现一个数组的递归方式，即从最原始的数组逐渐去除一定数量的元素形成子数组，我们将其定义为 Array 的一个拓展方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> decompose: (<span class="type">Element</span>, [<span class="type">Element</span>])? &#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty ? <span class="literal">nil</span> : (<span class="keyword">self</span>[startIndex], <span class="type">Array</span>(<span class="keyword">self</span>.<span class="built_in">dropFirst</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果数组为空则返回 nil，否则返回一个元组，元组第一个元素是当前数组的头元素，第二个元素是去掉第一个元素之后由该数组其余元素组成的新数组。我们可以通过重复调用一个数组的 decompose 方法递归地遍历一个数组。</p>
<p>接下来就可以定义一个接收数组参数的初始化方法了</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(key:[<span class="type">Element</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (head, tail) = key.decompose &#123;</span><br><span class="line">        <span class="keyword">let</span> children = [head: <span class="type">Trie</span>.<span class="keyword">init</span>(key: tail)]</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Trie</span>(isElement: <span class="literal">false</span>, children: children)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Trie</span>(isElement: <span class="literal">true</span>, children: [:])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它遍历传入的数组，生成以数组中元素为节点的单元素字典树。</p>
<ul>
<li>插入操作</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(key:[Element])</span></span> -&gt; <span class="type">Trie</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = key.decompose <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Trie</span>.<span class="keyword">init</span>(isElement: <span class="literal">true</span>, children: <span class="keyword">self</span>.children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> newChildren = <span class="keyword">self</span>.children</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> nextTrie = <span class="keyword">self</span>.children[head] &#123;</span><br><span class="line">        newChildren[head] = nextTrie.insert(key: tail)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newChildren[head] = <span class="type">Trie</span>.<span class="keyword">init</span>(key: tail)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Trie</span>.<span class="keyword">init</span>(isElement: isElement, children: newChildren)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历传入的数组并检查每一个节点的 children 键组。</p>
<p>如果键组为空，我们将 isElement 设置为 true，然后不再修改剩余的字典树，表明已经插入完毕了。</p>
<p>如果键组不为空，且键组的 head 已经存在于当前节点的 children 字典中，我们只需要递归地调用该函数，将键组的 tail 插入到对应的子字典树中。</p>
<p>如果键组不为空，且第一个键 head 并不是该字典树中 children 字典的某条记录，就创建一棵新的字典树来储存键组中剩下的键。然后，以 head 键和 tail 数组生成对应新的字典树，储存在当前节点中，完成插入操作。</p>
<p>然后我们就可以定义一个方法来将一个关联数组组合成字典树</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildStringTrie</span><span class="params">(words:[String])</span></span> -&gt; <span class="type">Trie</span>&lt;<span class="type">Character</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> emptyTrie = <span class="type">Trie</span>&lt;<span class="type">Character</span>&gt;.<span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">return</span> words.<span class="built_in">reduce</span>(emptyTrie, &#123; (result, word) -&gt; <span class="type">Trie</span>&lt;<span class="type">Character</span>&gt; <span class="keyword">in</span></span><br><span class="line">        result.insert(key: <span class="type">Array</span>.<span class="keyword">init</span>(word))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印方法，打印出字典树中包含的所有关联元素</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements: [[<span class="type">Element</span>]] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [[<span class="type">Element</span>]] = isElement ? [[]] : []</span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> children &#123;</span><br><span class="line">        result += value.elements.<span class="built_in">map</span> &#123; [key] + $<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很精巧，同时也很难懂，首先需要注意下面一些操作的结果</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[] + [[<span class="string">"r"</span>]] = [[<span class="string">"r"</span>]]</span><br><span class="line">[[]] + [[<span class="string">"r"</span>]] = [[], [<span class="string">"r"</span>]]</span><br></pre></td></tr></table></figure>

<p>对于一个嵌套的二维数组，直接加一个空的一维数组，这个空的一维数组就被加入为二维数组的一个元素，而两个嵌套的二维数组相加，则会合并为一个二维数组。</p>
<p>现在来看这段代码，它的思路其实是：</p>
<ul>
<li>对于 isElement 为 true 的节点，返回类似 [[]] 或 [[], [“X”]] 的数组，里面一定包含一个空数组，开始将此节点回溯的所有父节点组合为元素</li>
<li>对于 isElement 为 false 的节点，由于它一定是某个 isElement 为 true 的节点的父节点，所以返回类似 [[“X”], [“Y”, “Z”]] 的数组，不会生成多余的数组来组合新的元素</li>
<li>依次遍历，最终生成包含所有元素的数组</li>
</ul>
<p>让我们用一个简单的例子来测试，首先用 [“cart”, “car”] 数组来生成一个字典树，然后在 elements 过程中进行打印</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="keyword">let</span> contents = [<span class="string">"cart"</span>, <span class="string">"car"</span>]</span><br><span class="line">        <span class="keyword">let</span> trie = buildStringTrie(words:contents)</span><br><span class="line">        <span class="built_in">print</span>(trie.elements)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [[<span class="type">Element</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [[<span class="type">Element</span>]] = isElement ? [[]] : []</span><br><span class="line">        <span class="keyword">for</span> (key, value) <span class="keyword">in</span> children &#123;</span><br><span class="line">            result += value.elements.<span class="built_in">map</span> &#123; [key] + $<span class="number">0</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结果如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[[]]</span><br><span class="line">[[], [<span class="string">"t"</span>]]</span><br><span class="line">[[<span class="string">"r"</span>], [<span class="string">"r"</span>, <span class="string">"t"</span>]]</span><br><span class="line">[[<span class="string">"a"</span>, <span class="string">"r"</span>], [<span class="string">"a"</span>, <span class="string">"r"</span>, <span class="string">"t"</span>]]</span><br><span class="line">[[<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"r"</span>], [<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"r"</span>, <span class="string">"t"</span>]]</span><br><span class="line">[[<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"r"</span>], [<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"r"</span>, <span class="string">"t"</span>]]</span><br></pre></td></tr></table></figure>

<ul>
<li>检索某个字符串是否在字典树的方法和检索某个前缀对应的字典树的方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(key: [Element])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = key.decompose <span class="keyword">else</span> &#123; <span class="keyword">return</span> isElement &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> subtrie = children[head] <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> subtrie.lookup(key: tail)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withPrefix</span><span class="params">(<span class="keyword">prefix</span>:[Element])</span></span> -&gt; <span class="type">Trie</span>&lt;<span class="type">Element</span>&gt;?&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> (head, tail) = <span class="keyword">prefix</span>.decompose <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">self</span>&#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> remainder = children[head] <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> remainder.withPrefix(<span class="keyword">prefix</span>: tail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路大致一样，遍历传入的数组，当遍历结束时返回结果。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift的autoclosure与escaping标签</title>
    <url>/2018/03/02/iOS%E5%BC%80%E5%8F%91/Swift%E7%9A%84autoclosure%E4%B8%8Eescaping%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h2 id="autoclosure"><a href="#autoclosure" class="headerlink" title="@autoclosure"></a>@autoclosure</h2><p>在《函数式 Swift》第四章提到了 Swift 的 autoclosure 标签能够避免创建显式闭包的需求。</p>
<p>在 Swift 中有一个特殊类型叫做函数类型，它由一个参数类型和返回值类型组成，用于表示一个函数、方法或闭包的类型，形式如下</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">parameter<span class="built_in"> type </span>-&gt; return type</span><br></pre></td></tr></table></figure>

<p>autoclosure 标签能够将特定表达式上的表达式当做隐式闭包来捕获，也就是将一个表达式当做函数类型来处理，例如对于下面一个函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAutoClosure</span><span class="params">(target:@autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(target())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它接受一个函数类型的参数，但是调用的时候可以直接传入表达式作为参数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">testAutoClosure(target: <span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure>

<p>假如没有 autoclure 标签，我们就需要按照如下几种方式调用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">testAutoClosure &#123; () -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testAutoClosure(target: &#123;<span class="string">"Hello World"</span>&#125;)</span><br><span class="line"></span><br><span class="line">testAutoClosure&#123;<span class="string">"Hello World"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，autoclosure 作用就是简化闭包调用形式。</p>
<p>autoclosure 标签在 Swift 系统 API 中使用也很广泛，例如 ?? 操作符的定义</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, @autoclosure defaultValue: <span class="params">()</span></span></span> -&gt; <span class="type">T?</span>) -&gt; <span class="type">T?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, @autoclosure defaultValue: <span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>这样实现的原因是，如果 ?? 第二个参数直接接受一个特定值，那么在调用时第二个参数如果是函数就必须先被执行得到一个返回值，即使最终进行判断后并没有使用第二个参数，这样会带来不必要的计算消耗，尤其是当第二个参数的函数内进行的操作比较复杂时。那么定义一个闭包就可以在需要用到第二个参数时才执行闭包内的逻辑。进一步，为了像上面一样，能够简化闭包调用，所以使用 autoclosure 标签修饰了闭包参数。</p>
<p>当然使用 autoclosure 也有需要注意的地方</p>
<blockquote>
<p>最后要提一句的是，@autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -&gt; T 的参数才能使用这个特性进行简化。另外因为调用者往往很容易忽视 @autoclosure 这个特性，所以在写接受 @autoclosure 的方法时还请特别小心，如果在容易产生歧义或者误解的时候，还是使用完整的闭包写法会比较好。</p>
</blockquote>
<h2 id="Escaping"><a href="#Escaping" class="headerlink" title="@Escaping"></a>@Escaping</h2><p>escaping 是闭包的另一个修饰符。当闭包的某个参数在闭包返回后才被调用时称这个参数是逃逸的参数，Swift 默认不允许闭包的参数逃逸，所以下面的定义是不能通过编译的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canNotEscape</span><span class="params">(target:<span class="params">()</span></span></span>-&gt;<span class="type">Bool</span>) -&gt; ()-&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而下面这种形式就是可以逃逸的闭包参数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意一点，对于可以逃逸的闭包参数，其实现内部必须显式使用 self 引用，而非逃逸闭包参数则可以隐式使用 self 引用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        closure()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        completionHandlers.append(completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>UICollectionView快速点击无法高亮的原因</title>
    <url>/2018/02/28/iOS%E5%BC%80%E5%8F%91/UICollectionView%E5%BF%AB%E9%80%9F%E7%82%B9%E5%87%BB%E6%97%A0%E6%B3%95%E9%AB%98%E4%BA%AE%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>在 MTBCYAlbumKit 中有一个用于切换相册的 view，使用 collectionview 展示系统相册列表和用户相册列表，点击列表元素实现相册切换功能，其中 UI 要求点击时元素背景颜色变深，点击结束后恢复颜色。</p>
<p>collectionview 自身有两个代理方法可以实现此效果。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)collectionView : (<span class="built_in">UICollectionView</span> *)collectionView didHighlightItemAtIndexPath : (<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    [collectionView cellForItemAtIndexPath:indexPath].contentView.backgroundColor = HEXCOLOR(<span class="number">0xF5F5F5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didUnhighlightItemAtIndexPath : (<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    [collectionView cellForItemAtIndexPath:indexPath].contentView.backgroundColor = IMERCHANT_WHITE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在使用中发现有如下问题：快速点击列表内元素时不会出现高亮效果，只有按住一小段时间才会出现高亮效果。网上给出的解决方法是将 collectionview 的 delaysContentTouches 属性设置为 NO，下面阐述调研后的具体原因。</p>
<h3 id="delaysContentTouches-属性"><a href="#delaysContentTouches-属性" class="headerlink" title="delaysContentTouches 属性"></a>delaysContentTouches 属性</h3><p>delaysContentTouches 其实是 UIScrollView 的属性，它的含义如下</p>
<blockquote>
<p>A Boolean value that determines whether the scroll view delays the handling of touch-down gestures.</p>
<p>一个布尔值，用于确定滚动视图是否延迟触摸手势的处理。</p>
</blockquote>
<p>这里涉及到 UIScrollView 对于手势的处理逻辑，当手指开始 touch 屏幕时，scrollview 会启动一个短时间的定时器，在此期间，如果检测到手势有明显滑动，则 scrollView 发生滚动，并且不会将事件下发到 cell。如果此期间没有明显滑动，则触发 cell 的 touchBegin 事件，但同时如果之后手指发生滑动了，scrollView 就会传递 touchCancelled 事件给 cell。</p>
<p>而如果将默认值为 YES 的 delaysContentTouches 属性设置为 NO，则不会启动此定时器，直接触发 cell 的 touchBegin 事件。</p>
<h3 id="高亮效果"><a href="#高亮效果" class="headerlink" title="高亮效果"></a>高亮效果</h3><p>但是高亮效果是由 UICollectionView 确定的，为什么不设置 delaysContentTouches 为 NO 就不能出现高亮效果呢。</p>
<p>我对 UICollectionView 一些关键的代理方法做了埋点打印处理，具体如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)collectionView : (<span class="built_in">UICollectionView</span> *)collectionView didHighlightItemAtIndexPath : (<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didHighlight"</span>);</span><br><span class="line">    [collectionView cellForItemAtIndexPath:indexPath].contentView.backgroundColor = HEXCOLOR(<span class="number">0xF5F5F5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didUnhighlightItemAtIndexPath : (<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didUnHighlight"</span>);</span><br><span class="line">    [collectionView cellForItemAtIndexPath:indexPath].contentView.backgroundColor = IMERCHANT_WHITE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didSelectItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didSelectItemAtIndexPath"</span>);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时对 cell 的手势处理方法进行了覆写</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"touchesBegan"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"touchesEnded1"</span>);</span><br><span class="line">    [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"touchesEnded2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别对 delaysContentTouches 为 NO 和 YES 的情况进行五次点击测试后，得出如下数据</p>
<ul>
<li>delaysContentTouches = NO，快速点击变色</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">39.942214</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22929</span>:<span class="number">9571394</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">39.942469</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22929</span>:<span class="number">9571394</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">39.986804</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22929</span>:<span class="number">9571394</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">39.987212</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22929</span>:<span class="number">9571394</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">39.987573</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22929</span>:<span class="number">9571394</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">39.987737</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22929</span>:<span class="number">9571394</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">48.398848</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">48.399059</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">48.443024</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">48.443397</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">48.443793</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">48.444018</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">57.665995</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">57.666365</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">57.727243</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">57.727588</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">57.727932</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">57.728064</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">08.884289</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">08.884659</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">08.945185</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">08.945578</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">08.946008</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">08.946153</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.736691</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.737061</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.781248</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.781590</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.782002</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">18</span>:<span class="number">28.782147</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22936</span>:<span class="number">9574330</span>] touchesEnded2</span><br></pre></td></tr></table></figure>

<ul>
<li>delaysContentTouches = YES，快速点击不变色</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">13</span>:<span class="number">25.126845</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">13</span>:<span class="number">25.127143</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">13</span>:<span class="number">25.127362</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">13</span>:<span class="number">25.127587</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">13</span>:<span class="number">25.127891</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">13</span>:<span class="number">25.128023</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">33.459640</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">33.459983</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">33.460154</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">33.460321</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">33.460587</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">33.460714</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">33.733329</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">33.733524</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">33.733674</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">33.733760</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">33.733864</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">16</span>:<span class="number">33.733975</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">01.455392</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">01.455700</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">01.455874</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">01.456044</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">01.456308</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">01.456486</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">14.455519</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">14.455864</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">14.456056</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">14.456232</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">14.456488</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">17</span>:<span class="number">14.456613</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22932</span>:<span class="number">9572093</span>] touchesEnded2</span><br></pre></td></tr></table></figure>

<p>最终统计 didHighlight 和 didUnHighlight 之间的时间间隔，得到数据如下，时间单位为秒。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>delaysContentTouches = NO</th>
<th>delaysContentTouches = YES</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0.044998</td>
<td>0.000742</td>
</tr>
<tr>
<td>2</td>
<td>0.044935</td>
<td>0.000681</td>
</tr>
<tr>
<td>3</td>
<td>0.061593</td>
<td>0.000431</td>
</tr>
<tr>
<td>4</td>
<td>0.061289</td>
<td>0.000652</td>
</tr>
<tr>
<td>5</td>
<td>0.044899</td>
<td>0.000713</td>
</tr>
<tr>
<td>平均值</td>
<td>0.0515428</td>
<td>0.0006438</td>
</tr>
</tbody></table>
<p>可以看出当 delaysContentTouches = YES 时，highlight 和 unhighlight 之间间隔比 delaysContentTouches = NO 时小了两个数量级，所以推测出 delaysContentTouches = YES 时不变色的 <strong>可能原因</strong> 是变色过快，不能被肉眼察觉。另外值得注意的是，大量耗时过程发生在 touchesBegan 与 touchesEnd 之间。</p>
<p>进一步对 <code>- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</code> 方法进行埋点打印，多次测试后发现如下数据</p>
<ul>
<li>delaysContentTouches = YES 时不会触发 touchesMoved 事件</li>
<li>delaysContentTouches = NO 时可能触发 touchesMoved 事件</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">delaysContentTouches = NO</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.278930</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.279310</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.292573</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] touchMoved</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.308281</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] touchMoved</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.340444</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.340753</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.341192</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">33.341400</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22948</span>:<span class="number">9583284</span>] touchesEnded2</span><br><span class="line"></span><br><span class="line">delaysContentTouches = YES</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">37</span>:<span class="number">12.255610</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22945</span>:<span class="number">9582286</span>] didHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">37</span>:<span class="number">12.255807</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22945</span>:<span class="number">9582286</span>] touchesBegan</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">37</span>:<span class="number">12.256025</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22945</span>:<span class="number">9582286</span>] touchesEnded1</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">37</span>:<span class="number">12.256137</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22945</span>:<span class="number">9582286</span>] didUnHighlight</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">37</span>:<span class="number">12.256255</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22945</span>:<span class="number">9582286</span>] didSelectItemAtIndexPath</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-28</span> <span class="number">09</span>:<span class="number">37</span>:<span class="number">12.256366</span>+<span class="number">0800</span> MTBCYAlbumKit[<span class="number">22945</span>:<span class="number">9582286</span>] touchesEnded2</span><br></pre></td></tr></table></figure>

<p>所以 delaysContentTouches = NO 时大部分间隔发生在 touchBegin 和 touchEnd 之间，推测 <strong>可能原因</strong> 是 cell 进行 touchesMoved 检测导致的时间消耗。</p>
<p>而网上对于实现 collectionView 点击高亮的补充说明通常如下</p>
<blockquote>
<p>然而如果你实现了 本文介绍的 这个两个方法改变选中颜色，你会发现只有长按时才会看到设置的颜色。</p>
<p>原因：长按没有松手的时候，触发的是高亮方法，松手触发的是取消高亮的方法。轻触点击的时候会很快速的响应 高亮和取消高亮的方法，所以看不到颜色的改变。此时，需要设置delaysContentTouches属性为NO，此时当点击的时候会立刻调用点击事件的begin方法，率先变成高亮状态。</p>
</blockquote>
<p>其实真正耗时的操作并不是 begin 之前，而是在 begin 之后，end 之前。</p>
<h3 id="canCancelContentTouches"><a href="#canCancelContentTouches" class="headerlink" title="canCancelContentTouches"></a>canCancelContentTouches</h3><p>与 delaysContentTouches 相关的属性还有一个 canCancelContentTouches 属性，它的含义如下</p>
<blockquote>
<p>A Boolean value that controls whether touches in the content view always lead to tracking.</p>
<p>If the value of this property is YES and a view in the content has begun tracking a finger touching it, and if the user drags the finger enough to initiate a scroll, the view receives a touchesCancelled:withEvent: message and the scroll view handles the touch as a scroll. If the value of this property is NO, the scroll view does not scroll regardless of finger movement once the content view starts tracking.</p>
</blockquote>
<p>也就是可以控制当一个子控件开始跟踪触摸事件后，能否接收 touchesCancelled 事件从而取消事件处理过程。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
  </entry>
  <entry>
    <title>修正UIImage的Orientation属性</title>
    <url>/2018/02/28/iOS%E5%BC%80%E5%8F%91/%E4%BF%AE%E6%AD%A3UIImage%E7%9A%84Orientation%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>在 iOS 中展示图片时有时会遇到图片颠倒或者旋转展示的情况，通常来说这与图片的 orientation 值有关系。</p>
<h2 id="照片的“方向”"><a href="#照片的“方向”" class="headerlink" title="照片的“方向”"></a>照片的“方向”</h2><p>相机拍摄照片时是没有方向概念的，只有使用者明确照片按照什么方向放置最合适，因此对于同一个方向的物体，例如 ^ 上箭头，相机可能的拍摄角度就有上下左右四种，能拍出 ^（上）、V（下）、&lt;（左）、&gt;（右） 这四种情况，而相机并不知道如何放置能正确表现其拍摄内容的方向性。所以现代相机中加入了方向传感器，能将拍摄时的相机方向记录下来，需要显示图片的数字设备就可以根据相机的方向信息来正确摆放目标图片达到合理展示效果。</p>
<p>而这一方向信息就存放于图像的 Exif 中。EXIF 是一种可交换图像文件格式，可以附加于 JPEG、TIFF、RIFF 格式的图像文件中，包含拍摄信息的内容和索引图或图像处理软件的版本等信息，也包括这里的方向信息 orientation。</p>
<p>orientation 定义了八个值</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>0th Row</th>
<th>0th Column</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>top</td>
<td>left side</td>
</tr>
<tr>
<td>2</td>
<td>top</td>
<td>right side</td>
</tr>
<tr>
<td>3</td>
<td>bottom</td>
<td>right side</td>
</tr>
<tr>
<td>4</td>
<td>bottom</td>
<td>left side</td>
</tr>
<tr>
<td>5</td>
<td>left side</td>
<td>top</td>
</tr>
<tr>
<td>6</td>
<td>right side</td>
<td>top</td>
</tr>
<tr>
<td>7</td>
<td>right side</td>
<td>bottom</td>
</tr>
<tr>
<td>8</td>
<td>left side</td>
<td>bottom</td>
</tr>
</tbody></table>
<p>它们具体的区分如下图所示</p>
<img src="https://github.com/Yasic/FixImageOrientation/blob/master/SampleImage/EXIFOrientation.png?raw=true" width=500>

<p>从图中可以看到，表格将图片的 0th Row 定义为顶边线，0th Column 定义为左边线。例如，对于 orientation 为 1，顶边线就在顶部，左边线就在左边，所以这张照片就是以正常视角拍出来的。</p>
<h2 id="正确展示照片"><a href="#正确展示照片" class="headerlink" title="正确展示照片"></a>正确展示照片</h2><p>当我们需要在 iOS 中展示一个图片对象 UIImage 时，我们可以通过 UIImage 的 imageOrientation 属性获取到它的 orientation 信息，这是一个枚举值，它的定义如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIImageOrientation</span>) &#123;</span><br><span class="line">    <span class="built_in">UIImageOrientationUp</span>,            <span class="comment">// default orientation</span></span><br><span class="line">    <span class="built_in">UIImageOrientationDown</span>,          <span class="comment">// 180 deg rotation</span></span><br><span class="line">    <span class="built_in">UIImageOrientationLeft</span>,          <span class="comment">// 90 deg CCW</span></span><br><span class="line">    <span class="built_in">UIImageOrientationRight</span>,         <span class="comment">// 90 deg CW</span></span><br><span class="line">    <span class="built_in">UIImageOrientationUpMirrored</span>,    <span class="comment">// as above but image mirrored along other axis. horizontal flip</span></span><br><span class="line">    <span class="built_in">UIImageOrientationDownMirrored</span>,  <span class="comment">// horizontal flip</span></span><br><span class="line">    <span class="built_in">UIImageOrientationLeftMirrored</span>,  <span class="comment">// vertical flip</span></span><br><span class="line">    <span class="built_in">UIImageOrientationRightMirrored</span>, <span class="comment">// vertical flip</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应到图片如下</p>
<img src="https://github.com/Yasic/FixImageOrientation/blob/master/SampleImage/UIImageOrientation.png?raw=true" width=500>

<p>所以可以根据 UIImage 的 orientation 属性对 UIImage 做矩阵变换，获得正确方向下的图片再展示，就不会出现展示的图片旋转颠倒的情况了。</p>
<p>Github 有一个 UIImage 的 <a href="https://gist.github.com/alex-cellcity/1531596" target="_blank" rel="noopener">category</a> 流传很广，就是解决这一问题的，恰好在项目的历史代码中看到了，下面是源码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)fixOrientation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No-op if the orientation is already correct</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageOrientation == <span class="built_in">UIImageOrientationUp</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to calculate the proper transformation to make the image upright.</span></span><br><span class="line">    <span class="comment">// We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.imageOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDown</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.width, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="number">0</span>, <span class="keyword">self</span>.size.height);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformRotate</span>(transform, -M_PI_2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.imageOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationUpMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationDownMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.width, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="keyword">self</span>.size.height, <span class="number">0</span>);</span><br><span class="line">            transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now we draw the underlying CGImage into a new context, applying the transform</span></span><br><span class="line">    <span class="comment">// calculated above.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height,</span><br><span class="line">                                             <span class="built_in">CGImageGetBitsPerComponent</span>(<span class="keyword">self</span>.CGImage), <span class="number">0</span>,</span><br><span class="line">                                             <span class="built_in">CGImageGetColorSpace</span>(<span class="keyword">self</span>.CGImage),</span><br><span class="line">                                             <span class="built_in">CGImageGetBitmapInfo</span>(<span class="keyword">self</span>.CGImage));</span><br><span class="line">    <span class="built_in">CGContextConcatCTM</span>(ctx, transform);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.imageOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">            <span class="comment">// Grr...</span></span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span>.size.height,<span class="keyword">self</span>.size.width), <span class="keyword">self</span>.CGImage);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">self</span>.size.width,<span class="keyword">self</span>.size.height), <span class="keyword">self</span>.CGImage);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// And now we just create a new UIImage from the drawing context</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> cgimg = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">    <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithCGImage:cgimg];</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(ctx);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(cgimg);</span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了 CGAffineTransform 类来做矩阵变换，要注意一点是，合并两个 Transform 有两种方式，一种是 CGAffineTransformConcat(T1, T2)，它的执行顺序是 T1 -&gt; T2，一种是 CGAffineTransformXXX(T1, T2)，它的执行顺序是 T2 -&gt; T1，所以在这里要注意所有变换操作都是后加入的先执行。</p>
<p>fixOrientation 的基本思路是</p>
<ul>
<li>如果 orientation 为 UIImageOrientationUp 则不需要变换</li>
<li>否则，首先对于镜像类 orientation 先恢复原样，变为非镜像</li>
<li>对于非镜像类 orientation，旋转回正常方向</li>
<li>根据旋转后的方向，利用 CoreGraphic 得到 UIImage 后返回</li>
</ul>
<p>其中会有一些必要的移位操作，下面以 UIImageOrientationRightMirrored 为例进行具体操作说明</p>
<ul>
<li>这是 orientation 为 UIImageOrientationRightMirrored 的图片</li>
</ul>
<img src="https://github.com/Yasic/FixImageOrientation/blob/master/SampleImage/Step01.png?raw=true" width=300>

<ul>
<li><code>transform = CGAffineTransformScale(transform, -1, 1)</code> 将图片进行镜像还原</li>
</ul>
<img src="https://github.com/Yasic/FixImageOrientation/blob/master/SampleImage/Step02.png?raw=true" width=300>

<ul>
<li><code>transform = CGAffineTransformTranslate(transform, image.size.height, 0)</code>将图片移动到坐标原点</li>
</ul>
<img src="https://github.com/Yasic/FixImageOrientation/blob/master/SampleImage/Step03.png?raw=true" width=300>

<ul>
<li><code>transform = CGAffineTransformRotate(transform, -M_PI_2)</code> 将图片顺时针旋转 90 度</li>
</ul>
<img src="https://github.com/Yasic/FixImageOrientation/blob/master/SampleImage/Step04.png?raw=true" width=300>

<ul>
<li><code>transform = CGAffineTransformTranslate(transform, 0, image.size.height)</code> 将图片移动到坐标原点</li>
</ul>
<img src="https://github.com/Yasic/FixImageOrientation/blob/master/SampleImage/Step05.png?raw=true" width=300>

<p>这里还要注意一点，在最后进行 drawImage 操作时代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (image.imageOrientation) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeft</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIImageOrientationLeftMirrored</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIImageOrientationRight</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">UIImageOrientationRightMirrored</span>:</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,image.size.height,image.size.width), image.CGImage);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,image.size.width,image.size.height), image.CGImage);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于左右放置的图片，由于进行了旋转操作，因此最终进行 drawImage 时，rect 需要进行长宽变换。</p>
<p>而实际上，UIImage 的 drawInRect 方法已经实现了这一过程，并自动返回调整后的图片，且图片 orientation 为 UIImageOrientationUp。</p>
<blockquote>
<p>This method draws the entire image in the current graphics context, respecting the image’s orientation setting. In the default coordinate system, images are situated down and to the right of the origin of the specified rectangle. This method respects any transforms applied to the current graphics context, however.</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift可选类型、隐式可选类型与可选链</title>
    <url>/2018/02/02/iOS%E5%BC%80%E5%8F%91/Swift%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%E3%80%81%E9%9A%90%E5%BC%8F%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%AF%E9%80%89%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Swift-可选类型、隐式可选类型与可选链"><a href="#Swift-可选类型、隐式可选类型与可选链" class="headerlink" title="Swift 可选类型、隐式可选类型与可选链"></a>Swift 可选类型、隐式可选类型与可选链</h1><p>在 OC 中 nil 表示一个指向不存在的对象的指针，而 Swift 中 nil 不是指针，而是一个确定的值，它表示一切值缺失的情况，所谓值缺失就是一个和 Swift 的可选类型相关的概念。</p>
<h2 id="可选类型-optional"><a href="#可选类型-optional" class="headerlink" title="可选类型 optional"></a>可选类型 optional</h2><p>可选类型的变量可以有值，也可以无值，无值的变量取值得到的就是 nil，相对应的，非可选类型的变量必须有值，也不能赋值为 nil，如果没有值就会报编译期错误。Swift 声明一个变量时默认情况下就是非可选的，即必须给这个变量赋值一个非空值。之所以引入可选类型和非可选类型是为了增强便一阶段的安全检查，对于因 nil 引发的崩溃可以在编译期就检查出来，避免崩溃发现时间延时到运行时。</p>
<p>声明一个可选类型变量和不可选类型变量如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalVariable:<span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> nonOptionalVariable:<span class="type">String</span> = <span class="string">"Yasic"</span></span><br></pre></td></tr></table></figure>

<p>当然可选类型变量默认不赋值的时候就是 nil，并且对于一个类中的非可选类型变量，也可以将赋值操作延时到初始化 init 方法 中。</p>
<p>那么对于非可选类型参数就可以安全取值安全使用了，而可选类型参数则需要在使用前检查变量是否有值，通常我们会这样检查</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> optionalVariable != <span class="literal">nil</span> &#123;</span><br><span class="line">    optionalVariable!.append(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中用到了感叹号运算符，它表示对可选值的强制解析，表明开发者明确知道这个可选类型变量在此处是有值的所以强制从中取值，但是如果变量中的确没有值就会引发运行时崩溃了。</p>
<p>所以强制解析功能应当谨慎使用，Swift 更推荐的方式是可选绑定(Optional Binding)，与强制解析不同，可选绑定会判断可选类型是否有值，如果有值就将其赋值给一个临时常量或变量，可选绑定可以用在 if 和 while 语句中来对可选类型的值进行判断后赋值给临时常量或变量。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tempVariable = <span class="keyword">self</span>.optionalVariable &#123;</span><br><span class="line">    <span class="built_in">print</span>(tempVariable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>临时变量也可以是 var 型的，从而可以在分支中改变它的值。在分支中使用到临时变量时能保证它一定值，从而就避免了强制解析的过程。</p>
<h2 id="隐式可选类型"><a href="#隐式可选类型" class="headerlink" title="隐式可选类型"></a>隐式可选类型</h2><p>可选类型变量增强了代码的安全性，但是每次使用到可选类型变量都需要加判断或者强制解析比较麻烦，这时可以利用隐式可选类型。隐式可选类型实际就是一个普通的可选类型，但是开发者明确知道此可选类型变量在第一次赋值后一定总有值，从而用隐式可选类型省却了强制解析的过程。</p>
<p>声明一个隐式可选类型的方式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hiddenOptinalVariable:<span class="type">String!</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>使用时可以直接取值，此时表明开发者能明确保证可以取到值，但是如果的确没有值，就会引发运行时崩溃。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">hiddenOptinalVariable.append(<span class="string">"yasic"</span>)</span><br></pre></td></tr></table></figure>

<p>当然也可以用上面的方法对隐式可选类型进行判空</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> var temp = <span class="keyword">self</span>.hiddenOptinalVariable &#123;</span><br><span class="line">    temp.append(<span class="string">"yasic"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可选类型的应用"><a href="#可选类型的应用" class="headerlink" title="可选类型的应用"></a>可选类型的应用</h2><h3 id="空合运算符-Nil-Coalescing-Operator"><a href="#空合运算符-Nil-Coalescing-Operator" class="headerlink" title="空合运算符 Nil Coalescing Operator"></a>空合运算符 Nil Coalescing Operator</h3><p>空合运算符 “??” 是对三目运算符的简化，针对可选类型变量 a 进行空判断，若非空则返回 a 的变量值，否则返回空合运算符后的默认值 b。它的使用有两个条件</p>
<ul>
<li>a 必须是可选类型</li>
<li>b 的类型必须与 a 一致</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">self</span>.hiddenOptinalVariable ?? <span class="string">"123"</span></span><br></pre></td></tr></table></figure>

<h3 id="方法返回可选类型值"><a href="#方法返回可选类型值" class="headerlink" title="方法返回可选类型值"></a>方法返回可选类型值</h3><p>可选类型变量可以出现在方法的返回值当中，表明此方法的返回值能为 nil</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnOptinalVariable</span><span class="params">(input:Bool)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !input &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"true"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类返回可选类型对象"><a href="#类返回可选类型对象" class="headerlink" title="类返回可选类型对象"></a>类返回可选类型对象</h3><p>对于 Swift 的类有一个特殊的方法，构造方法 init，这个方法也可以返回一个可选类型的值，它的主要意义在于能够根据初始化时传入的值以及环境参数来判断是否可以返回一个实例对象，通常也称这类构造方法为可失败构造器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>?(input:<span class="type">Bool</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> !input &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭包返回可选类型值"><a href="#闭包返回可选类型值" class="headerlink" title="闭包返回可选类型值"></a>闭包返回可选类型值</h3><p>闭包返回可选类型闭包，表明此闭包可能为 nil</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnOptionalBlock</span><span class="params">(value: Bool)</span></span> -&gt; (() -&gt; (<span class="type">Void</span>))? &#123;</span><br><span class="line">    <span class="keyword">if</span> value &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; () <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"可选闭包"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> voidBlock = <span class="keyword">self</span>.returnOptionalBlock(value: <span class="literal">false</span>) &#123;</span><br><span class="line">    voidBlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意对于为 nil 的闭包进行强制解析执行会发生运行时错误 “Fatal error: Unexpectedly found nil while unwrapping an Optional value”。</p>
<h3 id="结构体和枚举的可失败构造器"><a href="#结构体和枚举的可失败构造器" class="headerlink" title="结构体和枚举的可失败构造器"></a>结构体和枚举的可失败构造器</h3><p>类似类的可失败构造器，结构体的可失败构造器也是支持的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OperationError</span>:<span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorFirst</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorSecond</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorThird</span></span><br><span class="line">    <span class="keyword">init</span>?(type:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> type &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"first"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">ErrorFirst</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"second"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">ErrorSecond</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"third"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">ErrorThird</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123; <span class="comment">// 可失败构造器</span></span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125; <span class="comment">// 如果实例化为空串，则返回nil(即实例化失败)</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理中的可选类型"><a href="#错误处理中的可选类型" class="headerlink" title="错误处理中的可选类型"></a>错误处理中的可选类型</h3><p>对于可能抛出错误的方法调用时应当使用 try 语法来捕捉错误，当然有时候并不对捕捉到的错误进行处理，此时代码可能会写成这个样子</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> picture = <span class="keyword">try</span>! loadImage(atPath: <span class="string">"..."</span>)</span><br></pre></td></tr></table></figure>

<p>这样其实是禁止了错误的抛出，一旦有错误时就会崩溃，所以建议的语法如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> picture = <span class="keyword">try</span>? loadImage(atPath: <span class="string">"..."</span>)</span><br></pre></td></tr></table></figure>

<h3 id="类型转换中的可选类型"><a href="#类型转换中的可选类型" class="headerlink" title="类型转换中的可选类型"></a>类型转换中的可选类型</h3><p>对于某种类型的变量进行向上转换时不会出现失败的情况，但是向下转型就可能会失败</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yasic = <span class="type">Person</span>(name: <span class="string">"Yasic"</span>)</span><br><span class="line"><span class="keyword">let</span> yasicCopy = yasic <span class="keyword">as</span> <span class="type">Male</span></span><br></pre></td></tr></table></figure>

<p>这样做会有编译期报错 <code>&#39;Person&#39; is not convertible to &#39;Male&#39;; did you mean to use &#39;as!&#39; to force downcast?</code></p>
<p>此时建议使用可选绑定来进行类型向下转换</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> yasic = <span class="type">Person</span>(name: <span class="string">"Yasic"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> yasicCopy = yasic <span class="keyword">as</span>? <span class="type">Male</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可选链-Optional-Chaining"><a href="#可选链-Optional-Chaining" class="headerlink" title="可选链 Optional Chaining"></a>可选链 Optional Chaining</h2><p>Swift 对可选链的定义如下</p>
<blockquote>
<p>可选链是一种可以请求和调用属性、方法及下标脚本的过程，它的可选性体现在请求或调用的目标当前可能为空 nil。如果可选的目标有值，那么调用就会成功；相反，如果可选的目标为 nil，那么调用就会返回 nil。多次请求或调用可以被链接在一起形成一个链，如果任何一个节点为空 nil 将导致整个链失效。</p>
</blockquote>
<p>此处假设有两个类 Person 和 Room</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> room:<span class="type">Room?</span></span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">nameStr</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> name = <span class="keyword">self</span>.name &#123;</span><br><span class="line">           <span class="keyword">return</span> name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> roomAddr:<span class="type">String?</span></span><br><span class="line">    <span class="keyword">var</span> roomArea:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> people:[<span class="type">String</span>]?</span><br><span class="line">    <span class="keyword">init</span>(roomAddr:<span class="type">String</span>, roomArea:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.roomAddr = roomAddr</span><br><span class="line">        <span class="keyword">self</span>.roomArea = roomArea</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">roomAddrStr</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> addr = <span class="keyword">self</span>.roomAddr &#123;</span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Person 有一个可选类型的成员变量 room，表示它可能为 nil，也可能有值，还有一个返回可选类型值的方法 nameStr，Room 类也有一个返回可选类型值的方法 roomAddrStr。</p>
<p>下面是一些具体的使用</p>
<ul>
<li>可选链调用属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> area = yasic.room?.roomArea &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样获取的就是一个 Int? 类型的值，而不是 roomArea 所定义的 Int 类型。</p>
<ul>
<li>可选链调用方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = yasic.room?.roomAddrStr() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可选链访问数组下标</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = yasic.room?.people?[<span class="number">1</span>] &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是可选链始终返回的是可选类型变量，不会因为最后一层的变量是非可选类型变量就返回非可选类型变量，并且可选链中任意一节失败就会直接返回 nil。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoLayout指南·AutoLayout Cookbook·StackView</title>
    <url>/2018/01/23/AutoLayout/AutoLayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20Cookbook%C2%B7StackView/</url>
    <content><![CDATA[<h1 id="AutoLayout指南·AutoLayout-Cookbook"><a href="#AutoLayout指南·AutoLayout-Cookbook" class="headerlink" title="AutoLayout指南·AutoLayout Cookbook"></a>AutoLayout指南·AutoLayout Cookbook</h1><h2 id="StackView"><a href="#StackView" class="headerlink" title="StackView"></a>StackView</h2><p>下面的指南将会向你展示如何使用 StackView 来创建比较复杂的布局。StackView 是一个非常有用的工具，它可以方便快捷地设计出你的用户界面。它的属性允许你很高程度地控制它对子视图的布局设置。你可以通过一些附加的自定义约束来增强这些设置，但是这样也会增加布局的复杂度。</p>
<p>查看此指南的源码请查阅 <a href="https://developer.apple.com/sample-code/xcode/downloads/Auto-Layout-Cookbook.zip" target="_blank" rel="noopener">Auto Layout Cookbook</a></p>
<h3 id="简单的-StackView"><a href="#简单的-StackView" class="headerlink" title="简单的 StackView"></a>简单的 StackView</h3><p>这里我们用一个垂直的 StackView 来布局一个 label、一个 imageview、一个 button。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Simple_Stack_View_Screenshot_2x.png" width=500>

<h4 id="视图和约束"><a href="#视图和约束" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>在 Interface Builder 中，首先拖进一个垂直的 StackView，然后添加一个 flower label，一个 imageview，一个编辑的 button，然后将它们的约束配置成下图</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/simple_stack_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Stack</span> View.Leading = Superview.LeadingMargin</span><br><span class="line"><span class="keyword">Stack</span> View.Trailing = Superview.TrailingMargin</span><br><span class="line"><span class="keyword">Stack</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Stack</span> View.<span class="keyword">Bottom</span> + Standard</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>在属性检查器中，需要设置下列 StackView 属性</p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Axis</th>
<th>Alignment</th>
<th>Distribution</th>
<th>Spacing</th>
</tr>
</thead>
<tbody><tr>
<td>StackView</td>
<td>Vertical</td>
<td>Fill</td>
<td>Fill</td>
<td>8</td>
</tr>
</tbody></table>
<p>然后将 imageview 属性设置如下</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>ImageView</td>
<td>Image</td>
<td>一个花朵的图片</td>
</tr>
<tr>
<td>ImageView</td>
<td>Mode</td>
<td>Aspect Fit</td>
</tr>
</tbody></table>
<p>最后在属性检查器中将 imageview 的 content-hugging 和 compression-resistance（CHCR）优先级设置如下</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Horizontal hugging</th>
<th>Verticle hugging</th>
<th>Horizontal resistance</th>
<th>Vertical resistance</th>
</tr>
</thead>
<tbody><tr>
<td>Imageview</td>
<td>250</td>
<td>249</td>
<td>750</td>
<td>749</td>
</tr>
</tbody></table>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>你必须将 StackView 加到父 view 上，否则 StackView 就会因为缺少参考约束而无法设置整个布局。</p>
<p>在这里我们将 StackView 填充父 view，并设置了一个很小的标准边距。而 StackView 的子视图将会重新设置尺寸以填充 StackView 的内部区域。水平方向上，所有的 view 都会被拉伸以匹配 StackView 的宽度。竖直方向上，view 会按照它们的 CHCR 优先级而被拉伸。由于 Imageview 要始终保持填满可填充区域，所以它的 Vertical content-hugging 和 compression-resistance 优先级要低于 label 和 button 的默认优先级。</p>
<p>最后我们设置了 Imageview 的展示模式为 Aspect Fit。这个设置强制使 imageView 调整自身 image，让图片以不改变宽高比的方式适应进 imageView 中。这样可以保证在 StackView 任意改变 Imageview 的尺寸时不会让它上面的 image 改变自身宽高比而导致图片扭曲变形。</p>
<h3 id="嵌套-StackView"><a href="#嵌套-StackView" class="headerlink" title="嵌套 StackView"></a>嵌套 StackView</h3><p>这里我们将用嵌套 StackView 的方式实现一个比较复杂的多层布局。但是在示例中仅凭 StackView 是不能完成效果的，还要借助一些约束来更好的配置布局。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Nested_Stack_Views_Screenshot_2x.png" width=500>

<p>我们会在构建完视图层级后，在下一节 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW12" target="_blank" rel="noopener">Views and Constraints</a> 添加额外的约束。</p>
<h4 id="视图和约束-1"><a href="#视图和约束-1" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>当使用内嵌的 stackView 时，从内向外布局是最容易的。首先将姓名行放置在 IB 中，然后将 label 和 textfield 放置在正确的位置，选中它们然后点击 Editor-&gt;Embed In-&gt;Stack View 选项，这样就创建了一个水平的 StackView 来装载这一行。</p>
<p>然后将这些行水平放置好，选中所有姓名行，再次点击 Editor-&gt;Embed In-&gt;Stack View。这样就创建了一个水平 StackView 来装载所有姓名行。依据下图继续创建界面。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/nested_stack_views_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Root</span> <span class="keyword">Stack</span> View.Leading = Superview.LeadingMargin</span><br><span class="line"><span class="keyword">Root</span> <span class="keyword">Stack</span> View.Trailing = Superview.TrailingMargin</span><br><span class="line"><span class="keyword">Root</span> <span class="keyword">Stack</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Root</span> <span class="keyword">Stack</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"><span class="keyword">Image</span> View.Height = <span class="keyword">Image</span> View.Width</span><br><span class="line"><span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Width = Middle Name <span class="keyword">Text</span> Field.Width</span><br><span class="line"><span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Width = <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.Width</span><br></pre></td></tr></table></figure>

<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>每一个 StackView 都有其自己的属性集合，这些属性定义了 StackView 如何布局它的子视图。在属性检查器中设置这些属性</p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Axis</th>
<th>Alignment</th>
<th>Distribution</th>
<th>Spacing</th>
</tr>
</thead>
<tbody><tr>
<td>First Name</td>
<td>Horizontal</td>
<td>First Baseline</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Middle Name</td>
<td>Horizontal</td>
<td>First Baseline</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Last Name</td>
<td>Horizontal</td>
<td>First Baseline</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>NameRows</td>
<td>Vertical</td>
<td>Fill</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Upper</td>
<td>Horizontal</td>
<td>Fill</td>
<td>Fill</td>
<td>8</td>
</tr>
<tr>
<td>Button</td>
<td>horizontal</td>
<td>First Baseline</td>
<td>Fill Equally</td>
<td>8</td>
</tr>
<tr>
<td>Root</td>
<td>Vertical</td>
<td>Fill</td>
<td>Fill</td>
<td>8</td>
</tr>
</tbody></table>
<p>另外，对 textView，需要设置一个亮灰色背景颜色，从而可以看出当设备旋转时 textview 是如何重新计算尺寸的。</p>
<p>|View|Attribute|Value|<br>|textView|Background|Light Gray Color|</p>
<p>最后在属性检查器中设置 view 的 CHCR 优先级</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Horizontal hugging</th>
<th>Verticle hugging</th>
<th>Horizontal resistance</th>
<th>Vertical resistance</th>
</tr>
</thead>
<tbody><tr>
<td>ImageView</td>
<td>250</td>
<td>250</td>
<td>48</td>
<td>48</td>
</tr>
<tr>
<td>TextView</td>
<td>250</td>
<td>249</td>
<td>250</td>
<td>250</td>
</tr>
<tr>
<td>First,Middle,Last Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>First,Middle,Last Name textfield</td>
<td>48</td>
<td>250</td>
<td>749</td>
<td>750</td>
</tr>
</tbody></table>
<h4 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h4><p>在这里，我们用多个 StackView 创建了大部分的布局，但是并不能完全依靠 StackView 来实现所有想要的效果。例如我们想让图片在 imageview 改变尺寸时保持自己的长宽比，就无法使用 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW2" target="_blank" rel="noopener">Simple Stack View</a> 中的技术来实现了。这个布局需要紧贴图片的边线，而使用 Aspect Fit 模式会在横向或纵向的某个维度上添加额外的空白。幸运的是，在这个例子中我们用到的图片都是正方形的，所以你可以确保图片一定能完美地紧贴边线，同时将图片的长宽比约束为 1：1。</p>
<blockquote>
<p>注意</p>
<p>在 IB 中一个长宽比约束代表一个 view 的长宽之间的约束，IB 还可以用一些方法来设置长宽比约束的乘数因子，一般来说 IB 会将约束表达为一个比率，例如一个表示宽高相等的约束可以表达为 1：1.</p>
</blockquote>
<p>另外，所有的 textfield 都要等宽度，不幸的是这些 textfield 都在不同的 StackView 中，所以这几个 StackView 无法实现自动让 textfield 等宽，因此，你必须显式地为这些 textfield 添加等宽约束。</p>
<p>同时就像示例中一样，你需要修改一些 CHCR 优先级，从而定义当父视图的区域变化时，view 如何伸缩。</p>
<p>垂直方向上，你想要 textView 扩展自己从而填满 upper Stack 和 button Stack 之间的空白区域，所以 textView 的 Vertical content-hugging 优先级就必须小于其他两个 Stackview 的 Vertical content-hugging 优先级。</p>
<p>水平方向上，label 需要按照其 intrinsic content size 来展示，而 textfield 要伸缩自己从而填满可填充区域。默认的 CHCR 优先级对于 label 来说可以实现这样的效果，因为 IB 已经将所有 label 的 content-hugging 设置为 251，保证其大于 textfield 的 content-hugging。但是你还是应该使 textfield 的 Horizontal content-hugging 和 Horizontal content-hugging 尽量小。</p>
<p>imageview 应当伸缩自身以保证其高度和包含三行 name 的 StackView 一致，然而 StackView 自身的 content-hugging 优先级是小于其子视图的，所以为了避免 StackView 被拉伸，而保证 imageview 被压缩来适应 StackView 的内部区域，需要将 imageview 的 Vertical compression resistance 设置非常低。另外，imageview 的长宽比使得布局变得较为复杂，因为长宽比使得水平约束与竖直约束互相之间发生了影响。这意味着 textfield 的 Horizontal content-hugging 必须非常小，或阻止 image view 压缩。考虑上述情况，需要将 textfield 的 Horizontal content-hugging 设置为小于 48 的值。<strong>此处有疑问</strong></p>
<h3 id="动态-StackView"><a href="#动态-StackView" class="headerlink" title="动态 StackView"></a>动态 StackView</h3><p>这里演示了如何在运行时动态向一个 StackView 添加和移除元素，并且所有发生在 StackView 的变化都有动画效果。另外还将 StackView 放进了一个 ScrollView 中，从而保证当列表中的元素过多时可以滑动查看。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Dynamic_Stack_View_Screenshot_2x.png" width=500>

<blockquote>
<p>注意</p>
<p>这里只是故意演示如何用 StackView 动态地实现布局效果，以及如何将 StackView 放进 scrollView 中使用。在一个需要实际上线的 app 中应当使用 UITableView 代替这种方式。一般来说，你不应当只是使用动态 StackView 来实现一个粗糙简陋的 TableView，而是应当将其用于实现一些其他技术无法方便实现的用户界面。</p>
</blockquote>
<h4 id="视图和约束-2"><a href="#视图和约束-2" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>初始界面很简单，你需要放置一个 scrollView 在 IB 的场景中，然后设置它的大小铺满整个场景，再把一个 StackView 放进 scrollView 中，并在 StackView 中加入一个添加元素的按钮。当所有元素都添加完毕后，将约束设置如下</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/dynamic_stack_view_2x.png" width=500>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Scroll <span class="keyword">View</span>.<span class="keyword">Leading</span> = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line">Scroll <span class="keyword">View</span>.<span class="keyword">Trailing</span> = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line">Scroll <span class="keyword">View</span>.Top = Superview.TopMargin</span><br><span class="line"></span><br><span class="line">Bottom Layout Guide.Top = Scroll <span class="keyword">View</span>.Bottom + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line">Stack <span class="keyword">View</span>.<span class="keyword">Leading</span> = Scroll <span class="keyword">View</span>.<span class="keyword">Leading</span></span><br><span class="line"></span><br><span class="line">Stack <span class="keyword">View</span>.<span class="keyword">Trailing</span> = Scroll <span class="keyword">View</span>.<span class="keyword">Trailing</span></span><br><span class="line"></span><br><span class="line">Stack <span class="keyword">View</span>.Top = Scroll <span class="keyword">View</span>.Top</span><br><span class="line"></span><br><span class="line">Stack <span class="keyword">View</span>.Bottom = Scroll <span class="keyword">View</span>.Bottom</span><br><span class="line"></span><br><span class="line">Stack <span class="keyword">View</span>.Width = Scroll <span class="keyword">View</span>.Width</span><br></pre></td></tr></table></figure>

<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>在属性检查器中，设置 StackView 的属性如下</p>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Axis</th>
<th>Alignment</th>
<th>Distribution</th>
<th>Spacing</th>
</tr>
</thead>
<tbody><tr>
<td>StackView</td>
<td>Vertical</td>
<td>Fill</td>
<td>Equal Spacing</td>
<td>0</td>
</tr>
</tbody></table>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>这里需要一些代码来实现向 StackView 添加和移除元素，所以为你的场景创建 ViewController，并添加 scrollView 和 StackView 的 outlet。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicStackViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">private</span> <span class="keyword">var</span> scrollView: <span class="type">UIScrollView!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">private</span> <span class="keyword">var</span> stackView: <span class="type">UIStackView!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Method implementations will go here...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来覆写 viewDidLoad 函数，设置 scrollView 的初始位置在状态栏下面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setup scrollview</span></span><br><span class="line">    <span class="keyword">let</span> insets = <span class="type">UIEdgeInsetsMake</span>(<span class="number">20.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    scrollView.contentInset = insets</span><br><span class="line">    scrollView.scrollIndicatorInsets = insets</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后给添加元素的按钮设置一个 action</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: Action Methods</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">addEntry</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> stack = stackView</span><br><span class="line">    <span class="keyword">let</span> index = stack.arrangedSubviews.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> addView = stack.arrangedSubviews[index]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> scroll = scrollView</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="type">CGPoint</span>(x: scroll.contentOffset.x,</span><br><span class="line">                         y: scroll.contentOffset.y + addView.frame.size.height)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> newView = createEntry()</span><br><span class="line">    newView.hidden = <span class="literal">true</span></span><br><span class="line">    stack.insertArrangedSubview(newView, atIndex: index)</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        newView.hidden = <span class="literal">false</span></span><br><span class="line">        scroll.contentOffset = offset</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法为 scrollView 计算了一个新的 offset 值，然后创建了一个新的实体视图并添加到 StackView 中，这个视图是隐藏的。隐藏的 view 不会影响到 StackView 的布局或界面。然后在动画代码块中，视图会被显示出来，scroll offset 也会被更新，同时伴随 view 的显示动画。</p>
<p>添加一个类似的方法用于删除实体。删除实体的方法不像 addEntity，这个方法不会与 IB 的任何控制器相连，app 将会在创建 view 时用代码配置每一个实体 view 与这个方法相连。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteStackView</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> view = sender.superview &#123;</span><br><span class="line">        <span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>, animations: &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            view.hidden = <span class="literal">true</span></span><br><span class="line">        &#125;, completion: &#123; (success) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            view.removeFromSuperview()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法在动画代码块中隐藏了一个 view，动画结束后将这个 view 从视图层级中移除，同时也会自动从 StackView 的子视图列表中删除这个视图。</p>
<p>尽管实体 view 可以是任何 view，但我们在这里会将一个日期 label、一个显示随机十六进制数字的 label、一个删除按钮放进 StackView。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Private Methods</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">createEntry</span><span class="params">()</span></span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="type">NSDateFormatter</span>.localizedStringFromDate(<span class="type">NSDate</span>(), dateStyle: .<span class="type">ShortStyle</span>, timeStyle: .<span class="type">NoStyle</span>)</span><br><span class="line">    <span class="keyword">let</span> number = <span class="string">"\(randomHexQuad())-\(randomHexQuad())-\(randomHexQuad())-\(randomHexQuad())"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> stack = <span class="type">UIStackView</span>()</span><br><span class="line">    stack.axis = .<span class="type">Horizontal</span></span><br><span class="line">    stack.alignment = .<span class="type">FirstBaseline</span></span><br><span class="line">    stack.distribution = .<span class="type">Fill</span></span><br><span class="line">    stack.spacing = <span class="number">8</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> dateLabel = <span class="type">UILabel</span>()</span><br><span class="line">    dateLabel.text = date</span><br><span class="line">    dateLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> numberLabel = <span class="type">UILabel</span>()</span><br><span class="line">    numberLabel.text = number</span><br><span class="line">    numberLabel.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> deleteButton = <span class="type">UIButton</span>(type: .<span class="type">RoundedRect</span>)</span><br><span class="line">    deleteButton.setTitle(<span class="string">"Delete"</span>, forState: .<span class="type">Normal</span>)</span><br><span class="line">    deleteButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"deleteStackView:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    </span><br><span class="line">    stack.addArrangedSubview(dateLabel)</span><br><span class="line">    stack.addArrangedSubview(numberLabel)</span><br><span class="line">    stack.addArrangedSubview(deleteButton)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">randomHexQuad</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSString</span>(format: <span class="string">"%X%X%X%X"</span>,</span><br><span class="line">                    arc4random() % <span class="number">16</span>,</span><br><span class="line">                    arc4random() % <span class="number">16</span>,</span><br><span class="line">                    arc4random() % <span class="number">16</span>,</span><br><span class="line">                    arc4random() % <span class="number">16</span></span><br><span class="line">        ) <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h4><p>正如本节所演示的，视图可以在运行时被添加到或移除出 StackView，StackView 的布局会自动适应其子视图列表的变化。但是这里仍然有一些需要注意的点</p>
<ul>
<li>隐藏的视图仍然会被加入到 StackView 的子视图列表中，但是不会被显示也不会对其他子视图的布局产生影响</li>
<li>向 StackView 添加一个视图会自动将其加入到视图层级中</li>
<li>从 StackView 的子视图列表中移除一个视图不会将其移除出视图层级，但是将视图从视图层级移除时会自动从 StackView 的子视图列表中移除</li>
<li>在 iOS 中，view 的隐藏属性正常来说不会有动画效果，但是一旦将其放入到 StackView 的子视图列表中，隐藏属性就会带有动画效果了。真正的动画动作是由 StackView 而非 view 自身完成的，所以可以使用 hidden 属性实现添加删除 view 时的动画效果</li>
</ul>
<p>这一节也介绍了如何将 AutoLayout 与 scrollView 放在一起使用，这里利用了 StackView 与 scrollView 之间的约束来设置 scrollView 的内容区尺寸。垂直方向上，内容区尺寸会基于 StackView 的适应尺寸而变化。StackView 会因为内容区的元素增加而变长，scrollView 的滑动性会由于内容区元素超出一屏的内容而自动激活。</p>
<p>查看更多信息请看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithScrollViews.html#//apple_ref/doc/uid/TP40010853-CH24-SW1" target="_blank" rel="noopener">Working with Scroll Views</a></p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·AutoLayout 高级指南·使用ScrollView</title>
    <url>/2018/01/22/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%C2%B7%E4%BD%BF%E7%94%A8ScrollView/</url>
    <content><![CDATA[<h1 id="014-Autolayout指南·AutoLayout-高级指南"><a href="#014-Autolayout指南·AutoLayout-高级指南" class="headerlink" title="014-Autolayout指南·AutoLayout 高级指南"></a>014-Autolayout指南·AutoLayout 高级指南</h1><h2 id="使用-ScrollView"><a href="#使用-ScrollView" class="headerlink" title="使用 ScrollView"></a>使用 ScrollView</h2><p>当你使用 scrollView 时，需要定义 scrollView 的 frame 在父视图中的尺寸和位置，同时定义内容区域的尺寸。所有这些属性都可以用 AutoLayout 来设置。</p>
<p>为了支持 scrollView，系统会根据约束定位的位置不同来解释约束。</p>
<ul>
<li>与其他视图一样，scrollView 和 scrollView 外的对象之间的任何约束都会被附加到滚动视图的框架</li>
<li>对于 scrollView 及其内容之间的约束，展示行为会根据受约束的属性而变化<ul>
<li>scrollView 与其内容区的边缘和间距的约束会被附加到 scrollView 的内容区域</li>
<li>高度，宽度或坐标中心等约束会被附加到滚动视图的 frame 上</li>
</ul>
</li>
<li>你也可以使用 scrollView 的内容区和 scrollView 外部对象之间的约束来为 scrollView 的内容区提供一个固定的位置，使得内容区看起来像是浮动在 scrollView 上</li>
</ul>
<p>对于大多数常见的布局方案来说，如果使用虚拟视图或布局分组来包含 scrollView 的内容，逻辑就会变得容易很多，在使用 Interface Builder 进行这些操作时，一般步骤如下所示</p>
<ul>
<li>将 scrollView 添加到 scene 里</li>
<li>像平常一样拖曳约束来定义 scrollView 的尺寸和位置</li>
<li>向 scrollView 添加一个 view。设置 view 的 Xcode 特定标签为内容视图</li>
<li>将内容视图的顶部，底部，头部和尾部固定到滚动视图的相应边缘，内容视图就会被定义为 scrollView 的内容区域</li>
</ul>
<blockquote>
<p>提醒：</p>
<p>内容视图并没有一个固定的尺寸，它可以伸展和压缩来适应你放进去的任何 view 或 control</p>
</blockquote>
<ul>
<li>（可选的）设置内容视图的宽度等于 scrollView 的宽度可以使内容视图在水平方向上填满 scrollView，从而禁止水平方向上的滚动</li>
<li>（可选的）设置内容视图的高度等于 scrollView 的高度可以使内容视图在竖直方向上填满 scrollView，从而禁止竖直方向上的滚动</li>
<li>将 scrollView 的内容放置在内容视图里，和平常一样使用约束来定位内容视图内的内容</li>
</ul>
<blockquote>
<p>重要：</p>
<p>你的布局必须完全定义内容视图的尺寸（步骤 5 和 步骤 6 定义的除外）。要根据内容的 intrinsic size 来设置高度，你必须保证约束链和视图链从内容视图的顶边到底边有不间断的延伸。 同样，要设置宽度，你必须保证约束链和视图链从内容视图的前导边缘到后边缘有一个不间断的延伸。</p>
<p>如果你的内容没有固有内容尺寸，你必须为内容视图或内容设置一个适当的尺寸约束。</p>
<p>当内容视图比 scrollView 高度要高时，scrollView 就能够在垂直方向上滑动。当内容视图比 scrollView 宽度要宽时，scrollView 就能够在水平方向上滑动。否则默认情况下 scrollView 是不能滑动的。</p>
</blockquote>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·AutoLayout 高级指南·使用自适应高度TableViewCell</title>
    <url>/2018/01/22/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%C2%B7%E4%BD%BF%E7%94%A8%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6TableViewCell/</url>
    <content><![CDATA[<h1 id="015-Autolayout指南·AutoLayout-高级指南"><a href="#015-Autolayout指南·AutoLayout-高级指南" class="headerlink" title="015-Autolayout指南·AutoLayout 高级指南"></a>015-Autolayout指南·AutoLayout 高级指南</h1><h2 id="使用自适应高度-TableViewCell"><a href="#使用自适应高度-TableViewCell" class="headerlink" title="使用自适应高度 TableViewCell"></a>使用自适应高度 TableViewCell</h2><p>在 iOS 中你可以使用 AutoLayout 来定义一个 TableViewCell 的高度，但是这一特性默认是没有打开的。</p>
<p>一般来说，一个 cell 的高度是由 tableview 的代理对象的  tableView:heightForRowAtIndexPath: 来决定的。为了实现自适应高度的 TableViewCell，你必须设置 tableview 的 rowHeight 属性为 UITableViewAutomaticDimension，并为 tableview 的 estimatedRowHeight 属性设置一个值。一旦这两个属性都被设置了，系统就会使用 AutoLayout 来计算实际行高。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">tableView.estimatedRowHeight = <span class="number">85.0</span></span><br><span class="line">tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span></span><br></pre></td></tr></table></figure>

<p>接下来，将 tableviewcell 的内容放置在 cell 的内容视图中。为了定义 cell 的高度，你需要保证约束链和视图链从内容视图的顶边到底边有不间断的延伸，最终撑起内容区高度。如果你的 view 有固有内容高度，系统会使用这些高度，如果没有，你就必须显式得为视图或视图内的内容添加适合的高度约束。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Chain_of_Views_and_Constraints_2x.png" width=500>

<p>此外，你要尝试使预估高度尽量精确。系统会根据这些预估高度计算一些值，例如滚动条高度。越精确的预估高度越能实现无缝的用户体验。</p>
<blockquote>
<p>注意：</p>
<p>使用 tableviewcell 时，不能更改预定义内容的布局（例如，textLabel，detailTextLabel 和 imageView 的属性）。</p>
<p>下面这些约束都是支持的：</p>
<ul>
<li>定位子视图相对于内容视图的约束</li>
<li>定位子视图相对于 cell 的边缘的约束</li>
<li>定位子视图相对于预定义内容视图的约束</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·AutoLayout 高级指南·更改约束</title>
    <url>/2018/01/22/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%C2%B7%E6%9B%B4%E6%94%B9%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="016-Autolayout指南·AutoLayout-高级指南"><a href="#016-Autolayout指南·AutoLayout-高级指南" class="headerlink" title="016-Autolayout指南·AutoLayout 高级指南"></a>016-Autolayout指南·AutoLayout 高级指南</h1><h2 id="更改约束"><a href="#更改约束" class="headerlink" title="更改约束"></a>更改约束</h2><p>约束改变是指任何改变约束的基础数学表达式的元素（见下图）。你可以查阅 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1" target="_blank" rel="noopener">详解约束</a> 了解约束表达式更多内容。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/view_formula_2x.png" width=500>

<p>下面这些行为都会造成至少一条约束的改变：</p>
<ul>
<li>激活或停用约束</li>
<li>改变约束中的常量因子</li>
<li>改变约束优先级</li>
<li>将一个 view 从视图层级中移除</li>
</ul>
<p>其他例如设置一个 control 的属性、修改视图层级等操作也能改变约束。当一个改变发生时，系统会稍后对布局进行更新（查阅 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW3" target="_blank" rel="noopener">延时布局更新</a>）</p>
<p>一般来说，你可以在任何时候进行这些改变。理想情况下，大多数约束条件都应在 Interface Builder 中设置，或者在控制器的初始设置期间由视图控制器用编程方式创建（例如在 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload" target="_blank" rel="noopener">viewDidLoad</a> 方法中）。</p>
<p>如果你需要在运行时动态改变约束，通常最好在应用程序状态发生改变时进行。例如，如果你想改变一个约束来响应一个按钮的点击，那么直接在按钮的点击事件中进行改变。</p>
<p>有时候出于性能原因，你可能需要进行一组约束的批处理。查阅 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="noopener">批处理约束改变操作</a> 了解更多信息。</p>
<h3 id="延时布局更新"><a href="#延时布局更新" class="headerlink" title="延时布局更新"></a>延时布局更新</h3><p>AutoLayout 不会立即更新受影响的 view 的 frame，而是安排不久的将来进行布局。此延迟操作会更新布局的约束，然后计算视图层次结构中所有视图的帧。</p>
<p>你可以通过调用 <a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="noopener">setNeedsLayout</a> 或 <a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="noopener">setNeedsUpdateConstraints</a> 安排你自己的延时布局更新操作。</p>
<p>延时布局操作过程实际上涉及到两个有关视图层级的过程：</p>
<ul>
<li>根据需要更新约束</li>
<li>根据需要重新定位 view 的 frame</li>
</ul>
<h4 id="约束更新操作"><a href="#约束更新操作" class="headerlink" title="约束更新操作"></a>约束更新操作</h4><p>系统会遍历视图层级，对所有 ViewController 调用 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621379-updateviewconstraints" target="_blank" rel="noopener">updateViewConstraints</a> 方法，对所有 view 调用 <a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="noopener">updateConstraints</a> 方法。你可以覆写这些方法来优化你的约束更新操作。（查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2" target="_blank" rel="noopener">批处理约束更新操作</a>）。</p>
<h4 id="布局更新操作"><a href="#布局更新操作" class="headerlink" title="布局更新操作"></a>布局更新操作</h4><p>系统会遍历视图层级，对所有 ViewController 调用 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="noopener">viewWillLayoutSubviews</a> 方法，对所有 view 调用 <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="noopener">layoutSubviews</a> 方法。默认情况下，<a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="noopener">layoutSubviews</a> 方法会用由 Auto Layout 引擎所计算出来的矩形更新每个子视图的 frame。你可以覆写这些方法修改布局。（查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW4" target="_blank" rel="noopener">自定义布局</a>）。</p>
<h3 id="批处理约束更新操作"><a href="#批处理约束更新操作" class="headerlink" title="批处理约束更新操作"></a>批处理约束更新操作</h3><p>在影响布局的变化发生之后，立即更新约束一般来说更加清晰和容易。而将这些更改延迟到稍后的某个方法会使代码变得更复杂和更难理解。</p>
<p>然而有些时候出于性能表现的原因，你会想要进行一些约束更新的批处理操作。只有当更改约束的操作太慢，或者一个视图正在进行一些冗余的更改时才能进行这种操作。</p>
<p>为了对一个更新进行批处理，你可以对保持此约束的 view 调用 <a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="noopener">setNeedsUpdateConstraints</a> 方法来代替直接更新约束的操作。然后覆写 <a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="noopener">updateConstraints</a> 方法来修改受影响的约束。</p>
<blockquote>
<p>注意：</p>
<p>你的 <a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="noopener">updateConstraints</a> 方法的实现应该尽可能高效。不要停用所有的约束，然后重新激活所需的约束。你应该有方法跟踪你的约束，并在每一次更新过程中激活它们。只改变需要改变的元素。在每一次更新过程中，你必须保证应用的当前状态有合适的约束。</p>
</blockquote>
<p>始终记得在你的 <a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="noopener">updateConstraints</a> 方法实现的最后一步调用父类的方法实现。</p>
<p>不要在你的 <a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints" target="_blank" rel="noopener">updateConstraints</a> 方法中调用 <a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="noopener">setNeedsUpdateConstraints</a>  方法，这会导致循环调用问题。</p>
<h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><p>覆写 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="noopener">viewWillLayoutSubviews</a> 或 <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="noopener">layoutSubviews</a> 方法可以修改布局引擎返回的布局结果。</p>
<blockquote>
<p>重要：</p>
<p>尽可能使用约束来定义你的所有布局，这样布局结果更加健壮，也更加便于调试。你应当只在需要创建一个无法用约束表达的布局时才覆写 <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews" target="_blank" rel="noopener">viewWillLayoutSubviews</a> 或 <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews" target="_blank" rel="noopener">layoutSubviews</a> 方法。</p>
</blockquote>
<p>当你覆写了这些方法之后，布局会处于一种不稳定的状态。一些 view 可能已经被布置，而另一些可能没有。你需要关注你是如何修改视图层级的，否则就可能造成循环调用。下面这些规则可能能帮助你避免循环调用：</p>
<ul>
<li>你必须在你的方法实现里调用父类的同名方法</li>
<li>你可以安全地使你的子视图树中的视图布局无效，但是，这一步必须在调用父类的实现之前进行</li>
<li>不要禁用你的子视图之外的其他 view 的布局，否则会引起循环调用</li>
<li>不要调用 <a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints" target="_blank" rel="noopener">setNeedsUpdateConstraints</a>，否则会引起循环调用</li>
<li>不要调用 <a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout" target="_blank" rel="noopener">setNeedsLayout</a>，否则会引起循环调用</li>
<li>要小心地改变约束，否则可能会意外地使你的子视图树外的某些 view 的布局失效</li>
</ul>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·AutoLayout 高级指南·基于size-class的布局</title>
    <url>/2018/01/21/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%C2%B7%E5%9F%BA%E4%BA%8Esize-class%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="013-Autolayout指南·AutoLayout-高级指南"><a href="#013-Autolayout指南·AutoLayout-高级指南" class="headerlink" title="013-Autolayout指南·AutoLayout 高级指南"></a>013-Autolayout指南·AutoLayout 高级指南</h1><h2 id="基于-size-class-的布局"><a href="#基于-size-class-的布局" class="headerlink" title="基于 size-class 的布局"></a>基于 size-class 的布局</h2><p>IB 的 storyboard 默认会使用 size-class。size-class 是为 UI 元素，如 scene 或 view，所声明的形状。它们提供了对于元素尺寸的一个粗糙的表述。IB 能使你基于当前的 size-class 自定义许多你的布局的特性。然后当 size-class 变化时布局就会自动适应。特别的，你可以在每一个 size-class 的基础上设置以下特性：</p>
<ul>
<li>注册或取消注册一个 view 或者控制器</li>
<li>注册或取消注册一个约束</li>
<li>设置选中属性的值（例如字体或布局边界设置）</li>
</ul>
<p>当系统加载 scene 时会实例化所有视图，控件和约束，并将这些项目分配给视图控制器（如果有的话）中相应的 outlet。你可以通过它们的 outlet 访问其中任何一个元素，无论当前 scene 的 size-class 是什么。但是系统只会在元素被注册到当前 size-class 时爱会添加这些元素到视图层级上。</p>
<p>当 view 的 size-class 改变时（例如，当你旋转一个 iphone 或者在 iPad 的全屏和 splitView 间切换 app 时），系统会自动从视图层级中添加或移除元素。系统也会为 view 的布局变化添加动画。</p>
<blockquote>
<p>注意：</p>
<p>系统会保持对一个未注册元素的引用，所以这些元素不会被销毁，即使它们被移除出视图层级。</p>
</blockquote>
<h2 id="final-size-class-与-base-size-class"><a href="#final-size-class-与-base-size-class" class="headerlink" title="final-size-class 与 base-size-class"></a>final-size-class 与 base-size-class</h2><p>IB 能识别出九种不同的 size-class。</p>
<p>其中四种属于 final-size-class：Compact-Compact, Compact-Regular, Regular-Compact, and Regular-Regular。final-size-class 代表设备上显示的实际 size-class。</p>
<p>剩下五种属于 base-size-class：Compact-Any, Regular-Any, Any-Compact, Any-Regular, and Any-Any。它们是一些代表两种或两种以上 final-size-class 的抽象 size-class。例如，注册在 Compact-Any 下的元素会同时展示在 Compact-Compact 和 Compact-Regular 两种 size-class 下。</p>
<p>任何设置在更具体的 size-class 中的东西总是会覆盖更一般的 size-class。此外，你必须为一共九个 size-class（甚至是 base-size-class）都提供一个无歧义、可满足的布局。 因此，从最一般性的 size-class 到最具体性的 size-class 通常是最容易的。你可以选择你的的应用程序的默认布局，并在 Any-Any size-class 中设计它，然后根据需要修改其他的 base-size-class 或 final-size-class。</p>
<h3 id="使用-size-class-工具"><a href="#使用-size-class-工具" class="headerlink" title="使用 size-class 工具"></a>使用 size-class 工具</h3><p>利用 IB 的 size-class 工具选中你正在编辑的 size-class，这个工具被展示在编辑窗口的底部中央位置。IB 默认会选择 Any-Any 作为启动时的 size-class。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Size_Class_Tool_2x.png" width=500>

<p>可以点击 size-class 工具来切换到一个新的 size-class。IB 会展示一个弹窗，里面有一个包含所有 size-class 的九宫格。在九宫格上移动鼠标来改变 size-class。九宫格的顶部会展示选中的 size-class 的名称，底部展示这个 size-class 的描述信息（包括它会影响到的设备和旋转方向）。九宫格还会在当前 size-class 所影响到的 size-class 的格子上展示一个绿色原点。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Selecting_A__Size_Class_2x.png" width=500>

<p>只有被注册到当前 size-class 的 view 和约束才能被添加到画布上。而当删除元素的时候，元素如何删除会影响到删除时的布局表现。</p>
<ul>
<li>从画布或 document outline 中删除元素将会完全从项目中删除此元素</li>
<li>通过命令行从画布或 document outline 中删除元素只会从当前 size-class 取消注册此元素</li>
<li>如果 scene 有多个 size-class，则从画布或 document outline 以外的任何地方删除元素（例如，从尺寸检查器中选择和删除约束）将会仅从当前的 size-class 中取消注册此元素</li>
<li>如果你只编辑了 Any-Any 这个 size-class，那么删除一个元素将会完全从项目中移除此元素</li>
</ul>
<p>如果你编辑了任何非 Any-Any 的 size-class，IB 就会将编辑窗口底部的 toolbar 变成蓝色高亮显示。这样能使你很容易发现你在编辑一个更加具体确定的 size-class。</p>
<h3 id="使用检查器"><a href="#使用检查器" class="headerlink" title="使用检查器"></a>使用检查器</h3><p>你也可以修改检查器中的 size-class-specific 设置，任何支持 size-class-specific 的设置都会在检查器中展示，旁边还会有一个小加号图标。</p>
<p>默认的，检查器会设置 Any-Any 的值。为了给更加具体的 size-class 设置一个不同的值，你可以点击加号图标来添加一个新的 size-class，然后选择你想添加的 size-class 的宽度和高度。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Adding_Size_Class_2x.png" width=500>

<p>检查器会按行显示每个 size-class： Any-Any 设置在最上面一行，下面列出了更具体的 size-class。你可以独立编辑每行的值，同时不影响到其他行的设置。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Setting_Size-Class_Specific_Values_2x.png" width=500>

<p>点击每一行行首的 x 图标可以移除一个自定义的 size-class。</p>
<p>查看 Size-Classes-Design-Help 获取更多帮助信息。</p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·AutoLayout 高级指南·编程创建约束</title>
    <url>/2018/01/15/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20%E9%AB%98%E7%BA%A7%E6%8C%87%E5%8D%97%C2%B7%E7%BC%96%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="012-Autolayout指南·AutoLayout-高级指南"><a href="#012-Autolayout指南·AutoLayout-高级指南" class="headerlink" title="012-Autolayout指南·AutoLayout 高级指南"></a>012-Autolayout指南·AutoLayout 高级指南</h1><h2 id="编程创建约束"><a href="#编程创建约束" class="headerlink" title="编程创建约束"></a>编程创建约束</h2><p>尽可能通过 IB 来创建你的约束。IB 能提供很多工具来可视化、编辑、管理和调试你的约束。IB 也可以通过分析你的约束，在设计期就发现很多常见的错误，使你能够在 app 运行之前找到并修复你的问题。</p>
<p>IB 能够管理不断增长的任务。你可以在 IB 中直接创建出几乎任何类型的约束（查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1" target="_blank" rel="noopener">在 IB 中使用 约束</a>）。你也可以指定基于特定 size-class 的约束（查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1" target="_blank" rel="noopener">调试 AutoLayout</a>），你甚至可以利用像 stackview 这样的新工具在运行时动态添加或移除 view（查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11-SW19" target="_blank" rel="noopener">Dynamic Stack View</a>）。然后，一些动态改变可能只能用代码来管理。</p>
<p>你有三种选择来通过编程创建约束：你可以使用 layout anchor、 NSLayoutConstraint 类，以及 VFL 语言。</p>
<h3 id="Layout-Anchor"><a href="#Layout-Anchor" class="headerlink" title="Layout Anchor"></a>Layout Anchor</h3><p>NSLayoutAnchor 类为创建约束提供了一个流畅的界面。要使用 API，你只需要访问你需要约束的元素的 anchor 属性。例如，ViewController 的顶部和底部 layoutGuide 有 topAnchor、bottomAnchor 和 heightAnchor 属性。另一方面 view 则将锚点暴露在其边缘，中心，大小和基线上。</p>
<blockquote>
<p>注意：</p>
<p>在 iOS 中，view 同样有 layoutMarginsGuide 和 readableContentGuide 属性，这些属性暴露了一个 UILayoutGuide 对象，这个对象分别表示了 view 的边界和可读的内容边界。这些 guide 反过来暴露了 Anchor 的边缘，中心和大小。</p>
<p>在用编程创建边界和可读内容边界约束时可以使用这些 guide。</p>
</blockquote>
<p>LayoutAnchor 能够使你用一种便于阅读和紧凑的格式来创建约束。正如下面展示的，它们暴露了一系列方法来创建不同类型的约束</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the superview's layout</span></span><br><span class="line">let margins = view.layoutMarginsGuide</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Pin the leading edge of myView to the margin's leading edge</span></span><br><span class="line">myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Pin the trailing edge of myView to the margin's trailing edge</span></span><br><span class="line">myView.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Give myView a 1:2 aspect ratio</span></span><br><span class="line">myView.heightAnchor.constraint(equalTo: myView.widthAnchor, multiplier: <span class="number">2.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如同 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1" target="_blank" rel="noopener">详解约束</a> 所描述的，一个约束就是一个线性等式</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/view_formula_2x.png" width=500>

<p>LayoutAnchor 有许多不同的方法来创建约束。每一个方法都包含等式中一些影响到布局的元素的参数。所以在下面这行代码里</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">myView.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这些符号对应于等式里的这些部分</p>
<table>
<thead>
<tr>
<th>等式</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>Item 1</td>
<td>myView</td>
</tr>
<tr>
<td>Attribute 1</td>
<td>LeadingAnch</td>
</tr>
<tr>
<td>Relationship</td>
<td>constraintEqualToAnchor</td>
</tr>
<tr>
<td>Multiplier</td>
<td>None (defaults to 1.0)</td>
</tr>
<tr>
<td>Item 2</td>
<td>margins</td>
</tr>
<tr>
<td>Attribute 2</td>
<td>leadingAnchor</td>
</tr>
<tr>
<td>Constant</td>
<td>None (defaults to 0.0)</td>
</tr>
</tbody></table>
<p>LayoutAnchor 也提供了额外的类型安全属性。NSLayoutAnchor 类有很多子类，这些子类为创建约束加入了类型信息和子类方法。这帮助我们防止发生非法约束的创建。例如，你只能将水平 Anchor （LeadingAnchor 或 TrailingAnchor）与其他水平 Anchor 相互约束。类似的，你只能为尺寸约束提供乘数因子。</p>
<blockquote>
<p>注意：</p>
<p>这些规则并不是 NSLayoutConstraint API 所强制的，如果你创建了一个非法的约束，那么约束就会在运行时抛出异常。因此 LayoutAnchor 能够将运行时错误转换为编译期错误。</p>
</blockquote>
<p>了解更多信息请查看 <a href="https://developer.apple.com/documentation/appkit/nslayoutanchor" target="_blank" rel="noopener">NSLayoutAnchor 类参考</a>。</p>
<h3 id="NSLayoutConstraint-类"><a href="#NSLayoutConstraint-类" class="headerlink" title="NSLayoutConstraint 类"></a>NSLayoutConstraint 类</h3><p>你也可以直接用 NSLayoutConstraint 类的 constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant: 方法来创建约束。这个方法显式地将约束关系式转换成了代码。每一个参数都对应于等式的一个部分（查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW2" target="_blank" rel="noopener">约束关系式</a>）。</p>
<p>不像 LayoutAnchor API 的方法，你必须为每一个参数确定一个值，即使这个参数不会影响到布局。最终的结果就是一大堆样板代码，而且一般很难阅读。例如，下面这段代码就和上一节的那句代码有一样的效果。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLayoutConstraint</span>(item: myView, attribute: .leading, relatedBy: .equal, toItem: view, attribute: .leadingMargin, multiplier: <span class="number">1.0</span>, constant: <span class="number">0.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSLayoutConstraint</span>(item: myView, attribute: .trailing, relatedBy: .equal, toItem: view, attribute: .trailingMargin, multiplier: <span class="number">1.0</span>, constant: <span class="number">0.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSLayoutConstraint</span>(item: myView, attribute: .height, relatedBy: .equal, toItem: myView, attribute:.width, multiplier: <span class="number">2.0</span>, constant:<span class="number">0.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>在 iOS 中，NSLayoutAttribute 包含了表示一个 view 的边距的枚举值。这意味着你不需要通过 layoutMarginsGuide 属性就可以为边距创建约束。但是你仍然需要使用 readableContentGuide 来创建可阅读内容 guide 的约束。</p>
</blockquote>
<p>不像 LayoutAnchor API，NSLayoutConstraint 方法不能高亮一个特定约束的重要特性。因此，在浏览代码时很容易就会遗留一些重要的细节。此外，编译器不会对约束执行任何静态检查。你可以自由地创建非法约束，这些约束会在运行时抛出异常。所以除非你需要支持 iOS 8 或者 OS X v10.10 之前的版本，否则你应当考虑将代码迁移到更新的 LayoutAnchor API 上。</p>
<p>了解更多信息请查阅 <a href="https://developer.apple.com/documentation/appkit/nslayoutconstraint" target="_blank" rel="noopener">NSLayoutConstraint 类参考</a></p>
<h3 id="视觉格式语言-VFL"><a href="#视觉格式语言-VFL" class="headerlink" title="视觉格式语言 VFL"></a>视觉格式语言 VFL</h3><p>VFL 使你可以使用类似 ASCII 中的字符串来定义约束。这提供了一种对于约束的可视化描述性表达。VFL 有以下优点和不足：</p>
<ul>
<li>AutoLayout 向控制台打印约束时用的是 VFL，所以使用 VFL 创建的代码会和调试信息非常类似</li>
<li>VFL 能允许你利用一种非常紧凑的格式，一次创建非常多的约束</li>
<li>VFL 能保证你创建的一定是合法约束</li>
<li>VFL 强调完整性的良好可视化,因此，使用 VFL 不能创建一些约束（例如，宽高比）</li>
<li>编译器没有任何办法验证这些字符串。你只能在运行时测试和发现你的错误</li>
</ul>
<p>下面就是一个用 VFL 创建的约束，它的效果与上面两节实现的效果一样</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">let views = [<span class="string">"myView"</span> : myView]</span><br><span class="line">let formatString = <span class="string">"|-[myView]-|"</span></span><br><span class="line"> </span><br><span class="line">let constraints = <span class="built_in">NSLayoutConstraint</span>.constraints(withVisualFormat: formatString, options: .alignAllTop, metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSLayoutConstraint</span>.activate(constraints)</span><br></pre></td></tr></table></figure>

<p>示例代码创建和激活了头部和尾部的约束。VFL 语言在使用默认空白时总是为父视图的边距创建 0pt 的约束，所以这些约束与前面两节的示例效果相同。但是 VFL 不能创建长宽比的约束。</p>
<p>如果你在一行里用很多元素创建了一个更加复杂的 view，VFL 会指定竖直和水平方向上的空白间距。正如示例所写的那样，”Align All Top” 选项不会影响布局，因为该示例只有一个视图（不包括父视图）。</p>
<p>为了利用 VFL 创建约束，你应当</p>
<ul>
<li>创建 view 字典。这个字典必须以字符串作为键，以视图对象（或其他可以在“自动布局”中约束的元素，例如 LayoutGuide）作为值，使用键来识别字符串对应的视图。</li>
</ul>
<blockquote>
<p>注意：</p>
<p>当使用 objective-c 时，可以使用 NSDictionaryOfVariableBindings 宏命令来创建 view 字典。在 Swift 里则需要你手动创建字典。</p>
</blockquote>
<ul>
<li>（可选）创建度量字典。这个字典必须以字符串作为键，NSNumber 对象作为值。使用键来表示字符串对应的约束值</li>
<li>通过放置一行或一列元素来创建格式化字符串</li>
<li>调用  NSLayoutConstraint 类的 constraintsWithVisualFormat:options:metrics:views: 方法，这个方法能返回一个数组，其中包含所有约束</li>
<li>通过调用 NSLayoutConstraint 类的 activateConstraints: 方法来激活约束</li>
</ul>
<p>了解更多信息请查阅附录的 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="noopener">视觉格式语言</a></p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·调试 AutoLayout·调试技巧</title>
    <url>/2018/01/15/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7%E8%B0%83%E8%AF%95%20AutoLayout%C2%B7%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="011-Autolayout指南·调试-AutoLayout"><a href="#011-Autolayout指南·调试-AutoLayout" class="headerlink" title="011-Autolayout指南·调试 AutoLayout"></a>011-Autolayout指南·调试 AutoLayout</h1><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>接下来的话题是关于如何收集和组织你的布局的信息的技术，以及一些你可能会遇到的奇葩的布局表现。你可能并不需要在每一个布局上都使用这些技术，但是它们能帮助你即使遇到最困难的问题也能顺利完成布局工作。</p>
<h3 id="理解日志"><a href="#理解日志" class="headerlink" title="理解日志"></a>理解日志</h3><p>有关视图的信息都可以被打印到控制台，无论是由于无法满足的布局，还是因为你调用 constraintsAffectingLayoutForAxis: 或者 constraintsAffectingLayoutForOrientation: 等调试函数显式地打印这些约束。</p>
<p>总之，你可以在这些日志里找到很多有用的信息，这里有一份有关无法满足的约束的示例输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-26</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">54.790</span> Auto Layout Cookbook[<span class="number">10040</span>:<span class="number">1906606</span>] Unable <span class="built_in">to</span> simultaneously satisfy constraints.</span><br><span class="line">    Probably <span class="keyword">at</span> least <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> constraints <span class="keyword">in</span> <span class="keyword">the</span> following list is <span class="literal">one</span> you don<span class="string">'t want. Try this: (1) look at each constraint and try to figure out which you don'</span>t expect; (<span class="number">2</span>) find <span class="keyword">the</span> code that added <span class="keyword">the</span> unwanted constraint <span class="keyword">or</span> constraints <span class="keyword">and</span> fix <span class="keyword">it</span>. (Note: If you<span class="string">'re seeing NSAutoresizingMaskLayoutConstraints that you don'</span>t understand, refer <span class="built_in">to</span> <span class="keyword">the</span> documentation <span class="keyword">for</span> <span class="keyword">the</span> UIView property translatesAutoresizingMaskIntoConstraints) </span><br><span class="line">(</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a87b000 H:[UILabel:0x7a8724b0'Name'(&gt;=400)]&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a895e30 UILabel:0x7a8724b0'Name'.leading == UIView:0x7a887ee0.leadingMargin&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a886d20 H:[UILabel:0x7a8724b0'Name']-(NSSpace(8))-[UITextField:0x7a88cff0]&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7a87b2e0 UITextField:0x7a88cff0.trailing == UIView:0x7a887ee0.trailingMargin&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7ac7c430 'UIView-Encapsulated-Layout-Width' H:[UIView:0x7a887ee0(320)]&gt;"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">Will attempt <span class="built_in">to</span> recover <span class="keyword">by</span> breaking constraint</span><br><span class="line">&lt;NSLayoutConstraint:<span class="number">0x7a87b000</span> H:[UILabel:<span class="number">0x7a8724b0</span><span class="string">'Name'</span>(&gt;=<span class="number">400</span>)]&gt;</span><br><span class="line"> </span><br><span class="line">Make <span class="keyword">a</span> symbolic <span class="built_in">breakpoint</span> <span class="keyword">at</span> UIViewAlertForUnsatisfiableConstraints <span class="built_in">to</span> <span class="keyword">catch</span> this <span class="keyword">in</span> <span class="keyword">the</span> debugger.</span><br><span class="line">The methods <span class="keyword">in</span> <span class="keyword">the</span> UIConstraintBasedLayoutDebugging category <span class="keyword">on</span> <span class="title">UIView</span> <span class="title">listed</span> <span class="title">in</span> &lt;<span class="title">UIKit</span>/<span class="title">UIView</span>.<span class="title">h</span>&gt; <span class="title">may</span> <span class="title">also</span> <span class="title">be</span> <span class="title">helpful</span>.</span><br></pre></td></tr></table></figure>

<p>这条错误信息展示了五条冲突约束，并不是所有约束都能同时成立，你需要移除其中一个，或者是将其转为一个可选的约束。</p>
<p>幸运的是，视图层级相对比较简单，你有一个包含一个 label 和 一个 textfield 的父视图，冲突约束设置了下面这一系列的关系：</p>
<ul>
<li>label 的宽度大于等于 400pt</li>
<li>label 的头部边线等于父视图的头部</li>
<li>Label 与 textfield 间距为 8pt</li>
<li>textfield 的尾部边线等于父视图的尾部</li>
<li>父视图的宽度为 320 pt</li>
</ul>
<p>系统会尝试打破 label 的宽度以修复冲突</p>
<blockquote>
<p>注意：</p>
<p>约束采用了视觉格式语言 VFL （Visual Format Language）打印到控制台，即使你从未使用过 VFL 来创建约束，你也一定能够读懂它，从而有效调试你的 AutoLayout 问题。关于 VFL 更多信息请查阅 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="noopener">Visual Format Language</a></p>
</blockquote>
<p>在这些约束中，最后一个约束是由系统创建的。你不能修改这条约束，另外，它还和第一条约束产生了一个明显的冲突。如果你的父视图宽度只有 320pt，那么你永远不能有一个 400pt 宽度的 label。幸运的是，你并不需要去除第一条约束，如果您将其优先级降至 999，那么系统仍然会尝试提供你所选择的宽度 - 它会尽可能接近，同时仍然满足其他约束。</p>
<p>基于 view 的 view’s autoresizing mask 创建的约束（例如当 translatesAutoresizingMaskIntoConstraints 为 YES 时就会创建约束）会有额外的信息。在约束的地址后面，日志分别展示了一个 “h=” 和 一个 “v=”，后面各跟着三个字符。这三个字符如果是”-“ 连字符则表示一个固定的值，是 “&amp;” 符号则表示一个变化的值。对于水平 mask 值（h=），三个字符分别代表左边距、宽度和右边距，对于垂直 mask 值（v=），三个字符分别表示上边距、高度和下边距。</p>
<p>例如，考虑下面这条日志信息：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;NSAutoresizingMaskLayoutConstraint:0x7ff28252e480 <span class="attribute">h</span>=--&amp; <span class="attribute">v</span>=--&amp; H:[UIView:0x7ff282617cc0(50)]&gt;<span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>这条信息包含了以下几部分：</p>
<ul>
<li>NSAutoresizingMaskLayoutConstraint:0x7ff28252e480: 这条约束的类和地址，这里的类告诉我们这是一条基于 view 的 autoresizing mask 创建的约束。</li>
<li>h=–&amp; v=—&amp;: view 的 autoresizing mask 值，在这里它是默认值。水平方向上有一个固定的左边距和宽度，一个变化的右边距。竖直方向上有一个固定的上边距和高度，一个变化的下边距。也就是说，这个 view 的左上角和尺寸不会随着父视图的尺寸变化而变化。</li>
<li>H:[UIView:0x7ff282617cc0(50)]: 这条约束的 VFL 表达。在这个例子中，它定义了一个有 50pt 宽度 的 view，表达中同样包含了这条约束影响到的视图的类和地址。</li>
</ul>
<h3 id="向日志添加标识"><a href="#向日志添加标识" class="headerlink" title="向日志添加标识"></a>向日志添加标识</h3><p>前面的示例还比较容易理解，但是随着约束列表变长，很快就会难以追踪和理解日志的含义。你可以向每一个 view 和约束提供一个可理解的标识来使日志更易于阅读。</p>
<p>如果 view 有一个明显的文本组件，Xcode 会使用这个组件来作为标识。例如，Xcode 会使用一个 lable 的文案，一个 button 的标题，或者一个 textfield 的占位文案来标识这些 view。否则，就需要在标识检查器里设置 view 的 Xcode 标签。IB 会在整个接口中使用这些标识符，控制台日志中也会展示这些标识。</p>
<p>对于约束，可以通过编程或者使用属性检查器来设置它们的 identifier 属性。Autolayout 之后会使用这些标识在控制台中打印约束信息。</p>
<p>例如，这里有一个同样无法满足的约束错误，它有一个标识集合：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">2015</span><span class="number">-08</span><span class="number">-26</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">32.870</span> Auto Layout Cookbook[<span class="number">10208</span>:<span class="number">1918826</span>] Unable <span class="built_in">to</span> simultaneously satisfy constraints.</span><br><span class="line">    Probably <span class="keyword">at</span> least <span class="literal">one</span> <span class="keyword">of</span> <span class="keyword">the</span> constraints <span class="keyword">in</span> <span class="keyword">the</span> following list is <span class="literal">one</span> you don<span class="string">'t want. Try this: (1) look at each constraint and try to figure out which you don'</span>t expect; (<span class="number">2</span>) find <span class="keyword">the</span> code that added <span class="keyword">the</span> unwanted constraint <span class="keyword">or</span> constraints <span class="keyword">and</span> fix <span class="keyword">it</span>. (Note: If you<span class="string">'re seeing NSAutoresizingMaskLayoutConstraints that you don'</span>t understand, refer <span class="built_in">to</span> <span class="keyword">the</span> documentation <span class="keyword">for</span> <span class="keyword">the</span> UIView property translatesAutoresizingMaskIntoConstraints) </span><br><span class="line">(</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7b58bac0 'Label Leading' UILabel:0x7b58b040'Name'.leading == UIView:0x7b590790.leadingMargin&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7b56d020 'Label Width' H:[UILabel:0x7b58b040'Name'(&gt;=400)]&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7b58baf0 'Space Between Controls' H:[UILabel:0x7b58b040'Name']-(NSSpace(8))-[UITextField:0x7b589490]&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7b51cb10 'Text Field Trailing' UITextField:0x7b589490.trailing == UIView:0x7b590790.trailingMargin&gt;"</span>,</span><br><span class="line">    <span class="string">"&lt;NSLayoutConstraint:0x7b0758c0 'UIView-Encapsulated-Layout-Width' H:[UIView:0x7b590790(320)]&gt;"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">Will attempt <span class="built_in">to</span> recover <span class="keyword">by</span> breaking constraint</span><br><span class="line">&lt;NSLayoutConstraint:<span class="number">0x7b56d020</span> <span class="string">'Label Width'</span> H:[UILabel:<span class="number">0x7b58b040</span><span class="string">'Name'</span>(&gt;=<span class="number">400</span>)]&gt;</span><br><span class="line"> </span><br><span class="line">Make <span class="keyword">a</span> symbolic <span class="built_in">breakpoint</span> <span class="keyword">at</span> UIViewAlertForUnsatisfiableConstraints <span class="built_in">to</span> <span class="keyword">catch</span> this <span class="keyword">in</span> <span class="keyword">the</span> debugger.</span><br><span class="line">The methods <span class="keyword">in</span> <span class="keyword">the</span> UIConstraintBasedLayoutDebugging category <span class="keyword">on</span> <span class="title">UIView</span> <span class="title">listed</span> <span class="title">in</span> &lt;<span class="title">UIKit</span>/<span class="title">UIView</span>.<span class="title">h</span>&gt; <span class="title">may</span> <span class="title">also</span> <span class="title">be</span> <span class="title">helpful</span>.</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，标识能允许你快速便捷地在日志中识别出你的约束。</p>
<h3 id="可视化-view-和-约束"><a href="#可视化-view-和-约束" class="headerlink" title="可视化 view 和 约束"></a>可视化 view 和 约束</h3><p>Xcode 提供了工具来帮助你可视化你的视图层级中的 view 和约束。</p>
<p>在模拟器中进行如下操作即可看到 view：</p>
<ul>
<li>在模拟器中运行 app</li>
<li>切换回 Xcode</li>
<li>选择 Debug &gt; View Debugging &gt; Show Alignment Rectangles。这个设置能显示出你的 view 的轮廓</li>
</ul>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Show_Alignment_Rectangles_2x.png" width=500>

<p>alignment rectangles 对齐是 AutoLayout 所使用的 view 的边线，开启这个选项能够使你快速定位尺寸不对的 alignment rectangles。</p>
<p>如果你需要更多信息，你可以点击 Xcode 调试条上的 Debug View Hierarchy 按钮。Xcode 会展示一个 View 互动调试器，提供给你一些工具来探索视图层级并与之进行交互。当你在调试 AutoLayout 问题时，”Show clipped content” 和 “Show constraints” 通常会非常有用。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Debug_View_Hierarchy_2x.png" width=500>

<p>选中 “Show clipped content” 选项会展示一些已经放置到屏幕外面的 view。选中 “Show constraints” 选项会展示所有影响到当前选中 view 的约束。当布局变得很奇怪时，两个选项提供了一个便捷而明智的检查方式。</p>
<p>了解更多信息请查阅 <a href="http://help.apple.com/xcode" target="_blank" rel="noopener">调试区帮助</a>。</p>
<h3 id="理解边界情况"><a href="#理解边界情况" class="headerlink" title="理解边界情况"></a>理解边界情况</h3><p>这里有一些会引起 AutoLayout 布局发生异常的边界情况：</p>
<ul>
<li>AutoLayout 是基于 alignment rectangles 来定位 view 的，而不是 view 的 frame，在大多数时候这两者是完全一样的。但是一些 view 可能会设置一个自己的 alignment rectangles 从而在布局计算中去除掉自己的部分 view（例如边界线）。</li>
</ul>
<p>了解更多信息，可以查看 <a href="https://developer.apple.com/documentation/uikit/uiview" target="_blank" rel="noopener">UIView类参考</a> 的 “与自动布局对齐视图” 一节。</p>
<ul>
<li>在 iOS 上，你可以使用一个 view 的 transform 属性来重新设置 view 的尺寸、对 viw 旋转、移动等，但是这些变换无法影响 AutoLayout 的计算。AutoLayout 会基于 view 未变换时的 frame 来计算它的 alignment rectangles。</li>
<li>一个 view 展示超出其边界的内容。大多数时候 view 会正常展示并限制内容在它们的边界内。但是，出于性能方面的考虑，这不是由图形引擎强制执行的。这意味着 view (尤其是有自定义绘图的 view) 可能会被按照一个与其 frame 所不同的尺寸来绘制。</li>
</ul>
<p>你可以通过设置 view 的 clipsToBounds 属性为 YES 或者检查 view 的 frame 尺寸来识别出这些 bug。</p>
<ul>
<li>只有当 view 都被按照其 intrinsic content height 来展示时 NSLayoutAttributeBaseline, NSLayoutAttributeFirstBaseline, and NSLayoutAttributeLastBaseline 属性才能正确对齐文案。如果其中一个 view 在竖直方向上被压缩或延展了，那么它的文案就可能被展示在错误的位置。</li>
<li>约束优先级在视图层级中充当了全局属性。你常常可以通过将 view 分组到一个 StackView 、一个 layoutguide、或者一个 dummy view 中来简化布局。但是这种方式并不能封装所包含 view 的优先级。AutoLayout 仍会继续比较组内和组外的优先级（甚至是其他组内的优先级）（疑惑？）</li>
<li>长宽比约束会将水平与竖直约束联系起来。一般来说竖直和水平约束都是分开计算的。但是如果你约束了一个 view 的高度相对于其宽度而变化，那么你就创建了竖直与水平约束之间的联系。它们互相之间可以影响甚至产生冲突。这种联系会极大增加布局复杂性，也会在你的布局的一些没有关联的部分之间引起无法预期的冲突。</li>
</ul>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·调试 AutoLayout·逻辑错误</title>
    <url>/2018/01/14/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7%E8%B0%83%E8%AF%95%20AutoLayout%C2%B7%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="010-Autolayout指南·调试-AutoLayout"><a href="#010-Autolayout指南·调试-AutoLayout" class="headerlink" title="010-Autolayout指南·调试 AutoLayout"></a>010-Autolayout指南·调试 AutoLayout</h1><h2 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h2><p>逻辑错误都是一些简单的 bug。有时候你会有一些错误的假设，可能是一个有关 Autolayout 如何计算 view 的 frame 的假设，可能是一个有关你创建的一系列约束，或者设置的一些视图属性的假设，也可能是一个有关约束如何互动从而创造出复杂布局表现的假设，总之都是一些并不符合你所预想的模型的地方。</p>
<p>逻辑错误也是最难被发现的，当你已经排除了其他所有可能性，那么无论多么不可置信，剩下的问题就只能是逻辑错误的问题了。然而即使你已经确信你的布局有 bug，你也仍然必须找到错误假设到底存在于何处。</p>
<p>没有工具或是说明步骤能够帮助你，修复逻辑错误通常需要实验和迭代测试，既要识别出问题，又要确定解决如何解决它。不过这里仍然有一些建议也许能够帮助到你：</p>
<ul>
<li>检查当前约束，确保没有遗漏约束或者突然添加了不想要的约束，确保所有的约束都被绑定在正确的 view 和正确的属性上</li>
<li>检查 view 的 frame，确保未发生意料之外的压缩或延展，这一步对于有不可见背景的 view 尤为重要，比如 label 或者 button。但是当这些元素被意外重设尺寸时可能并没有那样明显。被意外调整大小的一个症状是所有的基线对齐视图都不再正确地排列了，因为只有当 view 按照其 intrinsic content 高度来设置时基线才能正常对齐。如果你在竖直方向上压缩或者延展视图，文案就会神秘地出现在错误的位置</li>
<li>如果一个控制器需要始终保持它的 intrinsic content size，那么就给它的 content-hugging 和 compression-resistance 一个很高的优先级</li>
<li>寻找所有你用来创建当前布局的假设，并用显式的约束确保所有假设都成立。记住，无法满足的约束导致的问题一般都容易找到和修复，所以可以一直添加额外的约束，一直到你遇到了冲突，然后去检查和修复冲突</li>
<li>尝试理解为什么给定的约束会产生你看到的结果，如果你理解了它，那么你就很容易找到方法修复它</li>
<li>测试一些替代约束，Autolayout 一般会为一个相同的问题提供给你一些不同的解决方案，尝试一个不同的方案有可能会解决问题，或者至少能使定位错误变得容易一些</li>
</ul>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·调试 AutoLayout·有歧义的布局</title>
    <url>/2018/01/13/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7%E8%B0%83%E8%AF%95%20AutoLayout%C2%B7%E6%9C%89%E6%AD%A7%E4%B9%89%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="009-Autolayout指南·调试-AutoLayout"><a href="#009-Autolayout指南·调试-AutoLayout" class="headerlink" title="009-Autolayout指南·调试 AutoLayout"></a>009-Autolayout指南·调试 AutoLayout</h1><h2 id="有歧义的布局"><a href="#有歧义的布局" class="headerlink" title="有歧义的布局"></a>有歧义的布局</h2><p>当系统针对约束计算出多于一个可行解的时候就会出现有歧义的布局错误，大致可以分为两大错误：</p>
<ul>
<li>布局需要额外的约束来唯一确定每一个 view 的位置</li>
</ul>
<p>当你确定了哪些 view 有歧义后，就添加额外的约束来唯一确定 view 的尺寸和位置</p>
<ul>
<li>布局的部分可选约束有相同的优先级，系统无法确定应当打破哪个约束</li>
</ul>
<p>这时你需要通过改变 view 的优先级，使约束的优先级不相等，从而让系统明确哪些约束可以被打破。系统会优先打破最低优先级的约束。</p>
<h3 id="检测有歧义的约束"><a href="#检测有歧义的约束" class="headerlink" title="检测有歧义的约束"></a>检测有歧义的约束</h3><p>就像无法满足的约束一样，IB 通常可以在开发者设计阶段就检测出有歧义的布局，并提出修复意见。这些歧义点会作为警告出现在问题导航栏里，或者作为错误出现在文件大纲里，以及在画布上用红线标出。查阅 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ConflictingLayouts.html#//apple_ref/doc/uid/TP40010853-CH19-SW3" target="_blank" rel="noopener">识别无法满足的约束</a> 获得更多信息。</p>
<p>同无法满足的约束一样，IB 也并不能检测出所有可能的歧义点。许多错误只能通过测试来发现。</p>
<p>当运行时出现了一个有歧义的布局时，Autolayout 会选择一个可能的解来使用。这意味着布局可能正是你所期待的，也可能完全不是你期待的样子。另外这样的情况并不会在控制台输出警告信息，也没有办法为有歧义的布局设置断点。</p>
<p>因此，相比于无法满足的布局，有歧义的布局通常很难识别和检测出来。即使歧义点有相对明显、可视化的影响，也很难确定错误原因是歧义点还是由于你的布局逻辑。</p>
<p>但是幸运的是，你可以调用一些方法来帮助你识别有歧义的布局，但是所有这些方法都只能被用于调试。在你可以访问到视图层级的地方设置一个断点，然后在控制台调用下列方法的一个：</p>
<ul>
<li>hasAmbiguousLayout 支持 iOS 和 OS X。对一个错位 view 调用此方法，如果 view 的 frame 是有歧义的，则返回 YES，否则返回 NO</li>
<li>exerciseAmbiguityInLayout 支持 iOS 和 OS X。对于有歧义的布局调用此方法，系统将会在可能的可行解之间切换</li>
<li>constraintsAffectingLayoutForAxis 仅支持 iOS。对一个 view 调用此方法，将返回一系列</li>
<li>constraintsAffectingLayoutForOrientation</li>
<li>_autolayoutTrace iOS 上一个私有方法，对一个 view 调用此方法会返回一个字符串，字符串包含此 view 的整个视图层级的诊断信息，如果 view 的 translatesAutoresizingMaskIntoConstraints 属性设置为 YES，则有歧义的 view 会被标记出来</li>
</ul>
<p>你需要在控制台输入 oc 语法来执行这些命令。例如，当程序运行中触发断点后，向控制台输入 <code>call [self.myView exerciseAmbiguityInLayout]</code> 从而在 myView 对象上调用 <code>exerciseAmbiguityInLayout</code> 这个方法。类似的，输入 <code>po [self.myView autolayoutTrace]</code> 从而打印出有关 myView 的视图层级的布局诊断信息。</p>
<blockquote>
<p>注意：</p>
<p>确保在运行上面列举的诊断方法之前已经修复了 IB 发现的布局问题。IB 会尝试修复它发现的任何错误，这意味着如果它发现了一个有歧义的布局，它就会添加约束从而使布局不再有歧义。</p>
<p>这样一来，hasAmbiguousLayout 就会返回 NO，exerciseAmbiguityInLayout 也不能起作用，而 constraintsAffectingLayoutForAxis: 可能会返回一些额外的、非预期的约束条件。</p>
</blockquote>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·调试 AutoLayout·无法满足的布局</title>
    <url>/2017/12/27/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7%E8%B0%83%E8%AF%95%20AutoLayout%C2%B7%E6%97%A0%E6%B3%95%E6%BB%A1%E8%B6%B3%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="008-Autolayout指南·调试-AutoLayout"><a href="#008-Autolayout指南·调试-AutoLayout" class="headerlink" title="008-Autolayout指南·调试 AutoLayout"></a>008-Autolayout指南·调试 AutoLayout</h1><h2 id="无法满足的布局"><a href="#无法满足的布局" class="headerlink" title="无法满足的布局"></a>无法满足的布局</h2><p>当系统无法为当前的约束集合找到可行解时就会出现无法满足的布局。两个或更多所需的约束会因为它们不能同时为真而冲突。</p>
<h2 id="辨别无法满足的布局"><a href="#辨别无法满足的布局" class="headerlink" title="辨别无法满足的布局"></a>辨别无法满足的布局</h2><p>一般来说 IB 就可以在设计时期检测出冲突，在这种情况下 IB 会有多种方法来展示这个错误。</p>
<ul>
<li>冲突的约束会在画布上标红</li>
<li>Xcode 会在 issue navigator 中将冲突约束作为警告罗列出来</li>
<li>IB 会在文档大纲的右上角展示一个红色箭头</li>
</ul>
<p>点击箭头会罗列出所有当前布局里的 Autolayout 问题。</p>
<p>IB 经常能够为这些问题提供建议的修复方案，当然也可以在 AutoLayout 的帮助信息里查看更多解决 ViewController、Window、Root View 的冲突问题的方法。</p>
<blockquote>
<p>注意</p>
<p>尽管 IB 提供的即时反馈能方便地创建出可行的布局，但并不能找到所有可能的布局错误。</p>
<p>例如，IB 只能检测出画布当前尺寸下的冲突，然而一些冲突只会在根视图伸展或压缩超过某个点才会出现（或者当内容伸展或压缩超出某个点时）。IB 无法检测出这样的错误。</p>
<p>所以即使你修复了所有 IB 显式提示的问题和错误也是不够的，你仍然需要在运行时里测试各种屏幕尺寸、方向、动态字体大小、你希望支持的语言下你的布局的显式情况。</p>
</blockquote>
<p>当系统在运行时检测到一个无法满足的布局时，它会执行下列步骤</p>
<ul>
<li>AutoLayout 识别出冲突约束的集合</li>
<li>打破冲突约束集合中的某一个约束后检查布局，直到找到一个可行解</li>
<li>AutoLayout 将冲突和被打破的约束的信息打印到控制台</li>
</ul>
<p>这套反馈系统能使应用继续运行，同时仍能尝试向用户展示一些有意义的信息。然而打破约束造成的影响可能因布局不同而变化很大，甚至不同的构建之间也会有很大变化。</p>
<p>在许多情况下，缺失的约束可能没有任何明显的效果，视图层级可能仍然像你期待的那样展示。但也有一些情况下，缺失的约束将导致视图层级整个部分错位、缩放或者消失不显示。</p>
<p>当这些错误没有明显影响时可能会容易被忽视，毕竟它们并不会改变应用的表现效果。但是任何对视图层级或 SDK 的改变都可能会改变被打破的约束集合，从而造成一个明显破损的布局。</p>
<p>所以应当在检测出无法满足的布局时始终坚持修复它们，为 UIViewAlertForUnsatisfiableConstraints 打符号断点可以帮助你确认你在测试时捕捉到了不明显的错误。</p>
<h3 id="预防无法满足的布局"><a href="#预防无法满足的布局" class="headerlink" title="预防无法满足的布局"></a>预防无法满足的布局</h3><p>无法满足的约束相对容易修复，系统会在无法满足的约束出现时告诉你并提供给你一系列冲突的约束。</p>
<p>一旦你知道了这些错误，解决方法一般就很直接了。要么移除其中一个约束，要么将其改成可选的约束。</p>
<p>然而也有一些常见的错误需要你进行更细致的检查：</p>
<ul>
<li>当你用编程的方式向视图层级中添加 view 时经常会出现无法满足的布局。新的 view 的 <a href="https://developer.apple.com/documentation/uikit/uiview/1622572-translatesautoresizingmaskintoco" target="_blank" rel="noopener">translatesAutoresizingMaskIntoConstraints</a> 属性默认为 YES(译者注：Masonry 会在 make、update、remake 的时候设置其为 NO)。当你尝试向画布中的 view 添加约束时，IB 会自动设置该属性为 NO。但是如果你使用编程方式创建和放置你的 view，你就需要在添加约束前手动设置其为 NO。</li>
<li>当一个视图层级被显示在一个远小于它尺寸的空间时会出现无法满足的约束。</li>
</ul>
<p>你通常可以预测到你的 view 所需要的最小尺寸的空间并正确设计你的布局。但是国际化和动态字体都会造成 view 的内容远大于你期望的大小。伴随着排列方式的可能性逐渐增加，确保布局能够在所有状况下正常工作将会显著地困难起来。</p>
<p>Instead, you may want to build in failure points, so that your layout fails in a predictable, controlled manner.（不知道怎么翻译了、、）</p>
<p>可以考虑将一些必须的约束转换为高优先的可选约束，这可以帮助你在发生冲突时控制布局的哪些地方需要被打破。</p>
<p>例如，将你的容错点的优先级设置为 999，在大多无情况下这样的高优先级和必需优先级并没有什么区别。然而一旦冲突出现，高优先级约束就会被打破，从而保护剩余的布局。</p>
<p>类似的，避免给一个有 intrinsic content size 的 view 设置必需的 content-hugging 或 compression-resistance 优先级。一般而言，控制器的尺寸就是一个理想的容错点，控制器可以变得稍微大一些或者小一些，同时对布局不会造成过于显著的影响。</p>
<p>的确，有些控制器只能按照其 intrinsic content size 大小来展示，然而即使是这样的情况，使控制器有几 pt 的错误也比使布局按照无法预测的方式破损的效果要好很多。</p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoLayout指南·概述·AutoLayout Without Constraints</title>
    <url>/2017/12/26/AutoLayout/AutoLayout%E6%8C%87%E5%8D%97%C2%B7%E6%A6%82%E8%BF%B0%C2%B7AutoLayout%20Without%20Constraints/</url>
    <content><![CDATA[<h1 id="AutoLayout指南·概述"><a href="#AutoLayout指南·概述" class="headerlink" title="AutoLayout指南·概述"></a>AutoLayout指南·概述</h1><h2 id="AutoLayout-Without-Constraints"><a href="#AutoLayout-Without-Constraints" class="headerlink" title="AutoLayout Without Constraints"></a>AutoLayout Without Constraints</h2><p>Stack View 提供了一种简单的方式，可以不引入复杂的约束就能运用 AutoLayout 的特性构建用用户界面。一个 StackView 可以定义一行或者一列的用户界面元素。StackView 运用以下属性来调整这些元素。</p>
<ul>
<li>axis(UIStackView Only)：定义 StackView 的轴向是垂直还是水平</li>
<li>orientation(NSStackView only)：定义 StackView 的轴向是垂直还是水平</li>
<li>distribution：定义子 view 沿轴向的排布方式</li>
<li>alignment：设定如何沿轴线垂直方向排布子视图</li>
<li>spacing：设定子视图间距</li>
</ul>
<p>可以在 Interface Builder 中拖一个垂直或者水平的 StackView 到画布上来使用一个 StackView，然后拖出其他内容放到 Stack 中。</p>
<p>如果一个对象自身有固有内容尺寸(intrinsic content size)，则放置到 StackView 中后仍然会保持这一尺寸。如果对象本身没有 intrinsic content size，IB 将会提供一个默认尺寸给它。你可以重新调整对象的尺寸，IB 也会添加约束来维护视图的尺寸。</p>
<p>要进一步调整这个布局，也可以用属性检查器修改 StackView 的属性。比如下面的例子设置了 StackView 的间距为 8，distribution 为 Fills Equallly(默认使用Fill模式，自视图各自按照各自尺寸显示，Fill Equally模式的意思是让所有自视图尺寸大小相等)。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/IB_StackView_Simple_2x.png" width=500>

<p>StackView 也会基于子视图的抗拉伸属性和抗压缩属性来设置布局，你可以用尺寸检查器来修改这些属性。</p>
<blockquote>
<p>注意：</p>
<p>你可以直接通过添加约束的方式来调整子视图的布局，但是要避免任何可能的约束冲突：一般来说，如果一个视图的尺寸默认返回其 Intrinsic Content Size 值，就可以安全给这一维度添加约束。更多关于约束冲突的信息查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ConflictingLayouts.html#//apple_ref/doc/uid/TP40010853-CH19-SW1" target="_blank" rel="noopener">不安全的布局</a></p>
</blockquote>
<p>此外，你也可以嵌套 StackView 到其他 StackView 中，构建更加复杂的布局。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/IB_StackView_NestedStacks_2x.png" width=500>

<p>总而言之，应当尽可能用 StackView 去设置你的布局，只有 StackView 无法达到你想到的效果时才应该借助创建约束的方式去实现。</p>
<p>更多关于使用 StackView 的信息查看 <a href="https://developer.apple.com/documentation/uikit/uistackview" target="_blank" rel="noopener">UIStackView Class Reference</a> 或 <a href="https://developer.apple.com/documentation/appkit/nsstackview" target="_blank" rel="noopener">NSStackView Class Reference</a></p>
<blockquote>
<p>注意：</p>
<p>尽管嵌套 StackView 的使用可以创建更复杂的用户界面，你也不能完全避免使用约束。至少你仍然会需要用约束来布局最外层 StackView 的位置或者尺寸大小。</p>
</blockquote>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoLayout指南·概述·理解AutoLayout</title>
    <url>/2017/12/26/AutoLayout/AutoLayout%E6%8C%87%E5%8D%97%C2%B7%E6%A6%82%E8%BF%B0%C2%B7%E7%90%86%E8%A7%A3AutoLayout/</url>
    <content><![CDATA[<h1 id="AutoLayout指南·概述"><a href="#AutoLayout指南·概述" class="headerlink" title="AutoLayout指南·概述"></a>AutoLayout指南·概述</h1><p><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" target="_blank" rel="noopener">原地址</a></p>
<h2 id="理解-AutoLayout"><a href="#理解-AutoLayout" class="headerlink" title="理解 AutoLayout"></a>理解 AutoLayout</h2><p>基于设置在 view 上的约束，Auto Layout 可以动态计算视图层级中所有 view 的大小和位置。例如，你可以使一个按钮的中心与一张图片的 view 水平对齐，并使按钮的上边缘始终保持低于图像底部 8 个点。如果图片 view 的大小或位置发生了变化，按钮的位置也会自动变化从而保持约束。</p>
<p>这种基于约束方式设计的界面允许你构建的用户界面能动态响应内部与外部的变化。</p>
<h2 id="外部变化"><a href="#外部变化" class="headerlink" title="外部变化"></a>外部变化</h2><p>当你的 superView 的大小或形状发生变化时会引起所谓的“外部变化”，对于这些变化，你必须更新视图层级的布局从而使用好可利用的空间。这里有一些常见的外部变化的来源</p>
<ul>
<li>用户在 OSX 上改变了 window 的大小（OS X）</li>
<li>用户在 iPad 上进入或离开 Split View (iOS)</li>
<li>设备发生了旋转 (iOS)</li>
<li>设备来电以及录音导航栏出现或者隐藏 (iOS)</li>
<li>你希望支持不同大小的 sizeClass</li>
<li>你希望支持不同屏幕尺寸</li>
</ul>
<p>大部分变化都可能在运行时发生，并需要应用做出动态的响应。即使屏幕尺寸不会发生显著的变化，创建一个适配性强的用户界面也会使你的应用同时在 4S 和 6P 上，甚至是在 iPad 上运行良好。Auto Layout 同时也是支持 iPad 的 Slide Over 和 Split View 模式的关键组件。</p>
<h2 id="内部变化"><a href="#内部变化" class="headerlink" title="内部变化"></a>内部变化</h2><p>当应用的视图或控制器大小发生变化时，就会引起所谓的“内部变化”。这里有一些常见的内部变化发生的来源：</p>
<ul>
<li>展示在 app 里的内容发生了变化</li>
<li>app 需要支持国际化</li>
<li>app 需要支持动态字体大小(Dynamic Type)</li>
</ul>
<p>当应用展示的内容发生变化时，新的内容或许需要一个与旧的视图不一样的布局结构。这种情况一般发生在展示图片或文案的应用中。例如，一个新闻 app 需要调整布局来适应不同尺寸的新闻文章。或者一个照片拼图需要处理多种多样的图片尺寸与分辨率。</p>
<p>使应用能够适应不同语言、地区和文化的过程称为国际化。国际化应用的布局必须把这些差异考虑在内，同时在这个应用所支持的所有语言与地区中，正确显示布局。</p>
<p>国际化对于布局有三个主要的影响。首先，当我们将用户界面上的文案翻译为一个不同的语言时，字符需要不同空间来展示。例如德语相对于英语就需要比较多的空间来展示，而日语所需空间一般会少很多。</p>
<p>其次，不同地区展示日期与数字的样式可能有所不同，即使这些地区使用同一种语言。尽管这些样式相对于语言的变化较小，用户界面依然需要适配这些微小尺寸的变化。</p>
<p>最后，改变语言不仅仅会影响到文案的尺寸，也会影响到布局的组织结构，不同语言会使用不同的排版方向。例如英语使用从左到右的排版方向，而阿拉伯语和希伯来语则使用从右到左的排版方向。因此用户界面元素的顺序也需要进行调整以适应这种排版的不同。如果在展示英语文案的界面里有一个居于右下角的按钮，则在展示阿拉伯语文案的界面里它需要展示在左下角。</p>
<p>最后，如果应用还支持动态字体大小，那么用户就可以改变应用中文案的字体大小了。这一特性会同时改变用户界面上所有文本组件的高度和宽度。当用户在应用运行时改变了字体大小，那么应用就必须同时改变字体和布局结构来适应这种变化。</p>
<h3 id="自动布局与基于-Frame-的布局对比"><a href="#自动布局与基于-Frame-的布局对比" class="headerlink" title="自动布局与基于 Frame 的布局对比"></a>自动布局与基于 Frame 的布局对比</h3><p>构建用户界面有三种主要的方式。你可以用 frame 代码布局用户界面，也可以用 autoResizing 技术自动实现对外部变化的一些响应，同时也可以用 autoLayout 技术。</p>
<p>传统的开发过程中，开发者们通过手动为视图层级中的每个 view 设置 frame 的方式，来布局他们的用户界面，frame 定义了 view 在父视图坐标系统里的位置和宽高。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/layout_views_2x.png" width=500>

<p>为了正确构建用户界面，你需要计算视图层级中每一个 view 的位置和尺寸，当界面发生变化时，需要再次计算所有受影响 view 的 frame。</p>
<p>用代码定义一个 view 的 frame 在很多时候提供了足够的灵活性和稳定性。当变化发生时，你可以逐步设置任何你想要的变化效果。但正是由于需要自己手动处理所有变化情况，使用 frame 布局一个非常简单的界面也需要大量精力去设计、调试和维护。因此许多开发者都非常关注如何创建一个真正自适应的用户界面并有效减少复杂的布局维护工作。</p>
<p>当然你可以使用 AutoResizing 特性来帮助缓解一些 frame 布局带来的复杂工作。一个 AutoResizing 掩码定义了当一个父视图发生变化时，子视图如何改变自身的 frame。这一特性简化了为适应外部变化而创建的布局代码。</p>
<p>然而，autoresizing mask提供了一小部分的自动适配。对于复杂的用户界面，你通常还需要手动添加很多autoresizing mask来适配。此外，autoresizing mask只适配了外部变化，不支持内部变化。</p>
<p>AutoLayout 利用一系列的约束来定义你的用户界面。约束表达了两个 view 之间的布局关系。AutoLayout 会基于约束来计算每一个 view 的尺寸和大小。这种布局可以动态响应内部与外部的各种变化。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/layout_constraints_2x.png" width=500>

<p>利用约束生成特定布局表现的逻辑远远不同于编写过程式代码的逻辑或是面向对象代码的逻辑。很幸运的是，掌握 AutoLayout 并不同于掌握其他的编程能力。你只需要做到两步：首先理解基于约束进行布局的背后逻辑，其次学习相应的 API。你已经在学习其他编程能力时熟练掌握了这两步，AutoLayout 在这一点上并没有什么差别。</p>
<p>指南剩下的部分将会帮助你逐步过渡到 AutoLayout 上来。<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AutoLayoutWithoutConstraints.html#//apple_ref/doc/uid/TP40010853-CH8-SW1" target="_blank" rel="noopener">无约束的自动布局</a> 章节将会阐述一种高水平的抽象概念来简化用户界面背后所创建的 AutoLayout。<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1" target="_blank" rel="noopener">详解约束</a> 阐述为了更好使用 AutoLayout 需要掌握的理论知识。<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW1" target="_blank" rel="noopener">在 IB 中使用约束</a> 介绍了自动布局用到的一些工具。<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html#//apple_ref/doc/uid/TP40010853-CH16-SW1" target="_blank" rel="noopener">编程实现约束</a> 和 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH3-SW1" target="_blank" rel="noopener">AutoLayout 烹饪书</a> 细致描述了 AutoLayout 的 API。最后，<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH3-SW1" target="_blank" rel="noopener">AutoLayout 烹饪书</a> 陈列了一些不同复杂度下的示例布局，你可以学习并在自己的项目中使用这些示例。<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1" target="_blank" rel="noopener">AutoLayout 调试</a> 则提供了一些设备和工具用以在出错时对 AutoLayout 进行修复。</p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoLayout指南·AutoLayout Cookbook·intrinsic content size 视图</title>
    <url>/2017/12/26/AutoLayout/AutoLayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20Cookbook%C2%B7intrinsic%20content%20size%20%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="AutoLayout指南·AutoLayout-Cookbook"><a href="#AutoLayout指南·AutoLayout-Cookbook" class="headerlink" title="AutoLayout指南·AutoLayout Cookbook"></a>AutoLayout指南·AutoLayout Cookbook</h1><h2 id="intrinsic-content-size-视图"><a href="#intrinsic-content-size-视图" class="headerlink" title="intrinsic content size 视图"></a>intrinsic content size 视图</h2><p>接下来的示例将会使用一些有 intrinsic content size 的 view。一般来说，intrinsic content size 可以简化布局，减少所需约束的数目，但是使用 intrinsic content size 又经常需要设置 view 的 content-hugging 和 compression-resistance（CHCR）优先级，这会增加额外的复杂度。</p>
<p>查看源代码请前往 <a href="https://developer.apple.com/sample-code/xcode/downloads/Auto-Layout-Cookbook.zip" target="_blank" rel="noopener">AutoLayout CookBook</a></p>
<h3 id="简单的-label-和-textField"><a href="#简单的-label-和-textField" class="headerlink" title="简单的 label 和 textField"></a>简单的 label 和 textField</h3><p>这一节展示了如何放置一个简单的 label 和一个 textfield。在示例中我们设置 label 的宽度随着它的文案长度而变化，textfield 则伸缩自身来填满剩余的区域。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Label_and_Text_Field_Pair_2x.png" width=500>

<p>由于示例用到了 view 的 intrinsic content size，所以你只需要五条约束就可以实现布局，但是你必须将 CHCR 的优先级设置正确才能获得合理的效果。</p>
<p>查看更多关于 intrinsic content size 和 CHCR 优先级请前往 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW21" target="_blank" rel="noopener">Intrinsic Content Size</a></p>
<h4 id="视图和约束"><a href="#视图和约束" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>在 IB 中，拖进一个 label 和一个 textfield，设置 label 的文案和 textfield 的占位文案，然后将约束设置如下</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/simple_label_and_text_field_2x.png" width=500>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">Name</span> Label.<span class="keyword">Leading</span> = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="type">Name</span> <span class="type">Text</span> Field.<span class="keyword">Trailing</span> = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="type">Name</span> <span class="type">Text</span> Field.<span class="keyword">Leading</span> = <span class="type">Name</span> Label.<span class="keyword">Trailing</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="type">Name</span> <span class="type">Text</span> Field.Top = Top Layout Guide.Bottom + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="type">Name</span> label.Baseline = <span class="type">Name</span> <span class="type">Text</span> Field.Baseline</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>为了使 textfield 伸展来填空空白区域，要设置它的 content-hugging 小于 label 的 content-hugging。当然 IB 默认就将 label 的 content-hugging 设置为 251，而将 textfield 设置为 250。你也可以在尺寸检查器进行修改。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Horizontal hugging</th>
<th>Vertical hugging</th>
<th>Horizontal resistance</th>
<th>Vertical resistance</th>
</tr>
</thead>
<tbody><tr>
<td>Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>textfield</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
</tbody></table>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>要注意这个布局里只用到了约束 4 和 5 来定义垂直约束，约束 1、2 和 3 来定义水平约束。在 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW16" target="_blank" rel="noopener">Creating Nonambiguous, Satisfiable</a> 一节中我们提到一个 view 至少需要两条水平约束和两条垂直约束，然而这里 label 和 textfield 的 intrinsic content size 已经定义了它们的高度以及 label 的宽度，因此减少了三条约束。</p>
<p>示例还简单假设了 textfield 的高度始终高于 label，从而使用 textfield 的高度来定义从视窗顶部到 textfield 顶部的距离。由于 label 和 textfield 都是用来展示文案的，所以示例利用文案的 Baseline 对二者进行了垂直对齐。</p>
<p>在水平方向上，你仍然需要定义哪一个 view 拓展自身来铺满可填充区域。你需要通过修改 CHCR 优先级来实现。在这个例子中，IB 已经将 name label 的Horizontal hugging 和 Vertical hugging 优先级设置为 251 了，相比于 textfield 的默认 250 优先级，label 将更不容易被伸展。</p>
<blockquote>
<p>注意</p>
<p>如果布局会被展示在一个非常小的屏幕上，那么你就需要修改 compression resistance 来决定当展示空间不足时哪一个 view 会被截断。</p>
<p>在这个例子中，修改 compression resistance 的工作将留给读者完成。如果 name label 的文案或者字体过大，那么将没有足够空间来展示，此时会出现有歧义的布局。系统会尝试打破一个约束，所以 textfield 和 label 都有可能会被截断。</p>
<p>理想情况下，你会希望创建一个对于可用空间而言不会太大的布局 - 根据需要使用紧凑尺寸类的替代布局。但是当你的 view 被设计为支持多种语言和字体时，你将很难预测每一行文案会有多大。以防万一，修改 compression resistance 会是一个是一个很好的安全选择。</p>
</blockquote>
<h3 id="动态高度的-label-和-textfield"><a href="#动态高度的-label-和-textfield" class="headerlink" title="动态高度的 label 和 textfield"></a>动态高度的 label 和 textfield</h3><p>在 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW8" target="_blank" rel="noopener">Simple Label and Text Field</a> 示例中我们通过假设 textfield 的高度始终高于 label 简化了约束，但是这并不是始终成立的。如果你将 label 字体的大小增加足够大，label 的高度就会超过 textfield。</p>
<p>这一节示例将根据两个 view 的最高高度动态设置垂直空间，如果设置的字体时系统默认字体，则这一节的布局与上一节完全一样。但是如果你讲 label 的字体大小增加到 36 像素点，则布局的垂直高度就会按照 label 的顶部来计算。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Label_and_Text_Field_Pair_2x.png" width-500>

<p>这个例子有些生硬，毕竟当你增加了 label 的字体大小时，你一般也会增加 textfield 的字体大小。然而如果在 iphone 的辅助设置里设置了一个非常非常大的字体，那么这个技术就会在混合使用动态字体和固定字体的控件时起很大作用。</p>
<h4 id="视图和约束-1"><a href="#视图和约束-1" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>像上一节一样设置视图层级，然后使用一些较为复杂的约束</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/dynamic_height_label_and_text_field_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Name <span class="keyword">Label</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Name <span class="keyword">Text</span> Field.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Name <span class="keyword">Text</span> Field.Leading = Name <span class="keyword">Label</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> &gt;= <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span> (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> &gt;= <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span> (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> Name label.<span class="keyword">Baseline</span> = Name <span class="keyword">Text</span> Field.<span class="keyword">Baseline</span></span><br></pre></td></tr></table></figure>

<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>为了使 textfield 铺满可填充区域，要设置它的 content-hugging 低于 label 的 content-hugging。IB 会默认将 label 的content-hugging 设置为 251，textfield 为 250.你也可以在尺寸检查器中修改</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Horizontal hugging</th>
<th>Vertical hugging</th>
<th>Horizontal resistance</th>
<th>Vertical resistance</th>
</tr>
</thead>
<tbody><tr>
<td>Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>textfield</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
</tbody></table>
<h4 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h4><p>这一节对于每一个组件用到了一对约束，一个是必需的大于等于约束，用于定义 view 与边界的最小间距。一个是可选的约束，用于将间距精确设置为 20 个像素点。</p>
<p>对于高度较高的 view，两个约束都可以满足，所以系统会精确设置该 view 高度为 20 像素点，而对于高度较小的 view，只能满足最小间距，另一个约束会被忽略，因此这样就使得 AutoLayout 能在运行时根据 view 的高度变化动态计算出布局。</p>
<blockquote>
<p>注意：</p>
<p>要确保可选约束的优先级低于默认的 content-hugging 优先级，否则系统会尝试打破 content-hugging 约束从而拉伸 view，而不是重新定位其位置。</p>
<p>这一点在使用基于 Baseline 对齐的布局时尤其容易迷惑，因为 Baseline  对齐只会在 textView 是按照其 intrinsic content size 展示时才会生效。如果系统重新设置了某个 view 的尺寸，那么文案可能就不是合理的排列，即使设置了必需的 Baseline 约束。</p>
</blockquote>
<h3 id="固定高度的一列视图"><a href="#固定高度的一列视图" class="headerlink" title="固定高度的一列视图"></a>固定高度的一列视图</h3><p>这一节将会把 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW8" target="_blank" rel="noopener">Simple Label and Text Field</a> 拓展到一列包含 label 和 textfield 的视图中。其中所有 label 的右边线都被对齐。textfield 的左右边线也是对其的，并且横向间距取决于最长的 label。然而与 Simple Label and Text Field 一节类似，示例简单假设了 textfield 的高度始终高于 label。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Label_and_Text_Field_Columns_2x.png" width=500>

<h4 id="视图和约束-2"><a href="#视图和约束-2" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>类似 Fixed Height Columns 一节一样放置 label 和 textfield，但是需要添加一些额外的约束。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/dynamic_columns_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Middle Name <span class="keyword">Label</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Leading = <span class="keyword">First</span> Name <span class="keyword">Label</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> Middle Name <span class="keyword">Text</span> Field.Leading = Middle Name <span class="keyword">Label</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.Leading = <span class="keyword">Last</span> Name <span class="keyword">Label</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> Middle Name <span class="keyword">Text</span> Field.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Baseline</span> = <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Baseline</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> Middle Name <span class="keyword">Label</span>.<span class="keyword">Baseline</span> = Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Baseline</span></span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.<span class="keyword">Baseline</span> = <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Baseline</span></span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Width = Middle Name <span class="keyword">Text</span> Field.Width</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Width = <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.Width</span><br><span class="line"></span><br><span class="line"><span class="number">15.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> &gt;= <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span> (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> &gt;= <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">18.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span> (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">19.</span> Middle Name <span class="keyword">Label</span>.<span class="keyword">Top</span> &gt;= <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">20.</span> Middle Name <span class="keyword">Label</span>.<span class="keyword">Top</span> = <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">21.</span> Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> &gt;= <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">22.</span> Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> = <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">23.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> &gt;= Middle Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">24.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> = Middle Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">25.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> &gt;= Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">26.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> = Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br></pre></td></tr></table></figure>

<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>在属性检查器中设置如下属性，要注意将 label 的文案右对齐，右对齐文案可以使你使用比文案更长的 label，并仍保证文案的边线与 textfield 的边线是对齐的。</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>First Name Label</td>
<td>Text</td>
<td>Frist Name</td>
</tr>
<tr>
<td>First Name Label</td>
<td>Alignment</td>
<td>Right</td>
</tr>
<tr>
<td>First Name Text Filed</td>
<td>Placeholder</td>
<td>Enter First Name</td>
</tr>
<tr>
<td>Last Name Label</td>
<td>Text</td>
<td>Last Name</td>
</tr>
<tr>
<td>Last Name Label</td>
<td>Alignment</td>
<td>Right</td>
</tr>
<tr>
<td>Last Name Text Filed</td>
<td>Placeholder</td>
<td>Enter Last Name</td>
</tr>
<tr>
<td>Middle Name Label</td>
<td>Text</td>
<td>Middle Name</td>
</tr>
<tr>
<td>Middle Name Label</td>
<td>Alignment</td>
<td>Right</td>
</tr>
<tr>
<td>Middle Name Text Filed</td>
<td>Placeholder</td>
<td>Enter Middle Name</td>
</tr>
</tbody></table>
<p>对于每一对 label 和 textfield，label 的 content-hugging 都要比 textfield 的大。IB 再一次自动做了这些设置，当然你仍然可以在尺寸检查器中修改它们</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Horizontal hugging</th>
<th>Vertical hugging</th>
<th>Horizontal resistance</th>
<th>Vertical resistance</th>
</tr>
</thead>
<tbody><tr>
<td>First Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>First Name TextFiled</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Middle Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Middle Name TextFiled</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Last Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Last Name TextFiled</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
</tbody></table>
<h4 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h4><p>这一节示例的布局仅仅是对 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW8" target="_blank" rel="noopener">简单的 label 和 textField</a> 一节的三次拷贝，将其一个一个堆叠起来。但为了正确排列每一行，你需要添加一些额外的约束。</p>
<p>首先通过右对齐 label 的文案进行问题简化，你现在可以使所有的 label 保持一样的宽度，无论文案有多长，都可以容易地对齐它们的边线。另外，由于一个 Label 的 compression resistance 优先级高于它的 content hugging，所有的 label 都更易于伸展而难于压缩。所以当对齐了所有 label 的左右边线后，label 会自动按照最长 label 的 intrinsic content size 的宽度来伸展。</p>
<p>所以你只需要将所有 Label 的左右边线对齐就可以了。你同样需要对齐所有 textfield 的左右边线。幸运的是，Label 的左边线已经与父视图的边线对齐了，类似地，textfield 的右边线也与所有父视图的边线对齐。由于每一行都有相同的宽度，所以你只需要将剩下的两个边线(应该是 label 的右边线和 textfield 的左边线)的其中一个对齐，所有行都会被对齐。</p>
<p>有很多方法都可以实现这样的效果，在示例中我们将每一个 textfield 的宽度设置为相同宽度。</p>
<h3 id="动态高度的一列视图"><a href="#动态高度的一列视图" class="headerlink" title="动态高度的一列视图"></a>动态高度的一列视图</h3><p>这一节示例将把 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW16" target="_blank" rel="noopener">动态高度的 label 和 textfield</a> 与 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW24" target="_blank" rel="noopener">固定高度的一列视图</a> 两个示例混合使用，需要达到的目标如下</p>
<ul>
<li>label 的右边线基于最长的 label 对齐</li>
<li>textfield 的宽度相同，且左右边线对齐</li>
<li>textfield 拓展自身填充父视图的可填充区域</li>
<li>每一行的行高取决于此行中最高的元素</li>
<li>一切都是动态的，所以当字体大小或 label 的文案变化时，布局会自动更新</li>
</ul>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Label_and_Text_Field_Columns_2x.png" width=500>

<h4 id="视图与约束"><a href="#视图与约束" class="headerlink" title="视图与约束"></a>视图与约束</h4><p>像固定高度的一列视图一样放置一些 lable 和 textfield，但是需要设置一些额外的约束</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/dynamic_columns_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Middle Name <span class="keyword">Label</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Leading = <span class="keyword">First</span> Name <span class="keyword">Label</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> Middle Name <span class="keyword">Text</span> Field.Leading = Middle Name <span class="keyword">Label</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.Leading = <span class="keyword">Last</span> Name <span class="keyword">Label</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> Middle Name <span class="keyword">Text</span> Field.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Baseline</span> = <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Baseline</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> Middle Name <span class="keyword">Label</span>.<span class="keyword">Baseline</span> = Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Baseline</span></span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.<span class="keyword">Baseline</span> = <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Baseline</span></span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Width = Middle Name <span class="keyword">Text</span> Field.Width</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.Width = <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.Width</span><br><span class="line"></span><br><span class="line"><span class="number">15.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> &gt;= <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span> (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> &gt;= <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">18.</span> <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span> (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">19.</span> Middle Name <span class="keyword">Label</span>.<span class="keyword">Top</span> &gt;= <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">20.</span> Middle Name <span class="keyword">Label</span>.<span class="keyword">Top</span> = <span class="keyword">First</span> Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">21.</span> Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> &gt;= <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">22.</span> Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> = <span class="keyword">First</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">23.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> &gt;= Middle Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">24.</span> <span class="keyword">Last</span> Name <span class="keyword">Label</span>.<span class="keyword">Top</span> = Middle Name <span class="keyword">Label</span>.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">25.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> &gt;= Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">26.</span> <span class="keyword">Last</span> Name <span class="keyword">Text</span> Field.<span class="keyword">Top</span> = Middle Name <span class="keyword">Text</span> Field.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">249</span>)</span><br></pre></td></tr></table></figure>

<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><p>在属性检查器中设置以下属性，特别的，需要将所有 label 的文案右对齐。将 label 右对齐可以使你使用比文案长的 label，并且保证文案的边界依然按照 textfield 的边线对齐。</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>First Name Label</td>
<td>Text</td>
<td>Frist Name</td>
</tr>
<tr>
<td>First Name Label</td>
<td>Alignment</td>
<td>Right</td>
</tr>
<tr>
<td>First Name Text Filed</td>
<td>Placeholder</td>
<td>Enter First Name</td>
</tr>
<tr>
<td>Last Name Label</td>
<td>Text</td>
<td>Last Name</td>
</tr>
<tr>
<td>Last Name Label</td>
<td>Alignment</td>
<td>Right</td>
</tr>
<tr>
<td>Last Name Text Filed</td>
<td>Placeholder</td>
<td>Enter Last Name</td>
</tr>
<tr>
<td>Middle Name Label</td>
<td>Text</td>
<td>Middle Name</td>
</tr>
<tr>
<td>Middle Name Label</td>
<td>Alignment</td>
<td>Right</td>
</tr>
<tr>
<td>Middle Name Text Filed</td>
<td>Placeholder</td>
<td>Enter Middle Name</td>
</tr>
</tbody></table>
<p>对于每一对 label 和 textfield，label 的 content-hugging 都要比 textfield 的大。IB 再一次自动做了这些设置，当然你仍然可以在尺寸检查器中修改它们</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Horizontal hugging</th>
<th>Vertical hugging</th>
<th>Horizontal resistance</th>
<th>Vertical resistance</th>
</tr>
</thead>
<tbody><tr>
<td>First Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>First Name TextFiled</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Middle Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Middle Name TextFiled</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Last Name Label</td>
<td>251</td>
<td>251</td>
<td>750</td>
<td>750</td>
</tr>
<tr>
<td>Last Name TextFiled</td>
<td>250</td>
<td>250</td>
<td>750</td>
<td>750</td>
</tr>
</tbody></table>
<h4 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h4><p>这一节示例简单地混用了<a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW16" target="_blank" rel="noopener">动态高度的 label 和 textfield</a> 和 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW24" target="_blank" rel="noopener">固定高度的一列视图</a> 中介绍的技术。利用动态高度的 label 和 textfield 示例中的技术，使用了一对约束来动态设置行间的垂直间距。利用固定高度的一列视图示例中的技术，将 label 的文案设置为右对齐，并显式声明了列中视图的等宽关系。</p>
<blockquote>
<p>注意</p>
<p>示例中用 20 像素点来设置 view 的顶部与 top Layout guide 的间距，同时设置兄弟 view 之间间距为 8 像素点。这与直接设置一个固定的 20 像素点的顶部间距是一样的效果。但是如果你想使上边距能根据 bar 的显示与否自动适应的话，就需要一些额外的约束。在 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSimpleConstraints.html#//apple_ref/doc/uid/TP40010853-CH12-SW4" target="_blank" rel="noopener">单一自适应 View</a> 一节中介绍了一种一般性方法，这里我们将具体的实现留给读者。</p>
</blockquote>
<p>正如你所看到的，布局逻辑逐渐变得有些复杂了，但是仍然有一些方法可以简化它。首先，正如前面所提到的，你应当尽可能使用 StackView 来实现你的布局。同时你也可以对组件进行分组，然后对成组的组件进行布局。</p>
<h3 id="两个等宽按钮"><a href="#两个等宽按钮" class="headerlink" title="两个等宽按钮"></a>两个等宽按钮</h3><p>这一节将展示如何放置两个尺寸相同的按钮。垂直方向上，按钮将与屏幕的底部对齐。水平方向上，按钮会被伸展以铺满可填充区域。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Two_Equal-Width_Buttons_screen_2x.png" width=500>

<h4 id="视图和约束-3"><a href="#视图和约束-3" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>在 IB 中拖两个按钮到场景中，并用 guideline 将它们与场景底部的对齐，不要纠结于使它们完全等宽，只需要将其中一个伸展以铺满水平区域即可。大致放置好它们的位置后，将约束设置如下。AutoLayout 会计算出它们最终正确的位置。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_equal-width_buttons_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Long <span class="keyword">Button</span>.Leading = <span class="keyword">Short</span> <span class="keyword">Button</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Long <span class="keyword">Button</span>.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Short</span> <span class="keyword">Button</span>.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = Long <span class="keyword">Button</span>.Botton + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Width = Long <span class="keyword">Button</span>.Width</span><br></pre></td></tr></table></figure>

<h4 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h4><p>设置按钮的背景颜色从而更容易查看它们的 frame 是否会根据设备的旋转而变化，另外，还要使用不同长度的文案，从而能够体现按钮的文案不会影响按钮宽度的效果。</p>
<p>View|Attribute|Value<br>|—|—|—|<br>Short Button|Background|Light Gray Color<br>Short Button|Title|short<br>Long Button|Background|Light Gray Color<br>Long Button|Title|Much Longer Button Title</p>
<h4 id="讨论-4"><a href="#讨论-4" class="headerlink" title="讨论"></a>讨论</h4><p>这一节示例在计算布局时使用了按钮的固有高度而不是宽度。水平方向上，按钮会有明确的大小从而保证它们有相同的宽度并能填满可填充区域。可以将本节示例与 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSimpleConstraints.html#//apple_ref/doc/uid/TP40010853-CH12-SW17" target="_blank" rel="noopener">两个等宽视图</a> 一节进行比较，从而了解按钮的固有高度如何影响布局。在这节示例中只使用了两个垂直约束而不是四个。</p>
<p>按钮也会被赋值不同长度的文案从而帮助说明按钮的文案如何影响(或者不会影响)布局。</p>
<blockquote>
<p>注意</p>
<p>在这一节中，按钮的背景颜色被设置为亮灰色以帮助你查看它们的 frame。一般按钮和 label 的背景都是透明的，所以查看它们的 frame 变化会比较困难(但不是不可能)。</p>
</blockquote>
<h3 id="三个等宽按钮"><a href="#三个等宽按钮" class="headerlink" title="三个等宽按钮"></a>三个等宽按钮</h3><p>这一节示例拓展了 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW4" target="_blank" rel="noopener">两个等宽按钮</a> 的示例，从而实现三个等宽按钮的布局。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Three_Equal-Width_Buttons_screen_2x.png" width=500>

<h4 id="视图和约束-4"><a href="#视图和约束-4" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>将按钮如图放置，并设置约束如下</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/three_equal-width_buttons_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">Medium</span> <span class="keyword">Button</span>.Leading = <span class="keyword">Short</span> <span class="keyword">Button</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Long <span class="keyword">Button</span>.Leading = <span class="keyword">Medium</span> <span class="keyword">Button</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Long <span class="keyword">Button</span>.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Short</span> <span class="keyword">Button</span>.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Medium</span> <span class="keyword">Button</span>.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> <span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = Long <span class="keyword">Button</span>.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Width = <span class="keyword">Medium</span> <span class="keyword">Button</span>.Width</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Width = Long <span class="keyword">Button</span>.Width</span><br></pre></td></tr></table></figure>

<h4 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h4><p>设置按钮的背景颜色从而更容易查看它们的 frame 是否会根据设备的旋转而变化，另外，还要使用不同长度的文案，从而能够体现按钮的文案不会影响按钮宽度的效果。</p>
<p>View|Attribute|Value<br>|—|—|—|<br>Short Button|Background|Light Gray Color<br>Short Button|Title|Short<br>Medium Button|Background|Light Gray Color<br>Medium Button|Title|Medium<br>Long Button|Background|Light Gray Color<br>Long Button|Title|Long Button Title</p>
<h4 id="讨论-5"><a href="#讨论-5" class="headerlink" title="讨论"></a>讨论</h4><p>添加一个额外的按钮就需要添加额外三个约束，包括两个水平约束和一个垂直约束。要注意你并没有使用按钮的固有宽度，所以你需要设置至少两个水平约束来唯一确定按钮的位置和尺寸。但是你可以使用按钮的固有高度从而只需要使用一个额外的约束来确定按钮的垂直位置。</p>
<blockquote>
<p>注意</p>
<p>为了快速设置等宽约束，可以选取所有按钮后用 IB 的 Pin 工具创建一个等宽约束，IB 会自动为所有按钮创建所需的约束。</p>
</blockquote>
<h3 id="两个等间距按钮"><a href="#两个等间距按钮" class="headerlink" title="两个等间距按钮"></a>两个等间距按钮</h3><p>表面上看这一节好像与 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW4" target="_blank" rel="noopener">两个等宽按钮</a> 很类似，但是在这一节示例中按钮的宽度是基于最长的文案来确定的。如果有足够的空白空间，所有按钮都只会以最长文案的按钮的固有的宽度而伸展自身，而额外的空间则会被按钮等分。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Two_Buttons_with_Equal_Spacing_screen_2x.png" width=500>

<p>在 iphone 的竖直模式下，两个等宽按钮和两个等间距按钮的效果非常相似，而如果是在 iphone 的水平模式或者是 iPad 等大屏设备上，这两者的区别就会非常明显。</p>
<h3 id="视图与约束-1"><a href="#视图与约束-1" class="headerlink" title="视图与约束"></a>视图与约束</h3><p>在 IB 中拖出两个按钮和三个 view 对象并放置好位置，使按钮在 view 之间，然后设置约束如下</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_buttons_with_equal_spacing_2x.png" width=500>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">Leading</span> Dummy <span class="keyword">View</span>.<span class="keyword">Leading</span> = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Short Button.<span class="keyword">Leading</span> = <span class="keyword">Leading</span> Dummy <span class="keyword">View</span>.<span class="keyword">Trailing</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Center Dummy <span class="keyword">View</span>.<span class="keyword">Leading</span> = Short Button.<span class="keyword">Trailing</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Long Button.<span class="keyword">Leading</span> = Center Dummy <span class="keyword">View</span>.<span class="keyword">Trailing</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="keyword">Trailing</span> Dummy <span class="keyword">View</span>.<span class="keyword">Leading</span> = Long Button.<span class="keyword">Trailing</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="keyword">Trailing</span> Dummy <span class="keyword">View</span>.<span class="keyword">Trailing</span> = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Bottom Layout Guide.Top = <span class="keyword">Leading</span> Dummy <span class="keyword">View</span>.Bottom + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> Bottom Layout Guide.Top = Short Button.Bottom + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> Bottom Layout Guide.Top = Center Dummy <span class="keyword">View</span>.Bottom + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> Bottom Layout Guide.Top = Long Button.Bottom + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> Bottom Layout Guide.Top = <span class="keyword">Trailing</span> Dummy <span class="keyword">View</span>.Bottom + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">12.</span> Short Button.<span class="keyword">Leading</span> &gt;= Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span> Long Button.<span class="keyword">Leading</span> &gt;= Short Button.<span class="keyword">Trailing</span> + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">14.</span> Superview.TrailingMargin &gt;= Long Button.<span class="keyword">Trailing</span></span><br><span class="line"></span><br><span class="line"><span class="number">15.</span> <span class="keyword">Leading</span> Dummy <span class="keyword">View</span>.Width = Center Dummy <span class="keyword">View</span>.Width</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span> <span class="keyword">Leading</span> Dummy <span class="keyword">View</span>.Width = <span class="keyword">Trailing</span> Dummy <span class="keyword">View</span>.Width</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span> Short Button.Width = Long Button.Width</span><br><span class="line"></span><br><span class="line"><span class="number">18.</span> <span class="keyword">Leading</span> Dummy <span class="keyword">View</span>.Height = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">19.</span> Center Dummy <span class="keyword">View</span>.Height = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">20.</span> <span class="keyword">Trailing</span> Dummy <span class="keyword">View</span>.Height = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<h4 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h4><p>将按钮的背景颜色设置为非透明颜色，从而方便查看当设置旋转时它们的 frame 的变化。另外，将按钮的文案设置为不同长度的文案，按钮应当基于最长的文案来确定其尺寸。</p>
<p>View|Attribute|Value<br>|—|—|—|<br>Short Button|Background|Light Gray Color<br>Short Button|Title|Short<br>Long Button|Background|Light Gray Color<br>Long Button|Title|Much Longer Button Title</p>
<h4 id="讨论-6"><a href="#讨论-6" class="headerlink" title="讨论"></a>讨论</h4><p>正如你所看到的，约束逐渐变得复杂了起来。不过这个示例只是用于演示一种特定的技术，如果是在实际项目中应当考虑使用 StackView 来代替。</p>
<p>在这里，你希望空白区域能随着父视图的 frame 变化而变化。这意味着你需要一系列的等宽约束来控制空白区域的宽度，但是你不能对着空区域进行约束设置，你只能约束某类确定的对象。</p>
<p>在这个示例中，你使用傀儡 view 来表示空白区域，这些 view 都是 UIView 的空白实例。在示例中为了保证最小化它们在视图层级中的影响，它们被设置为 0 像素点的高度。</p>
<blockquote>
<p>注意</p>
<p>傀儡 view 会对你的布局增加额外的开销，所以你应当谨慎使用。如果这些傀儡 view 很大的话，它们的 graphic context 就会消耗一个相当大的数量，即使它们并未包含任何有意义的信息。</p>
<p>此外，这些 view 还会参与视图层级的响应链，这意味着它们会对在响应链中传递的一些类似 hit-testing 的消息进行响应。如果不小心处理，这些 view 就可能中断并相应这些消息并产生不易发现的 bug。</p>
</blockquote>
<p>可选的，你可以采用 UILayoutGuide 类的实例来表示这些空白区域。这个轻量级的类用于表示一个可以参与到 AutoLayout 约束的矩形 frame。layoutguide 并没有实际的 graphic context，也不是视图层级的一部分。这使得 layoutguide 最适合用于对元素分组或者定义空白区域。</p>
<p>但不幸的是你不能在 IB 的场景中使用 layoutguide，而在一个基于 storyboard 的场景里混合使用代码创建的视图对象是一件相当复杂的事情。所以作为一个一般规范，相比于使用自定义 layoutguide，最好还是使用 storyboard 和 IB。</p>
<p>这个示例使用了大于等于约束来定义按钮间空白区域的最小长度。必需约束同样保证了按钮和傀儡 view 都有了各自相同的宽度。剩下的布局主要由按钮的 CHCR 优先级来控制。如果没有足够的空间，傀儡 view 就会收缩到 0 像素宽度，按钮会平分可填充区域（并保持标准间距）。可填充区域增加时，按钮只会去拓展到最长按钮的固有宽度，傀儡 view 会填满剩下的所有区域。</p>
<h3 id="两个基于-Size-Class-布局的按钮"><a href="#两个基于-Size-Class-布局的按钮" class="headerlink" title="两个基于 Size-Class 布局的按钮"></a>两个基于 Size-Class 布局的按钮</h3><p>这个示例使用了两套不同的约束。一个是为 Any-Any 布局设置的，这套约束定义了一对等宽的按钮，与 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW4" target="_blank" rel="noopener">两个等宽按钮</a> 一节的布局完全相同。</p>
<p>另一套约束是为 Compact-Regular 布局设置的，这套约束定义了一对堆叠起来的按钮，如下图所示</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Buttons_with_Size_Class_Based_Layout_2x.png" width=500>

<p>垂直堆叠的按钮布局用于 iPhone 的垂直模式，而水平按钮行则用于其他 Size-Class 模式。</p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><p>类似两个等宽按钮示例那样放置两个按钮，在 Any-Any 类型下，设置约束 1 到 6。然后将 IB 的 Size-class 切换到 Compact-Regular 模式。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Setting_the_Compact_Regular_Layout_2x.png" width=500>

<p>去除约束 2 和约束 5，然后添加约束 7、8 和 9。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/compact-regular_layout_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Long <span class="keyword">Button</span>.Leading = <span class="keyword">Short</span> <span class="keyword">Button</span>.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Long <span class="keyword">Button</span>.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Short</span> <span class="keyword">Button</span>.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = Long <span class="keyword">Button</span>.Botton + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Width = Long <span class="keyword">Button</span>.Width</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> Long <span class="keyword">Button</span>.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> <span class="keyword">Short</span> <span class="keyword">Button</span>.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> Long <span class="keyword">Button</span>.<span class="keyword">Top</span> = <span class="keyword">Short</span> <span class="keyword">Button</span>.<span class="keyword">Bottom</span> + Standard</span><br></pre></td></tr></table></figure>

<h4 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h4><p>设置按钮的背景颜色从而更容易查看它们的 frame 是否会根据设备的旋转而变化，另外，还要使用不同长度的文案，从而能够体现按钮的文案不会影响按钮宽度的效果。</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Short Button</td>
<td>Background</td>
<td>Light Gray Color</td>
</tr>
<tr>
<td>Short Button</td>
<td>Title</td>
<td>short</td>
</tr>
<tr>
<td>Long Button</td>
<td>Background</td>
<td>Light Gray Color</td>
</tr>
<tr>
<td>Long Button</td>
<td>Title</td>
<td>Much Longer Button Title</td>
</tr>
</tbody></table>
<h4 id="讨论-7"><a href="#讨论-7" class="headerlink" title="讨论"></a>讨论</h4><p>IB 能让你设置基于 Size-Class 确定的 view、view 属性和约束。它允许你为三种不同的尺寸类别（Compact、Any、Regular）和长度、宽度确定不同的选项，总共有九种不同的 size-class。其中四种对应于设备上使用的 final size-class(Compact-Compact, Compact-Regular, Regular-Compact, 和 Regular-Regular)，剩下的对应于基类或抽象表现类(Compact-Any, Regular-Any, Any-Compact, Any-Regular, 和 Any-Any)(基于我对 size-class 的理解，我对这块的翻译很不满意)</p>
<p>当在一个给定的 size-class 下加载布局时，系统会为这个 size-class 加载最确定的设置。这意味着 Any-Any size-class 会定义所有 view 都使用的默认值。Compact-Any 设置会定义所有 view 一个紧凑的宽度，而 Compact-Regular 设置只会被用于紧凑宽度和常规高度的 view。当视图的 size-class 发生变化时，例如，当一个 iphone 从垂直旋转为水平模式时，系统会自动地转换布局，并用动画呈现这一变化。</p>
<p>你可以使用这一特性来为 iphone 不同的设备朝向创建不同的布局，也可以使用它来创建不同的 iPad 和 iphone 布局。这种基于特定 size-class 的定制化布局可以根据你想要的效果变得极为宽广也可以极为简易。当然，你的改变越多，storyboard 也就越复杂，而设计和维护也就越困难。</p>
<p>要记住，你需要确保对于每一种可能的 size-class 你都有可行的布局与之对应，包括所有的 size-class 基类。作为一个一般规则，选择一种布局作为你的默认布局会是一种最简单的方法。在 Any-Any size-class 下设计这种布局，然后按照需要修改 Final size-class。记住，你可以在更具体的 size-class 中添加或修改元其中的元素。</p>
<p>要创建更复杂的布局，你可能希望在开始创建布局前绘制出 size-class 的九宫格。九宫格帮助你看到哪些约束会被多种 size-class 共享，并帮助你找到布局和 size-class 的最佳混合。</p>
<p>查看更多使用 size-class 的信息请前往 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH22-SW1" target="_blank" rel="noopener">调试 AutoLayout</a></p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoLayout指南·概述·详解约束</title>
    <url>/2017/12/26/AutoLayout/AutoLayout%E6%8C%87%E5%8D%97%C2%B7%E6%A6%82%E8%BF%B0%C2%B7%E8%AF%A6%E8%A7%A3%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="AutoLayout指南·概述"><a href="#AutoLayout指南·概述" class="headerlink" title="AutoLayout指南·概述"></a>AutoLayout指南·概述</h1><h2 id="详解约束"><a href="#详解约束" class="headerlink" title="详解约束"></a>详解约束</h2><p>AutoLayout 用一系列的线性约束来实现视图层级的布局，每一个约束对应一个等式。你的目标就是声明一系列的等式，这些等式有且仅有一个可能的解。</p>
<p>下面就是一个简单的等式的例子</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/view_formula_2x.png" width=500>

<p>译者注：由于APP所处环境的不同，布局可能会不同，像英文环境中，页面布局是从左到右布局，而像阿拉伯语环境中，页面布局是从右到左的布局方式，因此有了Leading和Trailing的概念，为的就是一次布局后可以正常的显示在多种语言环境中。</p>
<p>这个约束表示红色 view 的头部(Leading)必须在蓝色 view 尾部(Trailing)之后相距 8 个单位的位置。等式由以下几个部分组成</p>
<ul>
<li>Item 1，在这个例子中就是等式的第一个元素红色 view，它必须是一个 view 或者是一个 layout guide</li>
<li>Attribute 1，第一个元素被约束的属性，在这个例子中就是红色 view 的头部边缘(LeadingEdge)</li>
<li>RelationShip，等式左边与右边的关系，可以是相等，大于等于，小于等于三种关系中的一种。在这里用到了相等关系</li>
<li>Mutiplier，乘数因子，属性 2 的值会被乘以这个浮点数，在这里 mutiplier 等于 1.0</li>
<li>Item 2，等式的第二个元素，在这里就是蓝色 view，不像第一个 item，这里的 item 可以为空</li>
<li>Attribute2，第二个元素被约束的属性，在这个例子中就是蓝色 view 的尾部，如果第二个 Item 为空，则 Attitude2 就不能为一个属性</li>
<li>Constant，常量因子，一个浮点数常量，在这里就是 8.0，这个值会和 Attribute2 的值进行加和</li>
</ul>
<p>在我们的界面中，大多数约束都定义了两个元素之间的关系。这些元素可以是 view 或者 layout guide。约束也可以用于定义单个元素的两个属性之间的关系，比如设置一个元素的长宽比。你也可以对一个元素的宽或高声明一个常量，此时上述表达式中的第二个元素和第二个属性就是空的，而 mutiplier 则为 0.0。</p>
<h3 id="Auto-Layout-属性"><a href="#Auto-Layout-属性" class="headerlink" title="Auto Layout 属性"></a>Auto Layout 属性</h3><p>在 AutoLayout 中属性定义了一中可以被约束的特性。一般来说，属性包括四条边缘（Leading、Trailing、Top、Bottom），以及 width、height、centerX 和 centerY。而文本元素还包含一个或多个基线(Baseline)属性。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/attributes_2x.png" width=500>

<p>在 <a href="https://developer.apple.com/documentation/uikit/nslayoutconstraint.attribute" target="_blank" rel="noopener">NSLayoutAttribute</a> 中枚举了全部的属性。</p>
<blockquote>
<p>注意</p>
<p>虽然 OSX 和 iOS 都用到 NSLayoutAttribute 枚举值，但是它们在定义上仍有一些细微的差别。所以在查看属性列表时要确保查看的属性列表对应的是正确的平台文件</p>
</blockquote>
<h3 id="约束关系式示例"><a href="#约束关系式示例" class="headerlink" title="约束关系式示例"></a>约束关系式示例</h3><p>AutoLayout 的约束关系式的大量参数和属性使你可以创造出各种各样的约束。你可以定义 View 之间的间距，对齐 view 的边线，定义两个 View 之间的相对尺寸，甚至定义一个 view 的长宽比。但是并不是所有属性都可以相互兼容(搭配到一起进行约束的设置)。</p>
<p>属性大致可以分为两类，一类是 size 属性（比如 Height 和 Width），一类是 location 属性（比如 Leading, Left, 和 Top）。size 属性被用于确定元素有多大，但没有指定这个元素的位置。location 属性被用于确定元素相对于其他元素的位置，但没有指定元素的尺寸大小。</p>
<p>由于属性之间有这些差别，因此在约束中要注意以下几个规则：</p>
<ul>
<li>不能用 size 属性约束 location 属性</li>
<li>不能用常量设置 location 属性</li>
<li>不能用除了 1.0 之外的因子给 location 属性使用</li>
<li>对于 location 属性，不能用垂直属性约束水平属性</li>
<li>对于 location 属性，不能用 Leading 和 Trailing 约束 Left 和 Right</li>
</ul>
<p>例如，在没有其他上下文信息的情况下，将一个元素的 top 设置为常量 20.0 是没有任何意义的。你必须总是定义一个元素的 location 属性与其他元素的location属性之间的关系，比如设置一个元素在父 view 的顶部（Top）下方 20 单位长的距离处。然而，设置一个元素的高度为 20.0 却是有意义的。查阅 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW22" target="_blank" rel="noopener">Interpreting Values</a> 获取更多信息。</p>
<p>下面列举一些常见的约束关系式。</p>
<blockquote>
<p>注意</p>
<p>本章节所有表达式均由伪代码组成，查看正式代码编写的关系式请前往 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html#//apple_ref/doc/uid/TP40010853-CH16-SW1" target="_blank" rel="noopener">Programmatically Creating Constraints</a> 或 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH3-SW1" target="_blank" rel="noopener">Auto Layout Cookbook</a></p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置一个常量高度</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>height = <span class="number">0.0</span><span class="operator"> * </span>NotAnAttribute + <span class="number">40.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置两个按钮的固定距离</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Button_2</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Button_1</span>.</span></span>trailing + <span class="number">8.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 声明两个按钮的左边线</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Button_1</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Button_2</span>.</span></span>leading + <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置两个按钮等宽</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Button_1</span>.</span></span>width = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Button_2</span>.</span></span>width + <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将一个 view 在父 view 中居中</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>centerX = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>centerX + <span class="number">0.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>centerY = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>centerY + <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置一个 view 的长宽比</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>height = <span class="number">2.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>width + <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<h3 id="相等、而非赋值"><a href="#相等、而非赋值" class="headerlink" title="相等、而非赋值"></a>相等、而非赋值</h3><p>一定要注意约束关系式表达的是相等关系、而非进行属性赋值。</p>
<p>当 AutoLayout 处理这些关系式时，它不仅仅是将等式右边的值赋给左边，取而代之的是，它会计算 Attribute1 和 Attribute2 的值并保证二者符合关系式。这意味着我们可以自由地在等式中重新组合元素，下面列举了与上一节的表达式列表相同约束而不同形式的表达式。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置两个按钮之间固定距离</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Button_1</span>.</span></span>trailing = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Button_2</span>.</span></span>leading - <span class="number">8.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 声明两个按钮的左边线</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Button_2</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Button_1</span>.</span></span>leading + <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置两个按钮等宽</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Button_2</span>.</span></span>width = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Button</span>.</span></span>width + <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使一个 view 在父 view 中居中</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>centerX = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>centerX + <span class="number">0.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>centerY = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>centerY + <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置一个 view 的长宽比</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>width = <span class="number">0.5</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>height + <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>在变换元素顺序时要注意转换乘数因子和常量因子。例如常量 8.0 需要变为 -8.0，常量因子 2.0 要变换为 0.5。而常量因子 0.0 和乘数因子 1.0 则保持不变。</p>
</blockquote>
<p>你会发现 AutoLayout 经常提供多种方式来解决相同的问题，所以你需要选择一种最清晰的表达方式。但无疑不同的开发者对最清晰的表达方式有不同的看法，此时保持一致比保持正确更重要。如果你不能一直保持同一种表达方式，那么你将不断在使用中遇到各种问题。比如这篇指南就用到了以下一些规则：</p>
<ul>
<li>优先使用整数乘数因子，好过于小数乘数因子</li>
<li>优先使用正数作为乘数因子，好过于使用负数作为常数因子</li>
<li>在任何位置中的view， 布局都应该遵照：从前(Leading)到后(Trailing)，从上(Top)到下(Bottom)的顺序</li>
</ul>
<h3 id="创建无歧义、可满足的布局"><a href="#创建无歧义、可满足的布局" class="headerlink" title="创建无歧义、可满足的布局"></a>创建无歧义、可满足的布局</h3><p>使用 AutoLayout 要达到的目的是提供一系列的约束表达式，同时有且仅有一个可行解。有歧义的约束表达式则会出现多个可行解。不可满足的约束表达式没有可行解。</p>
<p>一般来说，每一个 view 的尺寸和位置都必须被约束。假设父 view 的尺寸已经设置好（比如是 iOS 上一个 Scene 的根视图），对于每一个 View 的每一个维度，一个无歧义、可满足的表达式都需要至少两个约束来表达（不算父视图）。但是你可以采取不同的方式去实现你想要的效果。比如下面三种布局都是用无歧义、可满足的表达式实现的(只展示了水平约束)</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/constraint_examples_2x.png" width=500>

<ul>
<li>第一个布局约束了 view 的头部与父视图头部的关系，以及 view 的固定宽度，这样根据父视图的尺寸和其他约束就可以计算边线的位置。</li>
<li>第二个布局约束了 view 的头部及尾部与父视图的关系。根据父视图的尺寸和其他约束就可以计算出这个 view 的宽度。</li>
<li>第三个布局约束了 view 的头部与父视图的关系，同时将 view 居中展示在父视图中。根据父视图的尺寸和其他约束就可以计算出这个 view 的边线位置和宽度。</li>
</ul>
<p>注意每一个布局都由一个 view 和两个水平约束组成。在每一种情况中都定义了 view 的宽度和水平位置。这意味着这些布局在水平轴向上符合无歧义、可满足的布局要求。但是当父视图的宽度发生改变时这些约束可能就无法正常生效了。</p>
<p>在第一个布局中，view 的宽度不会改变，很多时候这并不是你需要的效果。事实上，作为一个普遍适用的规则，你应该避免将 view 的尺寸声明为一个常量。AutoLayout 是被设计用于在不同的设备环境下动态适应和改变布局的利器，而当你给 view 赋值了一个固定尺寸之后这一特性就将无法生效了。</p>
<p>可能没有那么显著，但其实第二个布局和第三个布局的表现是相同的。它们俩都维护了当前视图与父视图之间的固定边缘留白，无论父视图的宽度如何改变。然而它们并不是完全相同的。一般来说，第二个示例会更容易理解，但第三个示例却更有效，尤其是当你需要居中放置很多元素的时候。所以你应当始终为你的布局选择最好的实现方式。</p>
<p>现在考虑一些更复杂的布局情况。想象一下如果你想在 iPhone 的屏幕上并排展示两个 view，你需要确保它们的每条边都有合适的边缘留白，同时它们总是有相同的宽度。并且当设备屏幕发生旋转时它们应当正确地修正它们的尺寸。</p>
<p>下面的插图展示了屏幕在竖直和水平方向时这两个 view 的展示情况。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Blocks_Portrait_2x.png" width=500>

<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Blocks_Landscape_2x.png" width=500>

<p>所以我们应当如何进行约束设置呢？下面的插图展示了一种最直接的约束方式。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_view_example_1_2x.png" width=500>

<p>上图用到了以下这些约束</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 垂直约束</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>top = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>top + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>bottom = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>bottom + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>top = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>top + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>bottom = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>bottom + <span class="number">20.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 水平约束</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>leading + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>trailing + <span class="number">8.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>trailing = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>trailing + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>width = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>width + <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>遵循前文提到的布局规则，这里有两个 view，四条垂直约束和四条水平约束。尽管不是最可靠的，但确实能保证实现你需要的效果。更重要的是，这些约束唯一确定了两个 view 的尺寸和位置，生成了无歧义、可满足的布局。移除任何一条约束都将导致约束有歧义，而添加额外的约束可能引入布局冲突。</p>
<p>但是这并不是约束实现的唯一方式。下面有一个与之等同的实现途径</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_view_example_2_2x.png" width=500>

<p>除了固定蓝色视图的顶部(top)和底部(bottom)与它们的父视图之间的距离，你可以让蓝色视图的顶部(top)与红色视图的顶部(top)对齐。同样地，让蓝色视图的底部(bottom)与红色视图底部(bottom)对齐。下面是详细的约束</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 垂直约束</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>top = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>top + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>bottom = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>bottom + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>top = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>top + <span class="number">0.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>bottom = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>bottom + <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 水平约束</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>leading + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>trailing + <span class="number">8.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Superview</span>.</span></span>trailing = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>trailing + <span class="number">20.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>width = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>width + <span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>这种方式也包含了两个 view 和四条垂直约束、四条水平约束，同时也是无歧义可满足的布局。</p>
<blockquote>
<p>但是哪种方式更好呢？</p>
<p>两种方式都实现了需要的布局效果，但是哪种方式更好呢？<br>很不幸，并没有客观可行的方式去证明其中一种方式优于另一种，每种方式都有其优点和不足。</p>
<p>第一种方式在移除 view 时表现更健壮。从视图层级中移除一个 view 的同时也会移除与之相关的所有引用。所以如果你移除了红色的 view，蓝色的 view 将会剩下三条约束规则。你只需要加入一条约束就可以再次正确实现约束布局。而第二种方式下移除红色 view 将使得蓝色 view 只剩下一条约束。</p>
<p>但另一方面，在第一种情况下，如果你需要使 view 的顶部和底部对齐，你需要保证他们的约束使用了相同的常数值，如果你改变了其中一个常数值，你需要记得同时修改 view 对应的另一个常数值。</p>
</blockquote>
<h3 id="约束不等式"><a href="#约束不等式" class="headerlink" title="约束不等式"></a>约束不等式</h3><p>到目前为止，所有的示例都是展示的约束等式，但这只是故事的一部分。约束也可以以不等式的形式表示。特别地，约束之间的关系可以是相等的，大于等于的，或者小于等于的。</p>
<p>例如，你可以用约束来定义一个view的最小尺寸或最大尺寸，如表3-3：</p>
<p>表3-3 设置一个最小和最大尺寸</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置最小宽度</span></span><br><span class="line">View.width &gt;= <span class="number">0.0</span> * NotAnAttribute + <span class="number">40.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置最大宽度</span></span><br><span class="line">View.width &lt;= <span class="number">0.0</span> * NotAnAttribute + <span class="number">280.0</span></span><br></pre></td></tr></table></figure>

<p>一旦你开始用不等式时，每个视图的每个维度的两个约束就失效了。你可以总是用两个不等式替换一个等式。在表3-4中，一个等式关系和一对不等式关系都产生相同的结果。</p>
<p>表3-4 用两个不等式替换一个等式</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个单独的等式关系</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>leading = <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>trailing + <span class="number">8.0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可以被两个不等式关系替换</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>leading &gt;= <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>trailing + <span class="number">8.0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Blue</span>.</span></span>leading &lt;= <span class="number">1.0</span><span class="operator"> * </span><span class="module-access"><span class="module"><span class="identifier">Red</span>.</span></span>trailing + <span class="number">8.0</span></span><br></pre></td></tr></table></figure>

<p>相反却不一定成立，因为两个不等式不一定等于一个等式关系。例如，在表3-3中的不等式限定了这个视图的宽度的可能值范围–但是对于它们本身，它们没有定义宽度。你仍然需要在这个范围内附加横向约束来定义视图的位置和宽度。</p>
<p>译者注：这一段的中心思想是，一个等式可以用两个不等式来表示，但是两个不等式不能表示一个等式。</p>
<h3 id="约束优先级"><a href="#约束优先级" class="headerlink" title="约束优先级"></a>约束优先级</h3><p>默认情况下所有的约束都是必需的。AutoLayout 必需计算出满足所有约束的唯一可行解。如果无法计算出这一可行解就会出错。AutoLayout 会在控制台打印出未满足的约束的信息，并随机打破一个约束条件。然后它就会计算出没有这一约束条件下的可行解。具体请看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ConflictingLayouts.html#//apple_ref/doc/uid/TP40010853-CH19-SW1" target="_blank" rel="noopener">Unsatisfiable Layouts</a>。</p>
<p>你也可以创建一些可选的约束。所有的约束都有一个从 1 到 1000 的优先级，只有优先级为 1000 的约束是必须的，其他都是可选的。</p>
<p>当计算可行解时，AutoLayout 会按照优先级从高到低，尝试满足所有的约束条件。如果它无法满足一个可选的约束条件，则会跳过这一约束条件并继续计算下一个约束条件。</p>
<p>可选的约束即使无法被满足仍然可以对布局产生影响。如果在跳过这一约束后布局发生了歧义，那么系统会选择一种最接近被跳过的约束条件的可行解，在这种情况下，未满足的可选约束作为一种力量让视图向它们靠拢。</p>
<p>可选约束一般会和不等式约束成对出现。比如在 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW9" target="_blank" rel="noopener">Listing 3-4</a> 中你可以给两张不等式设置不同的优先级。可以设置大于等于关系式为必须的，而小于等于关系式为可选的（优先级250）。这意味着蓝色 view 与红色 view 的间距不会小于 8 个像素点。但是其他约束可以将它们拉开更大的距离。同样的，可选约束会基于其他约束条件，确保蓝色 view 与红色 view 尽可能接近 8 个像素点的间距。</p>
<blockquote>
<p>注意</p>
<p>不要认为所有优先级都设置为 1000 是最靠谱的方式。优先级应当有基本的四种系统定义的类型，low（250），medium（500），high（750），必需（1000）。你可能需要将其中一些约束优先级设置得高出其他优先级 1 到 2 个点以防止布局错乱。如果你所使用的优先级远超出这四种，你可能需要重新审查你的布局逻辑。</p>
<p><a href="https://developer.apple.com/documentation/uikit/uilayoutpriority" target="_blank" rel="noopener">UILayoutPriority</a> 里有优先级的所有预定义值。</p>
</blockquote>
<h3 id="固有内容尺寸-intrinsic-content-size"><a href="#固有内容尺寸-intrinsic-content-size" class="headerlink" title="固有内容尺寸(intrinsic content size)"></a>固有内容尺寸(intrinsic content size)</h3><p>到目前为止，所有的示例都是用约束的方式来定义视图的位置和它们的大小的。然而有一些 view 可以根据所含内容确定其自身的自然尺寸。这种属性被称为 intrinsic content size。比如一个按钮的 intrinsic content size 就是它的 title 的尺寸加上一个小边距。</p>
<p>并不是所有 view 都有 intrinsic content size，对于有这一属性的 view 来说，intrinsic content size 可以定义它的高度、宽度或者两者都有。下面是一些常见的示例</p>
<p>一般继承自UIControl的视图都有固有内容尺寸</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Intrinsic Content Size</th>
</tr>
</thead>
<tbody><tr>
<td>UIView 和 NSView</td>
<td>没有 intrinsic content size</td>
</tr>
<tr>
<td>Sliders</td>
<td>iOS 上只定义宽度，OSX 上会根据 slider 类型定义宽度或者高度</td>
</tr>
<tr>
<td>Label，Button，Switch，TextFiled</td>
<td>定义宽度和高度</td>
</tr>
<tr>
<td>TextView 和 ImageView</td>
<td>可变的 intrinsic content size</td>
</tr>
</tbody></table>
<p>intrinsic content size 是基于 view 当前所含内容确定的，一个 label 或者 buttton 的 intrinsic content size 是基于其所含文案的数目和字体确定的。对于其他 view，intrinsic content size 的确定更为复杂。例如，一个空白的 imageview 没有 intrinsic content size，一旦你添加一张图片，它的固有内容尺寸就被设置成了图片的尺寸。</p>
<p>一个 textView 的 intrinsic content size 会根据内容、是否可以滑动以及其他运用在这个 view 上的约束而变化。比如，对于可以滑动的 textView 没有 intrinsic content size，对于不能滑动的 textView，其 intrinsic content size 默认由其所包含文案不折行时的尺寸所确定。例如如果文案中没有折行符，intrinsic content size 就由布局单行文案所需的宽高来确定。如果你添加了约束来确定 view 的宽度，intrinsic content size 就会根据所给的宽度来确定展示文案所需的高度。</p>
<p>AutoLayout 在每一个维度上用一对约束来表示一个 view 的 intrinsic content size。其中内容压缩属性 content hugging 使 view 内聚从而更好贴合其内容，而抗压缩属性 content compression 则将 view 拓展从而避免内容被截断。</p>
<p>这些约束都用下面所示的不等式来表达，在这里 intrinsicHeight 和 intrinsicWidth 常量表示 intrinsic content size 所含的高度和宽度。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compression Resistance</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>height &gt;= <span class="number">0.0</span><span class="operator"> * </span>NotAnAttribute + IntrinsicHeight</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>width &gt;= <span class="number">0.0</span><span class="operator"> * </span>NotAnAttribute + IntrinsicWidth</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Content Hugging</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>height &lt;= <span class="number">0.0</span><span class="operator"> * </span>NotAnAttribute + IntrinsicHeight</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">View</span>.</span></span>width &lt;= <span class="number">0.0</span><span class="operator"> * </span>NotAnAttribute + IntrinsicWidth</span><br></pre></td></tr></table></figure>

<p>这些约束中的每一个约束均有其自己的优先级，默认情况下，view 的 content hugging 优先级默认为 250，compression resistance 优先级默认为 750。所以一个 view 很容易被延展，但不容易被压缩。对于大多数继承自 UIControl 的视图，这是符合预期的。例如，你可以安全地将一个 button 伸展出超出其 intrinsic content size 所定义的尺寸，但如果你压缩一个 button 则可能导致其内容被截断。Interface Builder 有时会修改这些优先级以防止被截断，具体请查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW2" target="_blank" rel="noopener">Setting Content-Hugging and Compression-Resistance Priorities</a></p>
<p>尽量在你的布局中使用 view 的 intrinsic content size，这将帮助你在内容发生变化时 view 的尺寸能动态适应，同时也会减少你需要创建的无歧义不冲突的约束的数目。但是你仍然需要配置 view 的 content-hugging 和 compression-resistance 属性（CHCR）。下面是处理 intrinsic content size 的一些指导建议：</p>
<ul>
<li>当你需要拉伸一系列 view 以充满一个区域时，如果所有 view 都有相同的 content-hugging 优先级，则这样的布局会产生歧义。AutoLayout 并不知道应该拉伸哪一个 view。</li>
</ul>
<p>一个常见的例子是一对 label 和 textfield，当你希望 label 保持 intrinsic content size，而 textfield 填满额外的空白区域时，你需要确保 textfield 的水平 content-hugging 优先级低于 label 的水平 content-hugging 优先级。</p>
<p>事实上，由于这样的例子很常见，IB 已经自动做了这些处理，它将所有 label 的 content-hugging 优先级设置为 251。如果你使用代码来设置布局，那么你需要自己修改 content-hugging 的优先级。</p>
<ul>
<li><p>如果 view 含有不可见的背景时（如 button 或者 label），尝试拉伸它们超出其 intrinsic content size 的值的时候可能会出现错误的或者意想不到的布局效果。虽然问题可能没有那么明显，因为文案只是被简单地展示到了错误的地方而已。为了阻止这样意想不到的拉伸，应当增加它们的 content-hugging 优先级。</p>
</li>
<li><p>基线 BaseLine 约束只有在 view 的尺寸满足其 intrinsic content size 时才会起作用，如果一个 view 被垂直拉伸或者压缩了，那么 baseline 约束将不能正确地对齐。</p>
</li>
<li><p>一些 view，例如 switch，应当始终保持其 intrinsic content size，所以要增加它们的 CHCR 优先级来阻止其被拉伸或者压缩。</p>
</li>
<li><p>避免赋值给 view 一个确定的 CHCR 优先级。一个 view 出现错误的尺寸总是好过发生布局冲突。如果一个 view 需要始终保持其 intrinsic content size，那么应当考虑使用一个非常高的优先级来代替（999）。这种方法一般可以保证 view 不会被压缩或拉伸，但是仍提供了一个压缩阈值从而确保你的 view 会在一个远大于或远小于你所预期的屏幕尺寸上正常显示。</p>
</li>
</ul>
<h3 id="intrinsic-content-size-与-fitting-size-对比"><a href="#intrinsic-content-size-与-fitting-size-对比" class="headerlink" title="intrinsic content size 与 fitting size 对比"></a>intrinsic content size 与 fitting size 对比</h3><p>intrinsic content size 就像是 AutoLayout 的一个输入值，当一个 view 含有 intrinsic content size 时，系统将会创建一些约束用于表示尺寸，同时根据这些约束来计算对应的布局。</p>
<p>而 fitting size 则是 AutoLayout 引擎的输出。它是基于 view 的约束计算出的一个尺寸。如果 view 用 AutoLayout 来布局它的子 view，那么系统就可以根据其内容来计算一个 fitting size 赋予它。</p>
<p>StackView 是一个很好的例子，如果没有其他约束，系统就会按照 StackView 的子视图和属性来计算它的尺寸。很多时候 StackView 都表现得像是有一个 intrinsic content size，你可以只使用一个水平或者垂直约束就能创建一个有效布局来定义它的位置。但其实它的尺寸是由 AutoLayout 计算得出而非输入 intrinsic content size 得出的。所以设置 StackView 的 CHCR 优先级是不会起作用的，因为它并没有 intrinsic content size 属性。</p>
<p>如果你需要使 StackView 的 fitting size 适配其外部的元素时，你可以创建显式的约束以捕捉这些关系，或者修改 StackView 的内部元素相对于外部元素外部元素的 CHCR 优先级。</p>
<h3 id="解读参数值"><a href="#解读参数值" class="headerlink" title="解读参数值"></a>解读参数值</h3><p>AutoLayout 的参数单位始终是 point(pt = px/scale)，然而这些测量值的确切含义取决于所涉及的属性和视图的布局方向。</p>
<table>
<thead>
<tr>
<th>AutoLayout 属性</th>
<th>参数值</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>Height Width</td>
<td>view 的尺寸</td>
<td>这些属性可以被声明为常量，或者与其他宽高属性绑定，不能是负数</td>
</tr>
<tr>
<td>Top Bottom Baseline</td>
<td>当下滑屏幕时这些参数会增加</td>
<td>这些参数只能与 CenterY，Top，Bottom 和 Baseline 属性绑定</td>
</tr>
<tr>
<td>Leading Trailing</td>
<td>对于一个从左到右的布局，当你向右移动时这些值会增加。对于一个从右到左的布局，当你向左移动时这些值会增加</td>
<td>这个参数只能与  Leading, Trailing, 和 Center X 绑定</td>
</tr>
<tr>
<td>Left Right</td>
<td>当你向右移动时这些参数会增加</td>
<td>这些参数只能与 Left、Right、CenterX 属性绑定。你应当尽量用 Leading 和 Trailing 属性来代替 Left 和 Right，这样可以使布局动态适应 view 的阅读方向。默认的阅读方向取决于用户所设置的系统语言。在 iOS 中，设置 view 的 semanticContentAttribute 属性可以确定是否在语言切换时进行布局方向转换</td>
</tr>
<tr>
<td>Center X Center Y</td>
<td>基于约束表达式其他属性而确定</td>
<td>CenterX 可以与 CenterX、Leading、Trailing、Right 和 Left 属性绑定。CenterY 可以与 CenterY、Top、Bottom、和 Baseline 属性绑定</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>Autolayout指南·调试 AutoLayout·错误类型</title>
    <url>/2017/12/26/AutoLayout/Autolayout%E6%8C%87%E5%8D%97%C2%B7%E8%B0%83%E8%AF%95%20AutoLayout%C2%B7%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="007-Autolayout指南·调试-AutoLayout"><a href="#007-Autolayout指南·调试-AutoLayout" class="headerlink" title="007-Autolayout指南·调试 AutoLayout"></a>007-Autolayout指南·调试 AutoLayout</h1><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>AutoLayout 中的错误可以大致分为三大类</p>
<ul>
<li>无法满足的布局。你的布局没有可行解，前往 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ConflictingLayouts.html#//apple_ref/doc/uid/TP40010853-CH19-SW1" target="_blank" rel="noopener">无法满足的布局</a> 查看更多信息</li>
<li>有歧义的布局。你的布局有两个或更多可能的解。前往 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AmbiguousLayouts.html#//apple_ref/doc/uid/TP40010853-CH18-SW1" target="_blank" rel="noopener">有歧义布局</a> 查看更多信息</li>
<li>逻辑错误。在你的布局逻辑中有 bug，前往 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LogicalErrors.html#//apple_ref/doc/uid/TP40010853-CH20-SW1" target="_blank" rel="noopener">逻辑错误</a> 查看更多信息</li>
</ul>
<p>大多数时候，真正的问题只是确定出了什么错误。你添加了你认为你需要的约束，但当你运行 app 时，事情并不像你希望的那样运转。</p>
<p>一般来说，当你理解了问题，解决方案也就显而易见了。移除冲突的约束，添加缺失的约束，调整优先级顺序使布局有一个明确的可行解。当然，要能够容易地理解问题则需要经过一些测试和错误。像其他技能一样，这也遵循熟能生巧的规律。</p>
<p>但是有时候问题会更加复杂，此时你可能需要查看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/DebuggingTricksandTips.html#//apple_ref/doc/uid/TP40010853-CH21-SW1" target="_blank" rel="noopener">调试技巧</a> 一节</p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoLayout指南·AutoLayout Cookbook·简单约束</title>
    <url>/2017/12/21/AutoLayout/AutoLayout%E6%8C%87%E5%8D%97%C2%B7AutoLayout%20Cookbook%C2%B7%E7%AE%80%E5%8D%95%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="AutoLayout指南·AutoLayout-Cookbook"><a href="#AutoLayout指南·AutoLayout-Cookbook" class="headerlink" title="AutoLayout指南·AutoLayout Cookbook"></a>AutoLayout指南·AutoLayout Cookbook</h1><h2 id="约束示例"><a href="#约束示例" class="headerlink" title="约束示例"></a>约束示例</h2><p>接下来的例子中将使用一些相对简单的例子实现一些常用的布局效果，这些例子可以作为基础构建块用于组建更大更复杂的布局。</p>
<p>查看示例的源码请查阅 <a href="https://developer.apple.com/sample-code/xcode/downloads/Auto-Layout-Cookbook.zip" target="_blank" rel="noopener">Auto Layout Cookbook</a></p>
<h3 id="单一-view"><a href="#单一-view" class="headerlink" title="单一 view"></a>单一 view</h3><p>这一节我们将一个红色 view 放进父视图中，并使其四个边线与父 view 保持一定的间距。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Simple_Single_View_Screenshot_2x.png" width=500>

<h4 id="视图和约束"><a href="#视图和约束" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>在 IB 中，拖拽一个 view 到你的场景中，然后改变其尺寸以填满场景，使用 Ib 向导选择一个与父视图四条边线相对合适的位置。</p>
<blockquote>
<p>注意</p>
<p>你并不需要完全保证 view 放置在正确的像素点位置上，当你设置完约束后，系统会自动帮你计算出正确的尺寸和位置。</p>
</blockquote>
<p>放置好 view 后设置如下约束</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/simple_single_view_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Red</span> View.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Red</span> View.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Red</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Red</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>为了给 view 配置一个红色背景，需要在属性检查器中设置如下属性</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Red View</td>
<td>Background</td>
<td>Red</td>
</tr>
</tbody></table>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>这一节示例中的约束使得红色 view 与父视图的边线保持了一个固定距离，对于左右边线，将 view 与父视图的 margin 相联系，对于上下边线，将 view 与父视图的 Layout guide 相联系。</p>
<blockquote>
<p>注意</p>
<p>系统会自动设置根 view 的边距使得左右边距为 16 或 20 个像素点（根据不同设备），上下边距为 0。这使得你非常容易将内容与不同的 control bar （statusbar，navigationbar，tabbar，toolbar 等）协同布局。</p>
<p>但是在这里你需要将内容放置在 bar 下面一点距离，因此你只能设置 view 自身的上下间距相对于 Layout guide 的间距。</p>
</blockquote>
<p>IB 默认会将 view 与父视图的边线设置 20 像素点的空白间距，将兄弟 view 之间边线设置 8 像素点空白间距。这意味着你应当在红色 view 的顶部与状态栏的底部使用 8 像素点的间距。但是当 iphone 横屏显示时，状态栏会隐藏，此时 8 像素点会显得比较拥挤。</p>
<p>因此应当总是在 app 中选择效果最好的布局，这里我们用固定 20 像素的间距设置 app 的顶部和底部，这使得约束逻辑尽量简单，同时在横屏和竖屏上的展示效果看起来也很合理，所以其他的布局或许会比默认的固定 8 像素点要好。</p>
<p>如果你需要一个能动态根据 bars 的展示和隐藏而调整自身的布局，你应当看看 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSimpleConstraints.html#//apple_ref/doc/uid/TP40010853-CH12-SW4" target="_blank" rel="noopener">Adaptive Single View</a></p>
<h3 id="自适应单一-view"><a href="#自适应单一-view" class="headerlink" title="自适应单一 view"></a>自适应单一 view</h3><p>这一节的示例将一个蓝色 view 以固定边距放置在父视图中，并填满父视图。但是不像上一节那样，蓝色 view 的顶部边距会随着 View 的上下文不同情况而变化。当存在状态栏时，view 会与状态栏保持 8 像素点间距，当状态栏不存在时，view 顶部会与父视图边线保持 20 像素点间距。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Adaptive_Single_View_Screenshot_2x.png" width=500>

<p>下面是简单 view 和自适应 view 的比较图</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/SideBySide_2x.png" width=500>

<h4 id="视图和约束-1"><a href="#视图和约束-1" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>在 IB 中，将一个 view 拖进场景中，设置其尺寸铺满场景，设置约束如下</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/adaptive_single_view_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Blue</span> View.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Blue</span> View.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Blue</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">750</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Blue</span> View.<span class="keyword">Top</span> &gt;= Superview.<span class="keyword">Top</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Blue</span> View.<span class="keyword">Bottom</span> + Standard (Priority <span class="number">750</span>)</span><br><span class="line"></span><br><span class="line">Superview.<span class="keyword">Bottom</span> &gt;= <span class="keyword">Blue</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br></pre></td></tr></table></figure>

<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>设置 view 背景为蓝色，设置如下属性</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Blue View</td>
<td>Background</td>
<td>Blue</td>
</tr>
</tbody></table>
<h4 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h4><p>这一节示例中为蓝色 view 的顶部和底部创建了一个自适应的边距，如果存在 bar，view 的边距就会与 bar 相距 8 像素，如果不存在 bar，view 就会与父视图的边距保持 20 像素。</p>
<p>示例用到了 LayoutGuide 去设置内容正确的位置。系统会基于 bar 的尺寸和是否展示将 LayoutGuide 放置在合适的位置。top LayoutGuide 会被放置在任何顶部 bar (例如 statusbar，navigationbar)的下边线。bottom LayoutGuide 会被放置在任何底部 bar 的上边线(例如 tabbar)。如果没有 bar，系统会将 LayoutGuide 放置在父视图相应的边线上。</p>
<p>示例利用一对约束来实现自适应视图的效果。首先是一个必需的约束，大于等于约束。这个约束保证了蓝色 view 的边线至少与父视图边线有 20 像素点距离。</p>
<p>然后是一个可选的约束，它尝试将 view 与对应的 LayoutGuide 保持 8 像素间距。由于这个约束是可选的，所以当系统无法满足这个约束的时候，会尝试尽量靠近这个约束的效果。所以这个约束像是弹簧一样将蓝色 view 系在 LayoutGuide 上。</p>
<p>如果系统没有展示 bar，则 LayoutGuide 与父视图的边线相等，此时蓝色 view 的边线与父视图边线既不能保持 8 像素间距也不能保持 20 像素间距，因此系统将无法满足可选约束，但它仍会尽量保证间距最小值为 20 像素。</p>
<p>如果 bar 存在，则两个约束都可以满足，因为所有的 bar 都有至少 20 像素的高度。所以如果系统将 view 与 bar 的边线保持 8 像素，也一定能满足 view 与父视图有至少 20 像素点的距离。</p>
<p>使用一对表现得像是相反力的约束在创建自适应布局时是非常常见的技术，当我们在 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html#//apple_ref/doc/uid/TP40010853-CH13-SW1" target="_blank" rel="noopener">Views with Intrinsic Content Size</a> 讲到 content-hugging 和 compression-resistance 的优先级时会再次用到它。</p>
<h3 id="两个等宽-view"><a href="#两个等宽-view" class="headerlink" title="两个等宽 view"></a>两个等宽 view</h3><p>这一节示例将展示两个 view，无论父视图的尺寸如何变化，它们始终保持等宽度。同时两个 view 会填满父视图，与父视图有一个固定间距，两个 view 之间也有一个标准空白间距。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Two_Equal_Width_Views_Screenshot_2x.png" width=500>

<h4 id="视图和约束-2"><a href="#视图和约束-2" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>在 IB 中拖两个 view 放进场景中，并使它们填满父视图。使用 guideline 设置它们与场景的间距。</p>
<p>不要担心不能使二者完全等宽，稍后可以用约束来精确保证这一效果。</p>
<p>放置好 view 后设置如下约束</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_equal_width_views_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">Yellow View.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Green</span> View.Leading = Yellow View.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="keyword">Green</span> View.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line">Yellow View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Green</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = Yellow View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Green</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line">Yellow View.Width = <span class="keyword">Green</span> View.Width</span><br></pre></td></tr></table></figure>

<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>在属性检查器中设置两个 view 的背景颜色</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Yellow View</td>
<td>Background</td>
<td>Yellow</td>
</tr>
<tr>
<td>Green View</td>
<td>Background</td>
<td>Green</td>
</tr>
</tbody></table>
<h4 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h4><p>这个布局显式地定义了两个 view 的顶部和底部间距，只要这些间距是相同的，这两个 view 就会有相同的高度。但是这并不唯一可能的实现方式，除了将绿色 view 与父视图的顶部和底部绑定，你也可以设置它与黄色 view 的顶部底部相等。对齐顶部和底部边线会显式地设置这些 view 相同的垂直布局。</p>
<p>即使是像这样一个相对简单的布局也可以用多种约束方式实现，一些会更加清晰，但是大多数都是等价的。每一个方式有其自己的优缺点，示例用到的方式有两个主要的优点。首先也是最重要的一点是，它很容易被理解，其次，这个布局可以最大限度保证其完整性，即使你从中移除一个 view。</p>
<p>从视图层级移除一个 view 的同时也会移除它上面的约束。对于这个例子，移除黄色 view 的同时，约束 1，2，4，6 和 8 也会被移除。但是剩下的三条约束仍可以使绿色 view 在其正确位置上，你只需要加入一条约束来定义绿色 view 左边线的位置就能修复这个布局了。</p>
<p>这个布局最大的缺点是你需要手动确保所有 view 的顶部约束和底部约束是相等的。改变其中一个约束的常数就会使视图展示出错。一般来说，用 IB 设置一个固定常量相对还比较容易，如果用拖拽方式创建约束就可能比较困难了。</p>
<p>当面对复杂而等价的诸多约束方式时，应当根据布局的上下文选择最容易理解和维护的方式。比如如果你需要居中一些不同尺寸的 view 时，最容易的方式是设置它们的 CenterX 属性，而其他布局可能设置 view 的边线或长宽会更容易一些。</p>
<p>更多关于选择最好的约束方式的信息请查阅 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW16" target="_blank" rel="noopener">Creating Nonambiguous, Satisfiable Layouts</a></p>
<h3 id="两个不同宽度的-view"><a href="#两个不同宽度的-view" class="headerlink" title="两个不同宽度的 view"></a>两个不同宽度的 view</h3><p>这个示例与上一节很类似，但是显著的不同在于这个示例中橙色 view 的宽度始终是紫色 view 的两倍。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Two_Different_Sized_Views_2x.png" width=500>

<h4 id="视图和约束-3"><a href="#视图和约束-3" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>像之前那样，简单向场景拖进两个 view 并放置在大致位置后设置约束如下</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_different_sized_views_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Purple</span> View.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Orange</span> View.Leading = <span class="keyword">Purple</span> View.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="keyword">Orange</span> View.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Purple</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Orange</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Purple</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Orange</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Orange</span> View.Width = <span class="number">2.0</span> x <span class="keyword">Purple</span> View.Width</span><br></pre></td></tr></table></figure>

<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><p>在属性检查器中设置 view 的背景颜色</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Purple View</td>
<td>Background</td>
<td>Purple</td>
</tr>
<tr>
<td>Orange View</td>
<td>Background</td>
<td>Orange</td>
</tr>
</tbody></table>
<h4 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h4><p>这个示例在宽度约束中使用了一个乘数因子，乘数因子只能被用在宽高的约束中，它能帮你设置不同 view 的相对尺寸。同时你也可以设置一个 view 的长宽比为一个常数。</p>
<p>IB 能让你用多种形式来表达一个乘数因子，可以是十进制整数、百分数、分数或者一个比值。</p>
<h3 id="两个有复杂宽度的-view"><a href="#两个有复杂宽度的-view" class="headerlink" title="两个有复杂宽度的 view"></a>两个有复杂宽度的 view</h3><p>这一节示例几乎和两个不同宽度的 view 的示例是一样的，但是这里你需要使用一对约束来定义对 view 的宽度定义一个更加复杂的效果。在一节里，系统将尝试使红色 view 的宽度是蓝色 view 宽度的两倍，而蓝色 view 至少要有 150 像素点的宽度。所以在 iphone 的竖屏模式下两个 view 的宽度几乎一样，但是在横屏模式下红色 view 的宽度很明显比蓝色 view 宽 2 倍。</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/Two_Views_with_Complex_Widths_Screenshot_2x.png" width=500>

<h4 id="视图和约束-4"><a href="#视图和约束-4" class="headerlink" title="视图和约束"></a>视图和约束</h4><p>在画布上放上两个 view，然后设置约束如下</p>
<img src="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/Art/two_views_with_complex_widths_2x.png" width=500>

<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Blue</span> View.Leading = Superview.LeadingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Red</span> View.Leading = <span class="keyword">Blue</span> View.Trailing + Standard</span><br><span class="line"></span><br><span class="line"><span class="keyword">Red</span> View.Trailing = Superview.TrailingMargin</span><br><span class="line"></span><br><span class="line"><span class="keyword">Blue</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Red</span> View.<span class="keyword">Top</span> = <span class="keyword">Top</span> Layout Guide.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Blue</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Bottom</span> Layout Guide.<span class="keyword">Top</span> = <span class="keyword">Red</span> View.<span class="keyword">Bottom</span> + <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Red</span> View.Width = <span class="number">2.0</span> x <span class="keyword">Blue</span> View.Width (Priority <span class="number">750</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Blue</span> View.Width &gt;= <span class="number">150.0</span></span><br></pre></td></tr></table></figure>

<h4 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h4><p>在属性检查器设置 view 的背景颜色</p>
<table>
<thead>
<tr>
<th>View</th>
<th>Attribute</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>Red View</td>
<td>Background</td>
<td>Red</td>
</tr>
<tr>
<td>Blue View</td>
<td>Background</td>
<td>Blue</td>
</tr>
</tbody></table>
<h4 id="讨论-4"><a href="#讨论-4" class="headerlink" title="讨论"></a>讨论</h4><p>示例用到了一对约束来控制 view 的宽度，一个可选的成比例的约束使红色 view 的宽度是蓝色 view 的 2 倍。而必需的大于等于约束则定义了蓝色 view 的最小宽度。</p>
<p>当父视图的左右边线距离大于等于 458（150 + 300 + 8）像素点时，红色 view 的宽度会是蓝色 view 的两倍。而如果父视图的左右间距小于这个值，则会保证蓝色 view 的宽度是 150 像素点，而红色 view 填充剩余的空间，并保持两个 view 之间有 8 个像素点的间距。</p>
<p>你可能已经发现了这种方式就是 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSimpleConstraints.html#//apple_ref/doc/uid/TP40010853-CH12-SW4" target="_blank" rel="noopener">Adaptive Single View</a> 一节提到的方法的变种。</p>
<p>你还可以用三个约束关系式拓展这种设计。例如你可以设置一个必需的约束对红色 view 的宽度进行限制，一个高优先级的可选约束限制蓝色 view 的宽度，然后一个低优先级的可选约束用于限制两个 view 的宽度比例。</p>
]]></content>
      <categories>
        <category>AutoLayout</category>
      </categories>
      <tags>
        <tag>AutoLayout</tag>
      </tags>
  </entry>
  <entry>
    <title>对 GIF 的裁剪与展示</title>
    <url>/2017/11/07/iOS%E5%BC%80%E5%8F%91/%E5%AF%B9%20GIF%20%E7%9A%84%E8%A3%81%E5%89%AA%E4%B8%8E%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<p>GIF 裁剪过程可以大致分为三步</p>
<ul>
<li>获取 GIF 的帧集合，并对每一帧图片进行裁剪后生成裁剪后的 UIImage 对象</li>
<li>裁剪后的 GIF 的 NSData 数据</li>
</ul>
<p>这里主要用到了 Image I/O 的相关接口，Image I/O framework 提供一种不透明的数据类型（opaque data types），从 CGImageSourceRef 获取图片数据，将图片数据写入到 CGImageDestinationRef。它提供一个范围很广的图片格式，包含 web 格式，动态图，原始相机数据等。</p>
<h2 id="获取帧集合并裁剪"><a href="#获取帧集合并裁剪" class="headerlink" title="获取帧集合并裁剪"></a>获取帧集合并裁剪</h2><p>首先是获取 GIF 的帧集合。</p>
<ul>
<li>通过 GIF 的 NSData 创建一个 CGImageSourceRef 对象</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)assetData, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>这里 CGImageSourceRef 就是一个代表图片的不透明的数据类型，它抽象了读取图像数据的通道，但本身不会读取图像的任何数据。</p>
<ul>
<li>获取 GIF 帧的个数</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</span><br></pre></td></tr></table></figure>

<p>对于 GIF 等 AnimateImage 对象可以包含多个 Image，这里 CGImageSourceGetCount 就可以获取到对应的源图片数据的帧数。</p>
<ul>
<li>获取帧集合并裁剪</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">NSTimeInterval</span> duration = (<span class="number">1.0</span>f / <span class="number">100.0</span>f) * count;</span><br><span class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGImageCreateWithImageInRect</span>(image, cropRect);</span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = [<span class="built_in">UIImage</span> imageWithCGImage:newImageRef];</span><br><span class="line">    [images addObject:newImage];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(image);</span><br><span class="line">&#125;</span><br><span class="line">animatedImage = [<span class="built_in">UIImage</span> animatedImageWithImages:images duration:duration];</span><br></pre></td></tr></table></figure>

<p>GIF 的一个重要属性是它的 duration 值，这里简单取为帧数的 10%，相当于每一帧的 duration 是 0.1s。SDWebImage 库的 SDWebImageGIFCoder.m 文件中提供了一种更准确的获取方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">float</span>)sd_frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index source:(<span class="built_in">CGImageSourceRef</span>)source &#123;</span><br><span class="line">    <span class="keyword">float</span> frameDuration = <span class="number">0.1</span>f;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> cfFrameProperties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(source, index, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *frameProperties = (__bridge <span class="built_in">NSDictionary</span> *)cfFrameProperties;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *gifProperties = frameProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *delayTimeUnclampedProp = gifProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFUnclampedDelayTime];</span><br><span class="line">    <span class="keyword">if</span> (delayTimeUnclampedProp) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *delayTimeProp = gifProperties[(<span class="built_in">NSString</span> *)kCGImagePropertyGIFDelayTime];</span><br><span class="line">        <span class="keyword">if</span> (delayTimeProp) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Many annoying ads specify a 0 duration to make an image flash as quickly as possible.</span></span><br><span class="line">    <span class="comment">// We follow Firefox's behavior and use a duration of 100 ms for any frames that specify</span></span><br><span class="line">    <span class="comment">// a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt;</span></span><br><span class="line">    <span class="comment">// for more information.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (frameDuration &lt; <span class="number">0.011</span>f) &#123;</span><br><span class="line">        frameDuration = <span class="number">0.100</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRelease</span>(cfFrameProperties);</span><br><span class="line">    <span class="keyword">return</span> frameDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 CGImageSourceCreateImageAtIndex 方法我们可以从一个 CGImageSourceRef 数据源中读到一个帧位的未解码图片数据，然后通过 CGImageCreateWithImageInRect 对这一帧数据进行裁剪后，解码生成一个 UIImage 对象，将其放入一个数组中。最后通过 [UIImage animatedImageWithImages: duration:] 方法来生成一个被裁剪后的 GIF 的 UIImage 对象。这时候 <strong>可以把这个 UIImage 对象赋给 UIImageView 对象来展示一个 GIF 图片</strong>。</p>
<p>最后要注意手动释放 CGImageSourceRef 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRelease(source);</span><br></pre></td></tr></table></figure>

<h2 id="获取裁剪后的-NSData"><a href="#获取裁剪后的-NSData" class="headerlink" title="获取裁剪后的 NSData"></a>获取裁剪后的 NSData</h2><p>如果要传输裁剪后的 GIF 图片给服务器，还需要将上一步得到的 UIImage 转化为 NSData 对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">size_t frameCount = animatedImage.images.count;</span><br><span class="line"><span class="built_in">NSTimeInterval</span> frameDuration = animatedImage.duration / frameCount;</span><br><span class="line"><span class="built_in">NSDictionary</span> *frameProperties = @&#123;</span><br><span class="line">                                  (__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary: @&#123;</span><br><span class="line">                                          (__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDelayTime: @(frameDuration)</span><br><span class="line">                                          &#125;</span><br><span class="line">                                  &#125;;</span><br><span class="line"><span class="built_in">NSMutableData</span> *mutableData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line"><span class="built_in">NSDictionary</span> *imageProperties = @&#123; (__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFDictionary: @&#123;</span><br><span class="line">                                           (__bridge <span class="built_in">NSString</span> *)kCGImagePropertyGIFLoopCount: @<span class="number">0</span></span><br><span class="line">                                           &#125;</span><br><span class="line">                                   &#125;;</span><br><span class="line"><span class="built_in">CGImageDestinationRef</span> destination = <span class="built_in">CGImageDestinationCreateWithData</span>((__bridge <span class="built_in">CFMutableDataRef</span>)mutableData, kUTTypeGIF, frameCount, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CGImageDestinationSetProperties</span>(destination, (__bridge <span class="built_in">CFDictionaryRef</span>)imageProperties);</span><br><span class="line"><span class="keyword">for</span> (size_t index = <span class="number">0</span>; index &lt; frameCount;index++) &#123;</span><br><span class="line">    <span class="built_in">CGImageDestinationAddImage</span>(destination, [[animatedImage.images objectAtIndex:index] <span class="built_in">CGImage</span>], (__bridge <span class="built_in">CFDictionaryRef</span>)frameProperties);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOL</span> success = <span class="built_in">CGImageDestinationFinalize</span>(destination);</span><br><span class="line"><span class="built_in">CFRelease</span>(destination);</span><br></pre></td></tr></table></figure>

<p>这里通过上一步得到的 UIImage 对象，首先获得 GIF 图的帧数，然后获得每一帧的 duration。同时创建一个 NSMutableData 的对象用于存储 GIF 图片的数据，然后创建一个 CGImageDestinationRef 来指定存入数据区（mutableData）、存入数据类型（kUTTypeGIF）和帧数（frameCount）。最后遍历 animatedImage 的每一个 UIImage 对象，依据每一帧的 duration 值存入 CGImageDestinationRef 对象中。执行完遍历操作后，mutableData 中就是我们需要的裁剪后的 GIF 图片的 NSData 数据。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>Block 深入学习</title>
    <url>/2017/08/20/iOS%E5%BC%80%E5%8F%91/Block%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Block 是 C 语言的扩充功能，实质是带有局部变量的匿名函数。其定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^ 返回值类型 参数列表 表达式</span><br></pre></td></tr></table></figure>

<p>具体使用有很多省略方法，可以查看 <a href="http://fuckingblocksyntax.com/" target="_blank" rel="noopener">How Do I Declare A Block in Objective-C?</a></p>
<p>Block 可以截获内部变量的值，但不能再进行改写，如果是 OC 对象类型的内部变量，可以调用变更其对象的方法，但不能重新赋值。要实现改写和赋值，必须用到 <code>__block</code> 说明符。</p>
<p>目前的 Block 没有实现对 C 语言数组的截获，因此要使用指针来实现。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> text[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    [printf(<span class="string">"%c"</span>, text[<span class="number">2</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样会报错，要改成下面的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *text = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    printf(<span class="string">"%c"</span>, text[<span class="number">2</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于 Block 的代码可以用 clang 进行转换，成为可以阅读的 C 语言源码，具体命令是 “clang -rewrite-objc 源文件名”，它会生成一个 cpp 文件。接下来分析各种情况下的 Block 源码实现。</p>
<h2 id="不截获变量"><a href="#不截获变量" class="headerlink" title="不截获变量"></a>不截获变量</h2><p>首先是不带局部变量的情况，也就是不涉及对 Block 之外的局部变量或者其他变量进行截获的情况。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(<span class="string">"Hello world\n"</span>);&#125;;</span><br><span class="line">    blk(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它转换后变为以下代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">printf(<span class="string">"Hello world\n"</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来分析下它的实现。</p>
<p>首先看 main 函数中，对于源码中的第一句对 block 的定义，main 函数是这样转换的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>

<p>其中包含以下几个元素，首先是一个函数指针，它将会负责执行我们定义的 Block，而它被赋值为一个 <code>__main_block_impl_0</code> 结构体实例，这个实例定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它定义了一些内部变量</p>
<ul>
<li><code>__block_impl</code> 类型的 impl</li>
<li><code>__main_block_desc_0</code> 类型的指针 Desc</li>
<li>还有一个初始化方法，这个方法接受一个函数指针，一个 <code>__main_block_desc_0</code> 指针，一个  flag 标志位。</li>
</ul>
<p>逐一来看，首先是 __block_impl，它的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里 isa 指针变量是个很重要的变量。首先要明确在 OC 中一切类的定义都是对象，同时 OC 包含对象实例、类、元类（metaClass）三种元素，isa 就是一个 Class 类型的指针，在实例中 isa 指向它的类对象，而类对象的 isa 指针指向它的元类，元类保存了类方法的列表，而类则保存了成员变量和成员方法的列表。元类的 isa 指针会指向元类的父类，最终指向一个根元类，根元类的 isa 指针则指向它本身形成一个闭环。所以 这里 isa 其实是指向 Block 的类对象。Flag 是个标志位，Reserced 是保留空间，而 FuncPtr 指针则会保存一个方法的指针。</p>
<p>实例、类、元类的继承关系如下图所示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/449095-3e972ec16703c54d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100" alt=""></p>
<p>然后是 <code>__main_block_desc_0</code> 类型的结构体，它的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到这里直接将结构体实例化并赋值给一个 <code>__main_block_desc_0_DATA</code> 变量。其中 reserved 也是保留位，<code>Block_size</code> 被赋值为结构体 <code>__main_block_impl_0</code> 的大小，也就是我们的 Block 的实际大小。</p>
<p>最后是一个初始化方法，这个方法具体内容很容易看明白，就是对一些内部变量的赋值，唯独 impl.isa 被赋值为 <code>_NSConcreteStackBlock</code> 的地址，这里相当于指明 impl 对象的类对象是 <code>_NSConcreteStackBlock</code>，因此 Block 实际上就是 OC 对象的一个对象而已，它的类可以是以下几种</p>
<ul>
<li><code>_NSConcreteStackBlock</code></li>
<li><code>_NSConcreteGlobalBlock</code></li>
<li><code>_NSConcreteMallocBlock</code></li>
</ul>
<p>之后涉及到局部变量截获并超出作用域可访问时就会区分它们的区别。</p>
<p>那么在 main 函数中如何使用到这个初始化函数呢</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA))</span><br></pre></td></tr></table></figure>

<p>它进行了初始化后转换为函数指针类型赋值给了 blk 变量，而初始化传入的参数第一个是 <code>__main_block_func_0</code>，它的参数含义就是一个方法的指针，而它的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>看到了我们定义的打印方法，所以最终 Block 内部的方法都会转换为一个静态 C 语言函数，命名方式为 Block 语法所属函数名和 Block 语法在函数中出现的顺序，这里的参数 <code>__cself</code> 变量是一个 <code>__main_block_impl_0</code> 指针，后面执行时会看到它。</p>
<p>因此在 main 函数中用 <code>(void *)__main_block_func_0</code> 方法指针和 <code>__main_block_desc_0_DATA</code> 结构体指针初始化了这个函数指针变量。</p>
<p>接下来就是调用部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br></pre></td></tr></table></figure>

<p>简化后可以看作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(blk-&gt;FunPtr)(blk);</span><br></pre></td></tr></table></figure>

<p>前面提过这个 FunPtr 在初始化时其实被赋值为了 <code>(void *)__main_block_func_0</code> 方法指针，这里就是对它的调用，而传入的 self 参数则是 blk 自身，符合这个方法的参数定义。</p>
<h2 id="截获基本类型局部变量"><a href="#截获基本类型局部变量" class="headerlink" title="截获基本类型局部变量"></a>截获基本类型局部变量</h2><p>首先看一段使用了非 <code>__blocking</code> 的局部变量的 Block 代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(fmt, value2);&#125;;</span><br><span class="line">    value2 = <span class="number">64</span>;</span><br><span class="line">    fmt = <span class="string">"new val = %d\n"</span>;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于没有使用 <code>__blocking</code> 修饰符所以这里修改局部变量对于 Block 运行是不会有影响的，打印结果是</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">val</span> = <span class="number">128</span></span><br></pre></td></tr></table></figure>

<p>那么它的实现代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;</span><br><span class="line">  <span class="keyword">int</span> value2;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _value2, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), value2(_value2) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> value2 = __cself-&gt;value2; <span class="comment">// bound by copy</span></span><br><span class="line"><span class="built_in">printf</span>(fmt, value2);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> value2 = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, value2));</span><br><span class="line">    value2 = <span class="number">64</span>;</span><br><span class="line">    fmt = <span class="string">"new val = %d\n"</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里基本过程和前面类似，主要关注对于局部变量的截获操作。可以看到在 <code>__main_block_impl_0</code> 方法的参数列表中多了两个参数，对应地在结构体 <code>__main_block_impl_0</code> 中也有两个成员变量 fmt 和 value2，而根据 OC 代码生成的方法函数 <code>__main_block_func_0</code> 只需要获取到 self 变量后就可以进行相关的打印操作了，因此截获自动变量就是在执行 Block 时，将 Block 所使用的自动变量值保存到 Block 结构体实例中。</p>
<p>由于截获后的数据并不能监听到原局部变量的值的变化，所以对原局部变量进行赋值或修改操作不能影响到 Block 结构体的成员变量，因此也不能改变 Block 内的值。</p>
<h2 id="Block-变量的截获操作"><a href="#Block-变量的截获操作" class="headerlink" title="__Block 变量的截获操作"></a>__Block 变量的截获操作</h2><p>如果要实现在 Block 内部保存值或者响应外部值的变化，可以通过静态变量、静态全局变量、全局变量来实现，也可以使用 <code>__block</code> 修饰符。</p>
<p>首先看静态变量和全局变量在 Block 的实现中是如何实现的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        global_val += <span class="number">1</span>;</span><br><span class="line">        static_global_val += <span class="number">1</span>;</span><br><span class="line">        static_val += <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    blk();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现预测如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> *static_val;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        global_val += <span class="number">1</span>;</span><br><span class="line">        static_global_val += <span class="number">1</span>;</span><br><span class="line">        (*static_val) += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于全局变量，无论是静态还是非静态，都可以被作用域内所有函数访问，包括 Block 函数，所以可以看到没有对它们进行额外的操作。而对于局部静态变量，由于 Block 方法域内要实现对这个静态变量的修改赋值操作，因此要进行地址传递，将静态局部变量的地址作为参数传给 Block 结构体，在 Block 方法内通过地址修改静态局部变量的值。</p>
<p>接下来是 <code>__block</code> 修饰符的实现过程</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        val = <span class="number">20</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    blk();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现预测如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        (val-&gt;__forwarding-&gt;val) = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实现中把 <code>__block</code> 修饰的变量用一个 <code>__Block_byref_val_0</code> 结构体存储，这个结构体的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中最重要的成员变量是 <code>__Block_byref_val_0</code> 指针，它的作用主要体现在可以使 Block 截获的变量超出其作用域，但是目前还没用到这一特性。</p>
<p>最终 <code>__block</code> 修饰的局部变量被初始化为一个结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>然后对于具体的赋值操作，实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        (val-&gt;__forwarding-&gt;val) = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>与静态局部变量的实现不同，这里的赋值操作是通过对 val 结构体实例的 <code>__forwarding</code> 指针的 val 成员变量进行赋值操作，当然在这里实际上就是对 val 结构体实例的 val 成员变量进行赋值，因此是可以改变原局部变量值的。</p>
<p>由于 block 变量的结构体 <code>__Block_byref_val_0</code> 被定义在全局范围，所以可以被多个 Block 复用。例如下面的代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^blk0)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        val = <span class="number">20</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^blk1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        val = <span class="number">20</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实现预测如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*blk0)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*blk1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_1((<span class="keyword">void</span> *)__main_block_func_1, &amp;__main_block_desc_1_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样将 Block 与 block 变量分离，可以便捷实现一个 Block 使用多个 block 变量或者一个 block 变量被多个 Block 使用。</p>
<h2 id="Block-存储域"><a href="#Block-存储域" class="headerlink" title="Block 存储域"></a>Block 存储域</h2><p>根据上面的解读，Block 实际上是栈上的结构体实例，block 变量也是栈上的结构体实例，而前面提过 isa 指针指向的是 Block 的类对象，它一般有三个值</p>
<ul>
<li><code>_NSConcreteStackBlock</code></li>
<li><code>_NSConcreteGlobalBlock</code></li>
<li><code>_NSConcreteMallocBlock</code></li>
</ul>
<p>这三个值实际上表达了 Block 的存储域，<code>_NSConcreteStackBlock</code> 将 Block 存储在栈上，<code>_NSConcreteGlobalBlock</code> 将 Block 存储在数据区域，<code>_NSConcreteMallocBlock</code> 将 Block 存储在堆上。</p>
<p><strong>要注意一点是，使用 clang 命令转换代码时可能会与实际实现有所不同。</strong></p>
<p>简单来说，在 Linux 下一个应用程序的内存分布如下所示</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序区域 .text</td>
<td>编译后程序的主体，也就是程序的机器指令</td>
</tr>
<tr>
<td>数据区域 .data</td>
<td>保存已初始化的全局变量</td>
</tr>
<tr>
<td>.bss</td>
<td>保存只声明没有初始化的全局变量</td>
</tr>
<tr>
<td>堆 heap</td>
<td>保存动态分配的内存，向高地址方向增长</td>
</tr>
<tr>
<td>栈 stack</td>
<td>用于函数调用，保存函数参数、临时变量、返回地址等，向低地址方向增长</td>
</tr>
</tbody></table>
<p>具体到 Block 中，定义在全局变量的 Block 以及在函数中但是没有截获局部变量的 Block 的 isa 都会被赋值为 <code>_NSConcreteGlobalBlock</code>，也就是会被存储在数据区域，而截获了局部变量或是 block 变量的 Block 则有些复杂。前面提到 block 变量是分配在栈上的，因此如果其所属变量作用域结束了，这个 block 变量也就被废弃了，但是事实上 Block 依然可以提供对 block 变量的跨作用域访问，这种机制的实现是将 Block 和 block 变量从栈上复制到堆上，由于堆的生命周期是由应用程序控制的，因而可以实现跨作用域的访问效果。而这时 Block 的 isa 指针就会指向 <code>_NSConcreteMallocBlock</code> 了。</p>
<p>一般来说当我们向方法或函数的参数中传递 Block 时，需要对 Block 进行手动复制操作，也就是执行 copy 方法，这一方法是没有副作用的，因此可以多次对一个 Block 调用。</p>
<table>
<thead>
<tr>
<th>Block 类</th>
<th>副本源的配置存储域</th>
<th>复制效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>_NSConcreteStackBlock</code></td>
<td>栈</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td><code>_NSConcreteGlobalBlock</code></td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td><code>_NSConcreteMallocBlock</code></td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody></table>
<p>当我们返回一个 Block 类型的返回值时，如果 Block 捕获了一个局部变量，这种我们也需要进行手动 copy 操作。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">blk_int func(<span class="keyword">id</span> rate)&#123;</span><br><span class="line">   <span class="keyword">return</span> [^(<span class="keyword">int</span> count) &#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">int</span>)rate * count;</span><br><span class="line">   &#125; <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果方法和函数已经复制了 Block 参数，就不需要手动复制了，包括以下情况</p>
<ul>
<li>Cocoa 框架的方法且方法名中含有 usingBlock 等</li>
<li>GCD 的 API</li>
</ul>
<h2 id="block-变量存储域"><a href="#block-变量存储域" class="headerlink" title="block 变量存储域"></a>block 变量存储域</h2><p>上节提到 Block 会从栈复制到堆，同时也会把 block 变量从栈复制到堆上，并且持有这一 block 变量，增加引用计数，最终 block 变量会按照引用计数的方式被管理。最关键的一点是，当 block 变量被复制到堆上以后，栈上还存在的 block 变量的 <code>__forwarding</code> 指针会指向堆上的 block 变量，而堆上的 <code>__forwarding</code> 指针则依然指向堆上的 block 变量自身。</p>
<p>看一段代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = [^&#123;++val;&#125; <span class="keyword">copy</span>];</span><br><span class="line">    ++val;</span><br><span class="line">    blk();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个 block 变量，并且分别在 Block 内外对它进行自增一操作，它的实现预测如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line">    ++(val.__forwarding-&gt;val);</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 Block 内部访问的是堆上的 block 变量，在 Block 外部访问的是栈上的 block 变量，但是由于都是通过 <code>__forwarding</code> 指针来访问的，所以实际效果都是访问到了堆上的 block 变量。</p>
<h2 id="截获-OC-对象"><a href="#截获-OC-对象" class="headerlink" title="截获 OC 对象"></a>截获 OC 对象</h2><p>对于 oc 对象也可以在 Block 中使用，并且会自动被 Block 截获。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> (^blk_t)(<span class="keyword">id</span> obj);</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        blk = [^(<span class="keyword">id</span> obj)&#123;</span><br><span class="line">            [array addObject:obj];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>, [array count]);</span><br><span class="line">        &#125; <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blk([<span class="built_in">NSObject</span> new]);</span><br><span class="line">    blk([<span class="built_in">NSObject</span> new]);</span><br><span class="line">    blk([<span class="built_in">NSObject</span> new]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们手动 copy 了 Block，但是在 ARC 下会自动帮我们 copy 所不用担心程序会强制结束的问题。下面是预测的实现源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  id <span class="built_in">array</span>;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, id _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : <span class="built_in">array</span>(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself, id obj) &#123;</span><br><span class="line">  id <span class="built_in">array</span> = __cself-&gt;<span class="built_in">array</span>; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            ((<span class="keyword">void</span> (*)(id, SEL, ObjectType))(<span class="keyword">void</span> *)objc_msgSend)((id)<span class="built_in">array</span>, sel_registerName(<span class="string">"addObject:"</span>), (id)obj);</span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_qj_zz_x2p3n7nv4t1r7gfbpd1q80000gn_T_SimpleBlock_267687_mi_0, ((NSUInteger (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)<span class="built_in">array</span>, sel_registerName(<span class="string">"count"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">blk_t</span>)</span><span class="params">(id obj)</span></span>;</span><br><span class="line">    <span class="keyword">blk_t</span> blk;</span><br><span class="line">    &#123;</span><br><span class="line">        id <span class="built_in">array</span> = ((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSMutableArray *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        blk = (<span class="keyword">blk_t</span>)((id (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((<span class="keyword">void</span> (*)(id))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="built_in">array</span>, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"new"</span>)));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"new"</span>)));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *, id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"new"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到大致过程与前面几种情况类似，但在 main 函数中对 Block 变量调用了 copy 方法，这个也是符合逻辑的。</p>
<p>当 Block 被从栈复制到堆的时候，会调用 <code>__main_block_copy_0</code> 方法，这个方法实际上调用的是 <code>_Block_object_assign</code> 方法，它会对 Block 的引用计数增加一。而当 Block 没有引用的时候，会被废弃，此时会调用 <code>__main_block_dispose_0</code> 方法，它实际上调用的是 <code>_Block_object_dispose</code> 方法，类似于 release 方法，释放 Block 对象。</p>
<p>调用 <code>_Block_object_assign</code> 方法的时机，也就是将 Block 从栈复制到堆的时机有</p>
<ul>
<li>调用 Block 的 copy 方法</li>
<li>Block 作为函数返回值</li>
<li>Block 赋值给 strong 变量或 Block 变量</li>
<li>方法名中含有 usingBlock 的 Cocoa 框架方法或 GCD 的 API</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里主要是对 《OC 高级编程》 第二章的总结，而第二章的论述很多是基于 MRC 的，实际上在 ARC 环境下，Block 一般都会直接分配在 <code>_NSConcreteMallocBlock</code> 上，因而很多 copy 操作不需要手动去做，一些会引发 crash 的操作也被做了保护，比如在作用域外，通过 block 对于一个数组进行操作，由于 block 被自动复制了，所以不会引发异常，对于 weak 变量也是同理。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Block</tag>
        <tag>ObjectiveC</tag>
      </tags>
  </entry>
</search>
