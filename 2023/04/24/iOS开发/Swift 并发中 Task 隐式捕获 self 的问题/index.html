<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Task 会隐式捕获 self 但没有编译提示，在大部分场景下这种特性并没有问题，但是遇到无限异步序列时容易造成循环引用问题">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift 并发中 Task 隐式捕获 self 的问题">
<meta property="og:url" content="http://yoursite.com/2023/04/24/iOS%E5%BC%80%E5%8F%91/Swift%20%E5%B9%B6%E5%8F%91%E4%B8%AD%20Task%20%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7%20self%20%E7%9A%84%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="Yasic Yu">
<meta property="og:description" content="Task 会隐式捕获 self 但没有编译提示，在大部分场景下这种特性并没有问题，但是遇到无限异步序列时容易造成循环引用问题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-23T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-26T03:32:31.223Z">
<meta property="article:author" content="Yasic Yu">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Swift 并发">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2023/04/24/iOS%E5%BC%80%E5%8F%91/Swift%20%E5%B9%B6%E5%8F%91%E4%B8%AD%20Task%20%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7%20self%20%E7%9A%84%E9%97%AE%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Swift 并发中 Task 隐式捕获 self 的问题 | Yasic Yu</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-158916051-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-158916051-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e11730c2477fa6748b6748c13059e7b1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yasic Yu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">In Code We Trust</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">50</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yasic" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/04/24/iOS%E5%BC%80%E5%8F%91/Swift%20%E5%B9%B6%E5%8F%91%E4%B8%AD%20Task%20%E9%9A%90%E5%BC%8F%E6%8D%95%E8%8E%B7%20self%20%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yasic Yu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yasic Yu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift 并发中 Task 隐式捕获 self 的问题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-24 00:00:00" itemprop="dateCreated datePublished" datetime="2023-04-24T00:00:00+08:00">2023-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">iOS开发</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">Task 会隐式捕获 self 但没有编译提示，在大部分场景下这种特性并没有问题，但是遇到无限异步序列时容易造成循环引用问题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h1><p>Swift Concurrency 的 Task 有两个常用的初始化方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(priority: <span class="type">TaskPriority?</span> = <span class="literal">nil</span>, operation: @escaping @<span class="type">Sendable</span> () async -&gt; <span class="type">Success</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">detached</span><span class="params">(priority: TaskPriority? = <span class="literal">nil</span>, operation: @escaping @Sendable <span class="params">()</span></span></span> async -&gt; <span class="type">Success</span>) -&gt; <span class="type">Task</span>&lt;<span class="type">Success</span>, <span class="type">Failure</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，两个方法的 <code>operation</code> 参数都是用 @escaping 修饰的，意味着 operation 是一个逃逸闭包，逃逸闭包会在声明后延长生命周期再执行，因此如果在一个类当中使用 Task，Task 内部又调用了类的方法，就会造成对 self 的隐式捕获。</p>
<p>这种 self 的隐式捕获是一个很常见的问题，例如下面的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            handle()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们用到了 GCD 调用 handle 方法，如果直接这样写就会触发 Xcode 的编译错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call to method 'handle' in closure requires explicit use of 'self' to make capture semantics explicit</span><br></pre></td></tr></table></figure>

<p>这是因为 Xcode 希望开发者通过显式调用 self.handle 的方式，提醒开发者这里发生了隐式捕获。需要注意的是，隐式捕获并不一定会造成内存泄漏，例如在这里，隐式捕获仅仅会因为捕获 self，导致 self 的生命周期延长到了下一个 runloop，一旦 GCD 执行结束，self 就可以正常释放，所以这里可以简单改为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">self</span>.handle()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在 Task 这里，情况有些不同，对于下面的代码，Xcode 是不会有任何提示的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            handle()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为前面提到的 Task 的两个初始化方法，在源码内部实际上会用 <code>_implicitSelfCapture</code> 关键词修饰 operation，<code>_implicitSelfCapture</code> 关键词可以让被修饰的 block 捕获 self 而不会触发显式捕获的错误，因为 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md#implicit-self" target="_blank" rel="noopener">Swift Concurrency 的设计者认为</a>，显式捕获 self 的意图是为了发现隐藏的循环引用，而 Task 的闭包会被 <strong>立即执行</strong>，所以看起来并不需要传递这种意图。</p>
<blockquote>
<p>The intent behind requiring self. when capturing self in an escaping closure is to warn the developer about potential reference cycles. The closure passed to Task is executed immediately, and the only reference to self is what occurs in the body. Therefore, the explicit self. isn’t communicating useful information and should not be required.  </p>
</blockquote>
<h1 id="隐式捕获的问题"><a href="#隐式捕获的问题" class="headerlink" title="隐式捕获的问题"></a>隐式捕获的问题</h1><p>看起来确实是这样，Task 通常情况下，包括在前面提到的场景下，都是会立即执行并结束的，它最多可能只会延长 self 的生命周期，并不会发生循环引用。</p>
<p>但在一些特殊情况下，这种预想就失效了，比如如果遇到了无限的异步序列 (AsyncSequence)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">            <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">                <span class="built_in">print</span>(notification)</span><br><span class="line">                handle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 Task 内部的 operation 监听了应用进入后台的通知，并通过 for await 对  notifications 异步序列进行了监听，也没有增加监听停止的条件，这样的代码就会造成 self 无法被释放。进一步分析会发现，这里真正捕获 self 的并不是 <strong>最外层的 Task</strong>，之所以这样说是因为如果我们将代码改为下面的形式，内存泄漏依然存在。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            await <span class="keyword">self</span>?.observeAppEnterBackground()</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">observeAppEnterBackground</span><span class="params">()</span></span> async &#123;</span><br><span class="line">        <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">        <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">            <span class="built_in">print</span>(notification)</span><br><span class="line">            handle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在初始化 Task 时，我们通过捕获列表已经将 self 弱引用捕获了，但是执行代码后， TestView 仍然无法释放。</p>
<p>实际上真正引发泄漏的是下面的代码，我们通过 for await 遍历无限异步序列 notifications，相当于代码陷入了死循环，而每一次 await 操作又会隐式捕获 self，造成了 self 无法被释放，可以简单认为，每一次 await 操作都会隐式生成一个新的 Task，而新的 Task 又会捕获 self，这才是造成循环引用的原因。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">    <span class="built_in">print</span>(notification)</span><br><span class="line">    handle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><h2 id="弱捕获-self"><a href="#弱捕获-self" class="headerlink" title="弱捕获 self"></a>弱捕获 self</h2><p>既然明确了在监听无限序列时因为捕获 self 导致了循环引用，解决思路也就有了，最传统的方式就是类似 GCD 和闭包引用一样，我们通过捕获列表将 self 引用变为弱引用，从而避免 Task 持有 self。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">            <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                <span class="built_in">print</span>(notification)</span><br><span class="line">                <span class="keyword">self</span>.handle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，由于真正发生捕获行为的地方是在 for await 的地方，因此如果像下面这样弱引用 self，是不能解决内存泄漏问题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">    <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">        <span class="built_in">print</span>(notification)</span><br><span class="line">        <span class="keyword">self</span>.handle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然通过 weakself 捕获， TestView 此时确实可以正常释放了，但是 Task 本身其实是脱离 TestView 的生命周期存在的，所以代码对 notifications 的监听并没有停止，验证这一点也很简单，我们将打印语句移动一下，就会发现即使 TestView 释放了，打印语句仍然会被执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">    <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">        <span class="built_in">print</span>(notification)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.handle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此正确的思路应该是取消 Task 执行。</p>
<h2 id="取消-Task"><a href="#取消-Task" class="headerlink" title="取消 Task"></a>取消 Task</h2><p>实际上 Swift Concurrency 并不推荐我们直接初始化一个 Task，因为这样初始化的 Task 是一个独立的根 Task，没有所属的父 Task，也就意味着 Task 的生命周期是独立存在的。Swift Concurrency 建议所有的 Task 都应该形成一个任务树，从而实现结构化编程。</p>
<blockquote>
<p>结构化编程：并发操作保证控制流路径的单一入口和单一出口  </p>
</blockquote>
<p>所以最合理的方式是这样修复。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task: <span class="type">Task</span>&lt;<span class="type">Void</span>, <span class="type">Never</span>&gt;?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        task?.cancel()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        task = <span class="type">Task</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> notifications = <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.notifications(named: <span class="type">UIApplication</span>.didEnterBackgroundNotification)</span><br><span class="line">            <span class="keyword">for</span> await notification <span class="keyword">in</span> notifications &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                <span class="built_in">print</span>(notification)</span><br><span class="line">                <span class="keyword">self</span>.handle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当 TestView 被释放时，对 UIApplication.didEnterBackgroundNotification 的监听也能正常取消。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://forums.swift.org/t/why-task-doesnt-need-explicit-use-of-self/58748/6" target="_blank" rel="noopener">Why Task { } doesn’t need explicit use of self? - #6 by AlexSedykh - Using Swift - Swift Forums</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md#implicit-self" target="_blank" rel="noopener">swift-evolution/0304-structured-concurrency.md at main · apple/swift-evolution · GitHub</a></li>
<li><a href="https://forums.swift.org/t/explicit-self-not-required-for-task-closures/54364/19" target="_blank" rel="noopener">Explicit self not required for Task closures? - #19 by kevinc - Using Swift - Swift Forums</a></li>
<li><a href="https://developer.apple.com/forums/thread/691814" target="_blank" rel="noopener">Swift 5.5 Task { … } weak self | Apple Developer Forums</a></li>
<li><a href="https://www.swiftwithvincent.com/blog/three-mistakes-to-avoid-with-async-await-in-swift" target="_blank" rel="noopener">3 mistakes to avoid with async / await — Swift with Vincent</a></li>
<li><a href="https://www.swiftbysundell.com/articles/memory-management-when-using-async-await/" target="_blank" rel="noopener">Memory management when using async/await in Swift | Swift by Sundell</a></li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2023/04/26/iOS开发/Swift 中的 some 和 any 关键字/" rel="bookmark">Swift 中的 some 和 any 关键字</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2018/02/02/iOS开发/Swift可选类型、隐式可选类型与可选链/" rel="bookmark">Swift可选类型、隐式可选类型与可选链</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2018/03/08/iOS开发/Swift实现二叉搜索树与字典树/" rel="bookmark">Swift实现二叉搜索树与字典树</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2018/03/02/iOS开发/Swift的autoclosure与escaping标签/" rel="bookmark">Swift的autoclosure与escaping标签</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Swift/" rel="tag"># Swift</a>
              <a href="/tags/Swift-%E5%B9%B6%E5%8F%91/" rel="tag"># Swift 并发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/28/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E%E7%BE%8E%E7%9A%84%E6%9C%AC%E8%83%BD%E2%80%94%E2%80%94%E3%80%8A%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0%E3%80%8B/" rel="prev" title="关于美的本能——《乔布斯传》">
      <i class="fa fa-chevron-left"></i> 关于美的本能——《乔布斯传》
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/26/iOS%E5%BC%80%E5%8F%91/Swift%20%E4%B8%AD%E7%9A%84%20some%20%E5%92%8C%20any%20%E5%85%B3%E9%94%AE%E5%AD%97/" rel="next" title="Swift 中的 some 和 any 关键字">
      Swift 中的 some 和 any 关键字 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#隐式捕获"><span class="nav-text">隐式捕获</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐式捕获的问题"><span class="nav-text">隐式捕获的问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何解决"><span class="nav-text">如何解决</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#弱捕获-self"><span class="nav-text">弱捕获 self</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取消-Task"><span class="nav-text">取消 Task</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#相关链接"><span class="nav-text">相关链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yasic Yu"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yasic Yu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Yasic" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yasic" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuxuan2580@gmail.com" title="E-Mail → mailto:yuxuan2580@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yasic Yu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
